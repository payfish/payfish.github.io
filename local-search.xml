<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2024/07/16/docker/"/>
    <url>/2024/07/16/docker/</url>
    
    <content type="html"><![CDATA[<h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p><strong>镜像</strong>：镜像不仅包含应用本身，还包含应用运行时所需的环境、配置、系统函数库。因为包含了环境，所以镜像可以运行在各种操作系统上</p><p><strong>容器</strong>：Docker在运行镜像时创建的一个隔离环境（进程），跟其他的进程相互隔离、互不干扰</p><p>镜像你可以把它看成Java中的类，而容器可以看做是类的实例化对象</p><p><img src="/2024/07/16/docker/docker%E9%83%A8%E7%BD%B2%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B.png"></p><h3 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e <span class="hljs-attribute">TZ</span>=Asia/Shanghai \<br>  -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=****** \<br>  mysql<br></code></pre></td></tr></table></figure><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name`` mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li>docker pull：从镜像仓库拉去镜像到本地</li><li>docker push：将制作好的镜像推送到镜像仓库</li><li>docker images：查看所有的本地镜像</li><li>docker rmi：删除本地镜像</li><li>docker build：通过DOCKERFILE打包制作镜像</li><li>docker save：保存镜像为一个压缩包</li><li>docker load：load压缩包为本地镜像</li><li>docker run：拉取镜像（如果本地没有），创建容器（每次创建一个新容器）</li><li>docker stop：停止容器，（停止容器内部的进程）</li><li>docker start：启动容器（启动停止的容器）</li><li>docker ps：查看容器的运行状态</li><li>docker rm：删除容器</li><li>docker logs：查看容器运行日志</li><li>docker exec：进入容器，执行操作</li><li>docker inspect：查看容器详细信息</li></ul><p><img src="/2024/07/16/docker/%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.png"></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>volume</strong>是一个虚拟目录，是容器内目录和宿主机目录之间映射的桥梁</p><p>docker提供的容器内运行环境只是满足镜像运行的最小环境，使用docker exec命令进入容器后，连vi命令都无法使用，而在外面的宿主机中使用这些命令特别方便。</p><p>建立起数据卷挂载后，docker容器内数据卷目录会和宿主机下对应目录双向绑定，其间的内容同步更新</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>数据持久性：即使容器被删除，数据卷中的数据也不会丢失，可以被其他容器使用。</li><li>数据共享：数据卷可以被多个容器同时挂载，实现容器间的数据共享。这对于需要多个容器共享数据的场景非常有用。</li></ul><p><strong>数据卷有点像 <code>Linux</code> 中的硬链接</strong></p><ul><li><p><strong>硬链接</strong>：在是另外一个位置创建源文件的链接文件，相当于复制了一份，占用资源会倍增。硬链接一旦创建，源文件和链接文件任何一方修改文件都会同步修改。</p></li><li><p><strong>软链接</strong>：指向源文件地址的一个引用，不占用资源</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p>在执行docker run命令时，使用 <code>-v</code>  <strong>数据卷</strong> <code>:</code> <strong>容器内目录</strong>可以完成数据卷挂载</p></blockquote><ul><li><strong>匿名卷</strong>：只指定容器内的路径，docker会自动在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下创建一个匿名卷，挂载到指定路径</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d -v /container/path <span class="hljs-keyword">my</span>-image<br></code></pre></td></tr></table></figure><ul><li><strong>命名卷</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">docker volume create my-volume <span class="hljs-comment">//可以手动创建</span><br>docker run -d -v my-volume:/container/path my-image <span class="hljs-comment">//运行容器时使用这个命名卷，若无docker会帮我们创建</span><br></code></pre></td></tr></table></figure><ul><li><strong>绑定挂载</strong>：绑定宿主机的目录到容器目录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//mysql 本地目录挂载实例</span><br>docker run -d \<br>  --name mysql \<br>  -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123</span> \<br>  -v ./mysql/data:/<span class="hljs-keyword">var</span>/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br></code></pre></td></tr></table></figure><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p><img src="/2024/07/16/docker/%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84.png"></p><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其常见语法有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><p>docker在安装之初便默认创建了一个网桥bridge，”Gateway”: “172.17.0.1”, “IPAddress”: “172.17.0.2”，运行容器时若不指定网络便会默认桥接进入这个网桥。</p><p>为了使我们的商场项目和MySQL运行在同一网桥下，以便访问，我们可以自定义一个网桥：<code>docker network create baima</code> ，通过 <code>docker network inspect baima</code>查看这个网桥的信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;baima&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ad4d38c784bcf47830bafe984d2a6fb9fff12cd407da65d937d6ce02fabfc4a9&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Created&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-07-18T16:08:52.000559732+08:00&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;EnableIPv6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;IPAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.0/16&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.1&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过<code>docker network connect baima mysql</code> 将mysql容器加入baima中，也可以在运行容器时通过添加 –network baima 参数，在创建容器时直接将其加入网段中。</p><h3 id="docker部署项目"><a href="#docker部署项目" class="headerlink" title="docker部署项目"></a>docker部署项目</h3><p>想要通过docker部署项目到云服务器上，因为我的后端服务是8080端口，所以要先去安全组开放一下端口。</p><p>接着通过maven将项目打包，自定义DOCKERFILE，一并上传到服务器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># DOCKERFILE</span><br><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">11.0</span>-jre-buster<br><span class="hljs-comment"># 设定时区</span><br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone</span><br><span class="hljs-comment"># 拷贝jar包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hm-service.jar /app.jar</span><br><span class="hljs-comment"># 入口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>通过<code>docker build -t hmall .</code> 打包成镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">[root@fu1sh ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY   <span class="hljs-keyword">TAG</span>               <span class="hljs-title">IMAGE</span> ID       CREATED       SIZE<br>hmall        latest            d3063508f8b0   <span class="hljs-number">3</span> hours ago   <span class="hljs-number">370M</span>B<br>mysql        latest            <span class="hljs-number">3218</span>b38490ce   <span class="hljs-number">2</span> years ago   <span class="hljs-number">516M</span>B<br>openjdk      <span class="hljs-number">11.0</span>-jre-buster   <span class="hljs-number">57925</span>f2e4cff   <span class="hljs-number">2</span> years ago   <span class="hljs-number">301M</span>B<br></code></pre></td></tr></table></figure><p>通过 <code>docker run -d --name hm --network baima -p 8080:8080 hmall</code> 运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@fu1sh ~]# dps<br>CONTAINER ID   IMAGE     PORTS                                                  STATUS       NAMES<br>284a8e00bbfe   hmall     0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              Up 3 hours   hm<br>5adc956a74df   mysql     0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 4 hours   mysql<br><br></code></pre></td></tr></table></figure><p>运行成功后就可以在浏览器访问我们的项目了。</p><h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p>集成部署，不用一个一个部署，比如部署完mysql部署后端代码，最后部署nginx，这些统统可以通过docker-compose.yml文件一键部署启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs docker-compose.yml">version: &quot;3.8&quot;<br><br>services:<br>  mysql:<br>    image: mysql<br>    container_name: mysql<br>    ports:<br>      - &quot;3306:3306&quot;<br>    environment:<br>      TZ: Asia/Shanghai<br>      MYSQL_ROOT_PASSWORD: 123<br>    volumes:<br>      - &quot;./mysql/conf:/etc/mysql/conf.d&quot;<br>      - &quot;./mysql/data:/var/lib/mysql&quot;<br>    networks:<br>      - new<br>networks:<br>  new:<br>    name: baima<br></code></pre></td></tr></table></figure><p>这个文件和我们运行镜像的命令几乎一模一样，这里不再赘述。接着通过命令启动即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker compose <span class="hljs-selector-attr">[OPTIONS]</span> <span class="hljs-selector-attr">[COMMAND]</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>参数或指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>OPTIONS</strong></td><td align="center">-f</td><td align="center">指定compose文件的路径和名称</td></tr><tr><td align="center"></td><td align="center">-p</td><td align="center">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td align="center"><strong>COMMAND</strong></td><td align="center">up</td><td align="center">创建并启动所有service容器</td></tr><tr><td align="center"></td><td align="center">down</td><td align="center">停止并移除所有容器、网络</td></tr><tr><td align="center"></td><td align="center">ps</td><td align="center">列出所有启动的容器</td></tr><tr><td align="center"></td><td align="center">logs</td><td align="center">查看指定容器的日志</td></tr><tr><td align="center"></td><td align="center">stop</td><td align="center">停止容器</td></tr><tr><td align="center"></td><td align="center">start</td><td align="center">启动容器</td></tr><tr><td align="center"></td><td align="center">restart</td><td align="center">重启容器</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截器与过滤器</title>
    <link href="/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>拦截器，顾名思义，是一个全局的拦截某些请求的东西，同过滤器一样，都是AOP思想的具体实现，在Spring中Controller方法执行之前和之后都可以看到拦截器的身影。以下是一个web请求的执行流程</p><p><img src="D:\Github\payfish.github.io\source_posts\拦截器\流程.png"></p><ul><li>浏览器发送请求到Tomcat服务器</li><li>需要静态资源直接去项目目录访问，动态资源才进入后端代码</li><li>经过几个过滤器过滤</li><li>进入中央处理器寻找对应的Controller中的方法</li><li>配置的拦截器会动态拦截控制器（Controller）中方法的执行，在方法执行前后进行操作，如jwt校验鉴权</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><blockquote><p>自定义的拦截器需要实现HandlerInterceptor接口，接口中有三个方法preHandle、postHandle等等，都是默认方法，不必强制实现，所有接口的实现类都会通过继承得到这个方法。源码里默认返回true，意思是直接放行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;host&quot;</span>)); <span class="hljs-comment">// request：请求对象，这里输出localhost:8081</span><br>        System.out.println(handler.getClass()); <span class="hljs-comment">// handler：可以获取方法相关信息，这里输出</span><br>        <span class="hljs-comment">//class org.springframework.web.method.HandlerMethod</span><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        System.out.println(handlerMethod.getMethod().getName()); <span class="hljs-comment">// 这里输出test</span><br>        response.setStatus(<span class="hljs-number">999</span>); <span class="hljs-comment">//response: 响应对象，在preHandle里可以任意修改</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//如果为false则拦截方法和postHandle和afterCompletion都不执行</span><br>    &#125;<br><br>    <span class="hljs-comment">//原始方法运行后运行，如果原始方法被拦截，则不执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);<br>        response.setStatus(<span class="hljs-number">888</span>); <span class="hljs-comment">// 修改失败，因为Controller方法执行结束后响应对象可能已经部分或完全提交</span><br>    &#125;<br><br>    <span class="hljs-comment">//拦截器最后执行的方法，无论原始方法是否执行。用于清理资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);<br>        response.setStatus(<span class="hljs-number">777</span>); <span class="hljs-comment">// 修改失败，此时响应已经完成并提交给客户端。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8/%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B.png" alt="拦截器方法的执行流程"></p><p>注册拦截器，配置要拦截的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestInterceptor interceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始注册拦截器&quot;</span>);<br>        registry.addInterceptor(interceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//如果这里还有Interceptor2，配置了多个拦截器形成了拦截器链，那么执行流程是按照配置的顺序先进后出</span><br>        <span class="hljs-comment">//具体来说就是:preHandle1-&gt;preHandle2—&gt;拦截方法-&gt;postHandle2-&gt;posthandle1-&gt;afterCompletion2</span><br>        <span class="hljs-comment">// -&gt;afterCompletion1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以通过.order(1)来控制拦截器的执行优先级，数字越小优先级越高</p></blockquote><p>Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/fuish&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sound</span> <span class="hljs-operator">=</span> dog.bark(<span class="hljs-string">&quot;wof~wof~wof~wof~wof~wof~wof~&quot;</span>);<br>        <span class="hljs-comment">//response.setStatus(200); 当然控制器内也可以随意修改response对象。</span><br>        <span class="hljs-keyword">return</span> sound;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dog实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-meta">@Timer</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">bark</span><span class="hljs-params">(String sound)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行： &quot;</span> + sound);<br>        <span class="hljs-keyword">return</span> sound;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>好了，浏览器输入localhost:8081&#x2F;fuish&#x2F;test，就可以在控制台查收拦截器的执行过程了。（我自己配置的8081端口）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">preHandle<br>localhost:8081<br>class org.springframework.web.method.HandlerMethod<br>test<br>方法执行： wof~wof~wof~wof~wof~wof~wof~<br>class com.spring.Dog<br>postHandle<br>afterCompletion<br></code></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器，是在java web中将你传入的request、response提前过滤掉一些信息，或者提前设置一些参数。然后再传入Servlet或Struts2的 action进行业务逻辑处理。比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <br><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="hljs-comment">// 配置拦截路径</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">//只会随着服务器的启动初始化一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        Filter.<span class="hljs-built_in">super</span>.init(filterConfig);<br>    &#125;<br><br>    <span class="hljs-comment">//每次请求都会被调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br>        System.out.println(<span class="hljs-string">&quot;过滤器拦截: &quot;</span> + request.getRequestURI());<br>        filterChain.doFilter(servletRequest, servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;要走了也得过滤一道。最终返回的状态码：&quot;</span> + response.getStatus());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        Filter.<span class="hljs-built_in">super</span>.destroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">过滤器拦截: /fuish/test<br>preHandle<br>localhost:8081<br>class org.springframework.web.method.HandlerMethod<br>test<br>方法执行： wof~wof~wof~wof~wof~wof~wof~<br>class com.spring.Dog<br>postHandle<br>afterCompletion<br>要走了也得过滤一道。最终返回的状态码：999<br></code></pre></td></tr></table></figure><blockquote><p>可以发现过滤器的执行顺序同样遵循先进后出，过滤器链也是一样的</p></blockquote><blockquote><p>同样可以通过@Order(1)注解来控制过滤器的执行优先级，数字越小优先级越高</p></blockquote><h2 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h2><p><strong>Filter属于Servlet技术， Interceptor属于SpringMVC技术</strong></p><ul><li>自定义过滤器需要实现 javax.servlet.Filter接口，而这个接口是在Servlet规范中定义的，或者说过滤器需要依赖于Servlet容器，因此它只能在Web程序中使用</li><li>自定义拦截器需要实现org.springframework.web.servlet.HandlerInterceptor接口，存在于SpringMVC中，由Spring容器来管理，不依赖于Servlet容器，是可以单独使用的，因此不仅可以用在Web程序中，也可以用在Application、Swing等程序中</li></ul><p><strong>Filter对所有访问进行增强，Interceptor只对特定请求增强</strong></p><p><strong>Filter基于函数回调， Interceptor基于AOP思想</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interceptor、Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC与AOP</title>
    <link href="/2024/07/10/AOP/"/>
    <url>/2024/07/10/AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是一种思想，全称叫做Inversion of Control，控制反转，意思是如果有两个对象A依赖于B，把本来A运行时需要主动创建B对象的操作交给IOC容器来帮我们做，创建B对象并注入A，实现了解耦</p><p>IOC也可以叫做DI，Dependency Injection，依赖注入，或者说DI是IOC思想的具体实现方式</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>AOP, Aspect Orient Programming，面向切面编程，拦截指定方法并对方法进行增强，不修改源代码的情况下给程序动态添加额外功能</p><ul><li><p><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</p></li><li><p>切面（Aspect）：对横切关注点进行封装的类，实现具体的功能。（切面 &#x3D; 切入点 + 通知，通俗点就是在什么时机，什么地方，做什么增强）</p></li><li><p>连接点（JoinPoint）：方法调用或方法执行的某个时刻。（能够被拦截的地方，Spring AOP 是基于动态代理的，所以是方法拦截的，每个成员方法都可以称之为连接点）</p></li><li><p>通知（Advice）：切面在某个连接点要执行的操作，有Before，After，AfterReturning，AfterThrowing，Around。在方法执行的什么时机（<strong>when</strong>：方法前&#x2F;方法后&#x2F;方法前后）做什么（<strong>what</strong>：增强的功能）</p></li><li><p>切点（Pointcut）：一个表达式，用来匹配哪些连接点需要被切面增强。（在哪些类，哪些方法上切入（<strong>where</strong>））</p></li><li><p>织入（weaving）：把切面加入到对象，并创建出代理对象的过程，这个由 Spring 来完成。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>AOP可以通过动态代理或操作字节码实现</p><p>Spring AOP基于动态代理实现，如果要代理的对象实现了接口，SpringAOP使用 JDK 动态代理创建代理对象，如果没有实现接口，使用Cglib生成一个要代理对象的子类来作为代理对象。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>利用AOP实现对数据的一些公共字段如createTime，updateUser等的自动填充功能，无需再手动set</p><p><strong>自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解，用于标识某个方法需要进行公共字段的自动填充</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    <span class="hljs-comment">//数据库操作类型： UPDATE, INSERT</span><br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//枚举定义数据库操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OperationType</span> &#123;<br>    UPDATE,<span class="hljs-comment">//更新操作</span><br>    INSERT<span class="hljs-comment">//插入操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>要被填充的方法</strong></p><p>以DishMapper举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增菜品</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AutoFill(OperationType.INSERT)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><p><strong>切面类</strong></p><p>实现具体的填充功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">//标注这是一个切面类</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">//加入Spring容器？</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-comment">//切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//通知</span><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><span class="hljs-comment">//方法调用前执行autoFill方法，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123; <span class="hljs-comment">// JoinPoint：连接点</span><br>        <span class="hljs-comment">//获取操作类型</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="hljs-comment">//获取方法签名</span><br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="hljs-comment">//方法上的注解对象</span><br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> autoFill.value();<span class="hljs-comment">//数据库操作类型</span><br><br>        <span class="hljs-comment">//获取切入点方法的参数列表</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 这里就是Dish实体类</span><br><br>        <span class="hljs-comment">//准备赋值的数据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>        <span class="hljs-comment">//根据操作类型，通过反射为对应的属性赋值</span><br>        <span class="hljs-keyword">if</span> (type == OperationType.INSERT) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreatTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,<br>                        Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER,<br>                        Long.class);<br><br>                setCreateUser.invoke(entity, currentId);<br>                setUpdateUser.invoke(entity, currentId);<br>                setUpdateTime.invoke(entity, now);<br>                setCreatTime.invoke(entity, now);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == OperationType.UPDATE) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,<br>                        Long.class);<br><br>                setUpdateUser.invoke(entity, currentId);<br>                setUpdateTime.invoke(entity, now);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-递归到记忆化搜索</title>
    <link href="/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="基础DP"><a href="#基础DP" class="headerlink" title="基础DP"></a>基础DP</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><blockquote><p>递归</p></blockquote><p><code>dfs(i)</code>表示从<code>0</code>爬到第<code>i</code>阶楼梯一共有多少种方法。最后一步可以爬1阶或者2阶，则<code>dfs(i)</code>等于<code>dfs(i - 1)</code> 和<code>dfs(i - 2)</code>之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(i - <span class="hljs-number">1</span>) + dfs(i - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/%E7%88%AC%E6%A5%BC%E6%A2%AF.png"></p><p><strong>dfs</strong> 的搜索过程为一颗二叉树，树高为$n$，节点个数为$2^n$，故搜索时间为$O(2^n)$，空间复杂度为$O(n)$，递归需要$O(n)$个栈空间</p><blockquote><p>记忆化搜索</p></blockquote><p>上面的做法会超时，太慢了，可以引入记忆化数组优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i] = dfs(i - <span class="hljs-number">1</span>, memo) + dfs(i - <span class="hljs-number">2</span>, memo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为递归是由上至下展开、由下至上收敛的过程。当递归到最小的问题（<code>i &lt;= 1</code>）时，逐步返回计算结果，并将这些结果存储在 <code>memo</code> 数组中。当递归回到较高层级时，已经计算过的结果保存在 <code>memo</code> 中，可以直接访问，避免重复计算。</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。具体来说，$f[i]$ 的定义和 $dfs(i)$ 的定义是一样的，都表示从 0 爬到 i 有多少种不同的方法。</p><p>相应的递推式（状态转移方程）也和 $dfs$ 一样：$f[i]&#x3D;f[i−1]+f[i−2]$</p><p>递推方法的核心在于通过自底向上的迭代计算，避免了递归中的重复计算和函数调用开销，达到了高效解决问题的目的。</p><p>当然，转换为三个变量滚动计算这里就不写了</p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>递归</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dfs(i - <span class="hljs-number">1</span>, nums), dfs(i - <span class="hljs-number">2</span>, nums) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时，记忆化搜索</p><blockquote><p>记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, nums, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span>[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(i - <span class="hljs-number">1</span>, nums, memo), dfs(i - <span class="hljs-number">2</span>, nums, memo) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>memo</em> 数组的<strong>初始值</strong>一定不能等于要记忆化的值！上一题的方案数不可能为0，故没有初始化数组，但是这道题要记忆化的值是金额可以为0，故要初始化数组为-1</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            f[i + <span class="hljs-number">2</span>] = Math.max(f[i + <span class="hljs-number">1</span>], f[i] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<span class="hljs-comment">//f下标加2，即可避免越界</span><br><br><span class="hljs-comment">//换成三个变量滚动，节约空间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(cur, pre + nums[i]);<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cost = [<span class="hljs-number">1,100,1,1</span>,<span class="hljs-number">1,100,1,1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：你将从下标为 <span class="hljs-number">0</span> 的台阶开始。<br></code></pre></td></tr></table></figure><blockquote><p>递归+记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []cost; <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cost = cost;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length + <span class="hljs-number">1</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(cost.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> memo[i] = Math.min(dfs(i - <span class="hljs-number">1</span>) + cost[i - <span class="hljs-number">1</span>], dfs(i - <span class="hljs-number">2</span>) + cost[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        f[i + <span class="hljs-number">2</span>] = Math.min(f[i + <span class="hljs-number">1</span>] + cost[i + <span class="hljs-number">1</span>], f[i] + cost[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br><span class="hljs-comment">//滚动</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.min(cur + cost[i + <span class="hljs-number">1</span>], pre + cost[i]);<br>        pre = cur;<br>        cur = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, target, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[target] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[target];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;   <br>            res += dfs(nums, target - i, memo);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> f[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= target; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= i) &#123;<br>                f[i] += f[i - x];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[target];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计构造”好”字符串的方案数"><a href="#统计构造”好”字符串的方案数" class="headerlink" title="统计构造”好”字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">统计构造”好”字符串的方案数</a></h3><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countGoodStrings</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> zero, <span class="hljs-type">int</span> one)</span> &#123;<br>    <span class="hljs-type">int</span> f[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>, ans = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= high; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= zero) f[i] = (f[i] + f[i - zero]) % mod;<br>        <span class="hljs-keyword">if</span> (i &gt;= one) f[i] = (f[i] + f[i - one]) % mod;<br>        <span class="hljs-keyword">if</span> (i &gt;= low) ans = (ans + f[i]) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计打字方案数"><a href="#统计打字方案数" class="headerlink" title="统计打字方案数"></a><a href="https://leetcode.cn/problems/count-number-of-texts/">统计打字方案数</a></h3><blockquote><p>分段 dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTexts</span><span class="hljs-params">(String pressedKeys)</span> &#123;<br>        <span class="hljs-type">int</span> []index = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">//每个号码对应的字符串长度</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//debug半天，res必须为long，不然乘法过程中可能溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = pressedKeys.length(); <br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; pressedKeys.charAt(i) == pressedKeys.charAt(i + <span class="hljs-number">1</span>)) &#123;<br>                i ++; <br>                len ++; <span class="hljs-comment">//统计每一段相同操作的长度，例如22255中222长度为3</span><br>            &#125;<br>            <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> index[pressedKeys.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>            res = (res * dfs(s, len, memo)) % mod; <span class="hljs-comment">//乘法原理，222和55是独立的，分别统计222和55各自的可能，再相乘即为答案</span><br>            i ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br><br>    <span class="hljs-comment">// 常规dfs记忆化搜索</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[len] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[len];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (len &gt;= i) &#123;<br>                res = (res + dfs(s, len - i, memo)) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len] = (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a><a href="https://leetcode.cn/problems/delete-and-earn/">删除并获得点数</a></h3><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，接着要删除两个<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>之后，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数。<br>总共获得<span class="hljs-number"> 9 </span>个点数。<br></code></pre></td></tr></table></figure><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//mp.merge(i, 1, Integer::sum);</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">return</span> dfs(a, n - <span class="hljs-number">1</span>, mp, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []a, <span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; mp, <span class="hljs-type">int</span>[]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] &gt;= a[i] - <span class="hljs-number">1</span>) -- j;<br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(a, i - <span class="hljs-number">1</span>, mp, memo), a[i] * mp.get(a[i]) + dfs(a, j - <span class="hljs-number">1</span>, mp, memo));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个细节：<code>a[j - 1] &gt;= a[i] - 1</code>  和 <code>dfs(a, j - 1, mp, memo)</code> 这里的 j - 1 不能为 j ，否则可能因为 j 未减小导致无限递归。</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">while</span> (a[j] &lt; a[i] - <span class="hljs-number">1</span>) ++ j;<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i], f[j] + a[i] * mp.get(a[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="施咒的最大总伤害"><a href="#施咒的最大总伤害" class="headerlink" title="施咒的最大总伤害"></a><a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/">施咒的最大总伤害</a></h3><p>一个魔法师有许多不同的咒语。</p><p>给你一个数组 <code>power</code> ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p><p>已知魔法师使用伤害值为 <code>power[i]</code> 的咒语时，他们就 <strong>不能</strong> 使用伤害为 <code>power[i] - 2</code> ，<code>power[i] - 1</code> ，<code>power[i] + 1</code> 或者 <code>power[i] + 2</code> 的咒语。</p><p>每个咒语最多只能被使用 <strong>一次</strong> 。</p><p>请你返回这个魔法师可以达到的伤害值之和的 <strong>最大值</strong> 。</p><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTotalDamage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 去重</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);  <span class="hljs-comment">// 排序</span><br>        <span class="hljs-type">long</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">return</span> dfs(a, n - <span class="hljs-number">1</span>, mp, memo);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []a, <span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; mp, <span class="hljs-type">long</span>[]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] &gt;= a[i] - <span class="hljs-number">2</span>) -- j;  <span class="hljs-comment">// 找到第一个能使用咒语的位置（第一个小于power[i] - 2的位置）</span><br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(a, i - <span class="hljs-number">1</span>, mp, memo), (<span class="hljs-type">long</span>) a[i] * mp.get(a[i]) + dfs(a, j - <span class="hljs-number">1</span>, mp, memo));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTotalDamage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.merge(i, <span class="hljs-number">1</span>, Integer::sum);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">long</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">while</span> (a[j] &lt; a[i] - <span class="hljs-number">2</span>) ++ j;<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i], f[j] + (<span class="hljs-type">long</span>) a[i] * mp.get(a[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计放置房子的方式数"><a href="#统计放置房子的方式数" class="headerlink" title="统计放置房子的方式数"></a><a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">统计放置房子的方式数</a></h3><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(n, memo);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod * res % mod) % mod;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span> <span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">long</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> memo[i] = (dfs(i - <span class="hljs-number">1</span>, memo) + dfs(i - <span class="hljs-number">2</span>, memo)) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">long</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>            f[i] = (f[i - <span class="hljs-number">1</span>]  + f[i - <span class="hljs-number">2</span>]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (f[n] % mod * f[n] % mod) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优化空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, cur = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (pre + cur) % mod;<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (cur % mod * cur % mod) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>), dfs(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)); <span class="hljs-comment">//考虑第1间和不考虑第一间</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> Math.max(dfs(nums, k, i - <span class="hljs-number">1</span>), dfs(nums, k, i - <span class="hljs-number">2</span>) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推（按照上面一比一翻译）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>), dfs(nums, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; n; i ++) &#123;<br>            f[i + <span class="hljs-number">2</span>] = Math.max(f[i + <span class="hljs-number">1</span>], f[i] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - start + <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>), dfs(nums, <span class="hljs-number">1</span>, n));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(nums[i] + pre, cur);<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><blockquote><p>动态规划，空间优化版</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        pre = Math.max(pre, <span class="hljs-number">0</span>) + nums[i];<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀和：从前往后遍历过程中维护一个最小的前缀和值，用当前前缀和减去最小前缀和即为可能答案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        sum += nums[i];<br>        res = Math.max(sum - mi, res);<br>        mi = Math.min(sum, mi);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到最大开销的子字符串"><a href="#找到最大开销的子字符串" class="headerlink" title="找到最大开销的子字符串"></a><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">找到最大开销的子字符串</a></h3><blockquote><p>先映射，确定字符串s中每一个字符的cost，接下来就是最大子数组和的做法了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumCostSubstring</span><span class="hljs-params">(String s, String chars, <span class="hljs-type">int</span>[] vals)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span> []mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++ i) &#123;<br>        mapping[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vals.length; ++ i) &#123;<br>        mapping[chars.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = vals[i];<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>        pre = Math.max(pre, <span class="hljs-number">0</span>) + mapping[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任意子数组和的绝对值的最大值"><a href="#任意子数组和的绝对值的最大值" class="headerlink" title="任意子数组和的绝对值的最大值"></a><a href="https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/">任意子数组和的绝对值的最大值</a></h3><p>请你找出 <code>nums</code> 中 <strong>和的绝对值</strong> 最大的任意子数组（<strong>可能为空</strong>），并返回该 <strong>最大值</strong> 。</p><blockquote><p>多维护一个任意子数组的最小值变量mm</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAbsoluteSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, n = nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        mx = Math.max(mx, <span class="hljs-number">0</span>) + nums[i];<br>        mm = Math.min(mm, <span class="hljs-number">0</span>) + nums[i];<br>        res = Math.max(Math.max(mx, - mm), res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-次串联后最大子数组之和"><a href="#K-次串联后最大子数组之和" class="headerlink" title="K 次串联后最大子数组之和"></a><a href="https://leetcode.cn/problems/k-concatenation-maximum-sum/">K 次串联后最大子数组之和</a></h3><p>给定一个整数数组 <code>arr</code> 和一个整数 <code>k</code> ，通过重复 <code>k</code> 次来修改数组。</p><p>例如，如果 <code>arr = [1, 2]</code> ， <code>k = 3</code> ，那么修改后的数组将是 <code>[1, 2, 1, 2, 1, 2]</code> 。</p><p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p><p>由于 <strong>结果可能会很大</strong>，需要返回的 <code>109 + 7</code> 的 <strong>模</strong> 。</p><blockquote><p>别被一个小小的变形吓跑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kConcatenationMaxSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) sum += i;<br>    res = kadane(arr, <span class="hljs-number">1</span>); <span class="hljs-comment">// k = 1,直接返回答案</span><br>    <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>) &#123;<br>        res = kadane(arr, <span class="hljs-number">2</span>); <span class="hljs-comment">// sum &lt;= 0,串联两次res最大</span><br>        <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//只有数组和大于0，串联k次才会使res增大，否则就是串联两次的最大子数组和最大</span><br>            res += (<span class="hljs-type">long</span>) sum * (k - <span class="hljs-number">2</span>) % mod; <span class="hljs-comment">//最大子数组和就是在串联两次的数组中间插入k-2个arr</span><br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res % mod;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kadane</span><span class="hljs-params">(<span class="hljs-type">int</span> []arr, <span class="hljs-type">int</span> k)</span> &#123; <span class="hljs-comment">//用来计算重复一次或者两次的最大子数组和</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n * k; i ++) &#123;<br>        pre = (Math.max(pre, <span class="hljs-number">0</span>) + arr[i % n]);<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a></h3><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><blockquote><p>思路：同时维护最小子数组和mi，与最大子数组和mx，以及数组总和sum，sum - mi就是跨过边界的子数组最大和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, pmx = <span class="hljs-number">0</span>, pmi = <span class="hljs-number">0</span>, mx = Integer.MIN_VALUE, mi = Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        sum += nums[i];<br>        pmx = Math.max(pmx, <span class="hljs-number">0</span>) + nums[i];<br>        pmi = Math.min(pmi, <span class="hljs-number">0</span>) + nums[i];<br>        mi = Math.min(mi, pmi);<br>        mx = Math.max(mx, pmx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mi == sum) <span class="hljs-keyword">return</span> mx; <span class="hljs-comment">//特殊情况数组全部元素为负，返回mx代表数组中最大的一个负数</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(mx, sum - mi);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拼接数组的最大分数"><a href="#拼接数组的最大分数" class="headerlink" title="拼接数组的最大分数"></a><a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">拼接数组的最大分数</a></h3><blockquote><p>就是求两个数组的差集数组<code>nums2 - nums1</code>的最大子数组和，再加上<code>nums1</code>的和；对于<code>nums2</code>再来一次该操作，最后返回二者最大的即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumsSplicedArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length, sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> nums1[i], t2 = nums2[i];<br>        sum1 += t1;<br>        sum2 += t2;<br>        nums2[i] = t2 - t1;<br>        nums1[i] = t1 - t2;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mx1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res1 = <span class="hljs-number">0</span>, mx2 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>        mx1 = Math.max(mx1 + i, <span class="hljs-number">0</span>) ;<br>        res1 = Math.max(res1, mx1);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums2) &#123;<br>        mx2 = Math.max(mx2 + i, <span class="hljs-number">0</span>);<br>        res2 = Math.max(res2, mx2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(sum2 + res1, sum1 + res2);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>封装成函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumsSplicedArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(kadane(nums1, nums2), kadane(nums2, nums1));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kadane</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums1, <span class="hljs-type">int</span> []nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++ i) &#123;<br>        sum += nums1[i];<br>        mx = Math.max(mx + nums2[i] - nums1[i], <span class="hljs-number">0</span>) ;<br>        res = Math.max(res, mx);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res + sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><blockquote><p>思路就是维护一个乘积的最大值 <code>mx</code> 一个最小值 <code>mi</code>，每次遇到负数就交换最大最小值，遇到0就把 <code>mx</code> 和 <code>mi</code> 置为1，计算下一段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, mi = <span class="hljs-number">1</span>, mx = <span class="hljs-number">1</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            mx = <span class="hljs-number">1</span>;<br>            mi = <span class="hljs-number">1</span>;<br>            res = Math.max(res, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> mx;<br>            mx = Math.max(i * mi, i);<br>            mi = Math.min(i * t, i);<br>            res = Math.max(res, mx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mx = Math.max(i * mx, i);<br>            mi = Math.min(i * mi, i);<br>            res = Math.max(res, mx);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网格图DP"><a href="#网格图DP" class="headerlink" title="网格图DP"></a>网格图DP</h2><h3 id="珠宝的最高价值"><a href="#珠宝的最高价值" class="headerlink" title="珠宝的最高价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">珠宝的最高价值</a></h3><p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p><ul><li>只能从架子的左上角开始拿珠宝</li><li>每次可以移动到右侧或下侧的相邻位置</li><li>到达珠宝架子的右下角时，停止拿取</li></ul><blockquote><p>dfs + 记忆化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][] frame;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>        <span class="hljs-built_in">this</span>.frame = frame;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y]; <span class="hljs-comment">// 用 &gt; 0判断也行</span><br>        <span class="hljs-keyword">return</span> memo[x][y] = Math.max(dfs(x - <span class="hljs-number">1</span>, y), dfs(x, y - <span class="hljs-number">1</span>)) + frame[x][y];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.max(f[i][j + <span class="hljs-number">1</span>], f[i + <span class="hljs-number">1</span>][j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] = Math.max(f[i % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>], f[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[n % <span class="hljs-number">2</span>][m];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[j + <span class="hljs-number">1</span>] = Math.max(f[j + <span class="hljs-number">1</span>], f[j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, memo);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (memo[m][n] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[m][n];<br>    <span class="hljs-keyword">return</span> memo[m][n] = dfs(m - <span class="hljs-number">1</span>, n, memo) + dfs(m, n - <span class="hljs-number">1</span>, memo);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(f, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>            f[j] += f[j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]obstacleGrid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.obstacleGrid = obstacleGrid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[x][y] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[x][y] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-keyword">return</span> memo[x][y] = dfs(x - <span class="hljs-number">1</span>, y, memo) + dfs(x, y - <span class="hljs-number">1</span>, memo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                dp[j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><blockquote><p>原地修改</p></blockquote><table><thead><tr><th align="center">1</th><th align="center">3</th><th align="center">1</th><th align="center"></th><th align="center">1</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>5</strong></td><td align="center"><strong>1</strong></td><td align="center">修改后–&gt;</td><td align="center"><strong>2</strong></td><td align="center"><strong>7</strong></td><td align="center"><strong>6</strong></td></tr><tr><td align="center"><strong>4</strong></td><td align="center"><strong>2</strong></td><td align="center"><strong>1</strong></td><td align="center"></td><td align="center"><strong>6</strong></td><td align="center"><strong>8</strong></td><td align="center"><strong>7</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) grid[j][<span class="hljs-number">0</span>] += grid[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> grid[j][i] = Math.min(grid[j][i - <span class="hljs-number">1</span>], grid[j - <span class="hljs-number">1</span>][i]) + grid[j][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/">三角形最小路径和</a></h3><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; triangle;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-built_in">this</span>.triangle = triangle;<br>        <span class="hljs-built_in">this</span>.n = triangle.size();<br>        <span class="hljs-built_in">this</span>.memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;    <br>        <span class="hljs-keyword">if</span> (r == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[r][c] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[r][c];<br>        <span class="hljs-keyword">return</span> memo[r][c] = Math.min(dfs(r + <span class="hljs-number">1</span>, c), dfs(r + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span>)) + triangle.get(r).get(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : dp) Arrays.fill(a, Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; ++ j) &#123;<br>            dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.min(dp[i][j + <span class="hljs-number">1</span>], dp[i][j]) + triangle.get(i).get(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-comment">// System.out.print(dp[n][i]);</span><br>        <span class="hljs-keyword">if</span> (dp[n][i + <span class="hljs-number">1</span>] &lt; res) res = dp[n][i + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自顶向下</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] += triangle.get(i).get(j); <br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (dp[i] &lt; res) res = dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自底向上</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// Initialize dp array with the last row of the triangle</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[i] = triangle.get(n - <span class="hljs-number">1</span>).get(i);<br>    &#125;<br>    <span class="hljs-comment">// Start from the second last row and move upwards</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            dp[j] = Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// The top element of dp array will have the minimum total</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">下降路径最小和</a></h3><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length, m = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(n - <span class="hljs-number">1</span>, i, matrix, memo);<br>            <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]matrix, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span> || y &gt;= matrix[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-keyword">return</span> memo[x][y] = Math.min(Math.min(dfs(x-<span class="hljs-number">1</span>, y, matrix, memo), dfs(x-<span class="hljs-number">1</span>, y-<span class="hljs-number">1</span>, matrix, memo)),                              dfs(x-<span class="hljs-number">1</span>, y+<span class="hljs-number">1</span>, matrix, memo)) + matrix[x][y];<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;            <br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n + <span class="hljs-number">2</span>];<br>    System.arraycopy(matrix[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>] = Integer.MAX_VALUE; <span class="hljs-comment">//左右边界同样初始化为MAX</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;<br>            dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>])<br>             + matrix[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (res &gt; dp[n - <span class="hljs-number">1</span>][i]) res = dp[n - <span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格中的最小路径代价"><a href="#网格中的最小路径代价" class="headerlink" title="网格中的最小路径代价"></a><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">网格中的最小路径代价</a></h3><p>题目太复杂，建议去原链接里读</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]grid; <span class="hljs-type">int</span> [][]moveCost;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.moveCost = moveCost;<br>        <span class="hljs-built_in">this</span>.m = grid.length;<br>        <span class="hljs-built_in">this</span>.n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, i, memo);<br>            <span class="hljs-comment">// System.out.print(t + &quot; &quot;);</span><br>            <span class="hljs-keyword">if</span> (t &lt; res) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y];<br>        <span class="hljs-keyword">if</span> (memo[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(x + <span class="hljs-number">1</span>, i, memo) + grid[x][y] + moveCost[grid[x][y]][i];<br>            res = Math.min(res, t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) dp[<span class="hljs-number">0</span>][i] = grid[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dp[i - <span class="hljs-number">1</span>][k] + moveCost[grid[i - <span class="hljs-number">1</span>][k]][j];<br>                <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>            &#125;<br>            dp[i][j] = grid[i][j] + res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ans &gt; dp[m - <span class="hljs-number">1</span>][i]) ans = dp[m - <span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//倒序遍历，可以原地修改</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> grid[i + <span class="hljs-number">1</span>][k] + moveCost[grid[i][j]][k];<br>                <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>            &#125;<br>            grid[i][j] += res;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ans &gt; grid[<span class="hljs-number">0</span>][i]) ans = grid[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下降路径最小和-II"><a href="#下降路径最小和-II" class="headerlink" title="下降路径最小和 II"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum-ii/">下降路径最小和 II</a></h3><p>给你一个 <code>n x n</code> 整数矩阵 <code>grid</code> ，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p><p><strong>非零偏移下降路径</strong> 定义为：从 <code>grid</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]grid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; ++ i) &#123;<br>            res = Math.min(res, dfs(<span class="hljs-number">0</span>, i, memo));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == grid.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y];<br>        <span class="hljs-keyword">if</span> (memo[x][y] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (i != y) &#123;<br>                res = Math.min(dfs(x + <span class="hljs-number">1</span>, i, memo) + grid[x][y], res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推 + 原地修改</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-keyword">if</span> (k != j) &#123;<br>                    res = Math.min(res, grid[i+<span class="hljs-number">1</span>][k]);<br>                &#125;<br>            &#125;<br>            grid[i][j] += res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : grid[<span class="hljs-number">0</span>]) &#123;<br>        ans = Math.min(ans, a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵的最大非负积"><a href="#矩阵的最大非负积" class="headerlink" title="矩阵的最大非负积"></a><a href="https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/">矩阵的最大非负积</a></h3><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <strong>向右</strong> 或 <strong>向下</strong> 移动。</p><p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <strong>最大非负积</strong> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p><p>返回 <strong>最大非负积</strong> 对 <strong><code>109 + 7</code></strong> <strong>取余</strong> 的结果。如果最大积为 <strong>负数</strong> ，则返回 <code>-1</code> 。</p><p><strong>注意，</strong>取余是在得到最大积之后执行的。</p><blockquote><p>直接上来就动态规划递推解决，但是在两个地方被卡了一个小时</p></blockquote><ul><li><code>(int) (mx[m - 1][n - 1] % mod)</code> 取模操作优先级低于类型转换，必须加括号</li><li>不认真读题，在每一步更新 <code>mx[i][j]</code> 的同时就对其取模，导致后续下一层比较大小时出问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProductPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">long</span> [][]mx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">long</span> [][]mi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    mx[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = mi[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        mx[i][<span class="hljs-number">0</span>] = (mx[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * grid[i][<span class="hljs-number">0</span>]);<br>        mi[i][<span class="hljs-number">0</span>] = mx[i][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        mx[<span class="hljs-number">0</span>][i] = (mx[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * grid[<span class="hljs-number">0</span>][i]);<br>        mi[<span class="hljs-number">0</span>][i] = mx[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>            mx[i][j] = (grid[i][j] * Math.max(mx[i][j - <span class="hljs-number">1</span>], mx[i - <span class="hljs-number">1</span>][j]));<br>            mi[i][j] = (grid[i][j] * Math.min(mi[i][j- <span class="hljs-number">1</span>], mi[i - <span class="hljs-number">1</span>][j]));<br>            <span class="hljs-keyword">if</span> (grid[i][j] &lt; <span class="hljs-number">0</span>) &#123;<br>                mx[i][j] = (grid[i][j] * Math.min(mi[i][j - <span class="hljs-number">1</span>], mi[i - <span class="hljs-number">1</span>][j]));<br>                mi[i][j] = (grid[i][j] * Math.max(mx[i][j - <span class="hljs-number">1</span>], mx[i - <span class="hljs-number">1</span>][j]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-type">int</span>) (mx[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] % mod);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵中和能被-K-整除的路径"><a href="#矩阵中和能被-K-整除的路径" class="headerlink" title="矩阵中和能被 K 整除的路径"></a><a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">矩阵中和能被 K 整除的路径</a></h3><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 和一个整数 <code>k</code> 。你从起点 <code>(0, 0)</code> 出发，每一步只能往 <strong>下</strong> 或者往 <strong>右</strong> ，你想要到达终点 <code>(m - 1, n - 1)</code> 。</p><p>请你返回路径和能被 <code>k</code> 整除的路径数目，由于答案可能很大，返回答案对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p><blockquote><p>dfs + memo，区别在于多考虑一个维度，memo的第三维存 <code>x、y</code> 点当前路径和 <code>s</code> 的状态信息</p><p>具体来说， <code>memo[x][y][s]</code> 表示从 <code>(x, y)</code> 开始，路径和对 <code>k</code> 取模为 <code>s</code> 的路径数量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">long</span> [][][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m][n][k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> [][]a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> []b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, grid, k, <span class="hljs-number">0</span>, memo); <span class="hljs-comment">//正向反向开始都可以</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]grid, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> s, <span class="hljs-type">long</span> [][][]memo)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        s = (s + grid[x][y]) % k;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s % k == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[x][y][s] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y][s];<br>        <span class="hljs-keyword">return</span> memo[x][y][s] = (dfs(x - <span class="hljs-number">1</span>, y, grid, k, s, memo) + dfs(x, y - <span class="hljs-number">1</span>, grid, k, s, memo)) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length; <br>        <br>        <span class="hljs-type">long</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>][k];<br>     <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; k; ++ r) &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][(r + grid[i][j]) % k] = (dp[i][j + <span class="hljs-number">1</span>][r] + dp[i + <span class="hljs-number">1</span>][j][r]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (dp[m][n][<span class="hljs-number">0</span>] % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h3><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><blockquote><p>dfs + memo: 假设要凑成target，需要添加+号的所有数的和为p，则需要添加负号的为sum(nums) - p，target &#x3D; p + (p - s) </p><p>解得p &#x3D; (s + target) &#x2F; 2，因此 s + target 小于0以及为奇数均不合法，题目转化为从n个数组元素中选取元素刚好填满容量为p的背包</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        target += sum;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, target, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有元素可选，检查背包是否刚好填满</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 刚好填满，方案数 +1</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][c] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][c]; <br>        <span class="hljs-keyword">if</span> (c &lt; nums[i]) <span class="hljs-keyword">return</span> memo[i][c] = dfs(i - <span class="hljs-number">1</span>, c, memo);<span class="hljs-comment">// 容量小于当前元素体积，不能选</span><br>        <span class="hljs-keyword">return</span> memo[i][c] = (dfs(i - <span class="hljs-number">1</span>, c, memo) + dfs(i - <span class="hljs-number">1</span>, c - nums[i], memo));<span class="hljs-comment">// 总方案数为选与不选当前元素的方案数之和</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>    target += sum;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    target /= <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> [][]f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                f[i + <span class="hljs-number">1</span>][j] = f[i][j] + f[i][j - nums[i]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i + <span class="hljs-number">1</span>][j] = f[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n][target];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>    target += sum;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    target /= <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= x; -- j) &#123;<br>            f[j] = f[j] + f[j - x];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[target];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">inf</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = coins;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> dfs(n - <span class="hljs-number">1</span>, amount, memo);<br>        <span class="hljs-keyword">return</span> ans == inf ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> c == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : inf;<br>        <span class="hljs-keyword">if</span> (memo[i][c] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][c];<br>        <span class="hljs-keyword">if</span> (c &lt; nums[i]) <span class="hljs-keyword">return</span> memo[i][c] = dfs(i - <span class="hljs-number">1</span>, c, memo);<br>        <span class="hljs-keyword">return</span> memo[i][c] = Math.min(dfs(i - <span class="hljs-number">1</span>, c, memo), dfs(i, c - nums[i], memo) + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty实现RPC框架实战</title>
    <link href="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h3 id="深入Netty"><a href="#深入Netty" class="headerlink" title="深入Netty"></a>深入Netty</h3><h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><p>Netty并未使用NIO中的ByteBuffer来作为缓冲区，而是自定义了一个ByteBuf，相比于ByteBuffer有如下区别：</p><ul><li>写操作完成后无需filp</li><li>比ByteBuffer响应更快</li><li>动态扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractByteBuf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteBuf</span> &#123;<br>    ...<br>    <span class="hljs-type">int</span> readerIndex;   <span class="hljs-comment">//index被分为了读和写，是两个指针在同时工作</span><br>    <span class="hljs-type">int</span> writerIndex; <span class="hljs-comment">//双指针取代position指针，无需flip将position置0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> markedReaderIndex;    <span class="hljs-comment">//mark操作也分两种</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> markedWriterIndex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxCapacity;    <span class="hljs-comment">//最大容量，没错，这玩意能动态扩容</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">10</span>); <span class="hljs-comment">//非池化缓冲区</span><br><span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> PooledByteBufAllocator.DEFAULT;<span class="hljs-comment">//池化技术可以复用buffer</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> allocator.buffer(<span class="hljs-number">256</span>);<br>byteBuf.writeBytes(<span class="hljs-string">&quot;abcdefgrfrfrf&quot;</span>.getBytes()); <span class="hljs-comment">//超过缓冲区大小动态扩容，先到64，之后再每次X2</span><br></code></pre></td></tr></table></figure><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>零拷贝允许在计算机内部传输数据时快速高效地将数据从文件系统移动到网络接口，避免将数据从一个存储区域复制到另一个存储区域，从而减少 CPU 负载和内存带宽的消耗。</p><p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p><p><img src="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png"></p><p>比如Java创建线程，实际上是通过调用本地方法<code>private native void start0();</code>来启动线程，它使用 JNI 调用操作系统的线程创建函数 <code>CreateThread</code> （这个就叫系统调用），这个过程就涉及到用户态到内核态的切换，操作系统内核负责分配资源（如栈、线程控制块等），并将新线程加入调度队列。</p><p>我们的文件操作也是如此，操作系统帮我们从磁盘读取到文件中的数据发给网络，流程如下</p><p><img src="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/%E6%96%87%E4%BB%B6IO.png"></p><p>DMA控制器就是Direct Memory Access，CSGO经常听到的DMA硬件外挂就是通过FPGA硬件设备直接访问内存，修改内存数据达到控制游戏操作的效果。图中经历了两次CPU拷贝两次DMA拷贝，拷贝略多，可以使用零拷贝优化。</p><p><strong>使用零拷贝技术</strong></p><ul><li><p><strong>mmap&#x2F;munmap</strong>：通过内存映射文件，可以将文件内容映射到进程的地址空间，这样读写文件就像读写内存一样，无需经过用户态的缓冲区。</p></li><li><p><strong>sendfile</strong>：系统调用 <code>sendfile</code> 允许直接将数据从一个文件描述符传输到另一个文件描述符（例如，从文件到网络套接字），避免在用户态和内核态之间进行数据拷贝。在内核空间中直接由CPU把数据拷贝到Socket。</p></li><li><p><strong>虚拟内存</strong>：现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p></li></ul><h3 id="基于Netty的RPC框架"><a href="#基于Netty的RPC框架" class="headerlink" title="基于Netty的RPC框架"></a>基于Netty的RPC框架</h3><h4 id="NettyServer和NettyClient"><a href="#NettyServer和NettyClient" class="headerlink" title="NettyServer和NettyClient"></a>NettyServer和NettyClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcServer</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyServer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonDecoder</span>())<br>                                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSerializer</span>()))<br>                                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                        &#125;<br>                    &#125;)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> bootstrap.bind(port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcClient</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyClient.class);<br><br>    <span class="hljs-keyword">private</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">//在静态代码块中先配置好客户端</span><br>        bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>        .channel(NioSocketChannel.class)<br><br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonDecoder</span>())<br>                        .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSerializer</span>()))<br>                        .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">sendRequest</span><span class="hljs-params">(RpcRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> bootstrap.connect(host, port).sync();<br>            logger.info(<span class="hljs-string">&quot;客户端连接到服务器：&#123;&#125;，&#123;&#125;&quot;</span>, host, port);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> future.channel();<br>            <span class="hljs-keyword">if</span> (channel.isActive()) &#123;<br>                channel.writeAndFlush(request).addListener(future1 -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (future1.isSuccess()) &#123;<br>                        logger.info(<span class="hljs-string">&quot;客户端发送消息：&#123;&#125;&quot;</span>, request.toString());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        logger.error(<span class="hljs-string">&quot;发送消息时有错误发生，&#123;&#125;&quot;</span>, future1.cause().getMessage());<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            <span class="hljs-comment">//阻塞等待直到channel关闭</span><br>            channel.closeFuture().sync();<br>            AttributeKey&lt;RpcResponse&gt; attributeKey = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>            <span class="hljs-type">RpcResponse</span> <span class="hljs-variable">rpcResponse</span> <span class="hljs-operator">=</span> channel.attr(attributeKey).get();<br>            <span class="hljs-keyword">return</span> rpcResponse.getData();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;发送消息时有错误发生：&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><p>首先自定义通信协议</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">魔数（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|数据包类型（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|序列化器类型（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|消息长度（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|消息体<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span> &#123; <span class="hljs-comment">//编码器</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAGIC_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xCAFEBABE</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CommonSerializer serializer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommonEncoder</span><span class="hljs-params">(CommonSerializer serializer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serializer = serializer;<br>    &#125;<br><br>    <span class="hljs-comment">//自定义协议：魔数（int）4字节|数据包类型|序列化器类型|消息长度|消息体</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Object o, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        byteBuf.writeInt(MAGIC_NUMBER);<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> RpcRequest) &#123;<br>            byteBuf.writeInt(PackageType.REQUEST_PACK.getCode());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            byteBuf.writeInt(PackageType.RESPONSE_PACK.getCode());<br>        &#125;<br>        byteBuf.writeInt(serializer.getCode());<br>        <span class="hljs-type">byte</span>[] bytes = serializer.serialize(o);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> bytes.length;<br>        byteBuf.writeInt(len);<br>        byteBuf.writeBytes(bytes);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CommonDecoder.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAGIC_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xCAFEBABE</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">magic</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-keyword">if</span> (magic != MAGIC_NUMBER) &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid magic number! &#123;&#125;&quot;</span>, magic);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_MAGIC_NUMBER);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">packageCode</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        Class&lt;?&gt; packageClass;<br>        <span class="hljs-keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;<br>            packageClass = RpcRequest.class;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;<br>            packageClass = RpcResponse.class;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid package type! &#123;&#125;&quot;</span>, packageCode);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_PACK_TYPE);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">serializeCode</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-type">CommonSerializer</span> <span class="hljs-variable">serializer</span> <span class="hljs-operator">=</span> CommonSerializer.getByCode(serializeCode);<br>        <span class="hljs-keyword">if</span> (serializer == <span class="hljs-literal">null</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid serialize code! &#123;&#125;&quot;</span>, serializeCode);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_SERIAL_CODE);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>        byteBuf.readBytes(data);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> serializer.deserialize(data, packageClass);<br>        list.add(o);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码器解码器都是继承自<code>ChannelInboundHandlerAdapter</code>入站处理器类。其中解码器继承的ReplayingDecoder是<code>ByteToMessageDecoder</code>的子类，简化了数据解码的逻辑，可以自动处理缓冲区的读取操作，如果数据不足，它会自动暂停解码并等待更多的数据。而<code>ByteToMessageDecoder</code>需要手动检查可读字节，并决定是否有足够的数据来解码一条完整的消息。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="Json序列化器"><a href="#Json序列化器" class="headerlink" title="Json序列化器"></a>Json序列化器</h5><p>基于JSON字符串，占用空间大，速度慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommonSerializer</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(JsonSerializer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-type">byte</span>[] bytes;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bytes = mapper.writeValueAsBytes(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Json serialize error&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bytes;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;<br>        Object obj;<br>        <span class="hljs-keyword">try</span> &#123;<br>            obj = mapper.readValue(bytes, clazz);<br>            <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> RpcRequest) &#123;<br>                obj = handleRequest(obj);<br>            &#125;<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Json deserialize error&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解决反序列化RpcRequest的Object[] params数组中的元素前后不一致的问题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">rpcRequest</span> <span class="hljs-operator">=</span> (RpcRequest) obj;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;<br>            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];<br>            <span class="hljs-keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParams()[i].getClass())) &#123;<br>                <span class="hljs-type">byte</span>[] bytes = mapper.writeValueAsBytes(rpcRequest.getParams()[i]);<br>                rpcRequest.getParams()[i] = mapper.readValue(bytes, clazz);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rpcRequest;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SerializerCode.JSON_SERIALIZER.getCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象, 通常会直接反序列化成string类型：</p><p>客户端日志：</p><blockquote><p>[com.fu1sh.rpc.client.NettyClient]-客户端发送消息：RpcRequest(interfaceName&#x3D;com.fu1sh.rpc.api.Animal, methodName&#x3D;eat, params&#x3D;[<strong>Food</strong>(name&#x3D;猪食, price&#x3D;30)], paramTypes&#x3D;[class com.fu1sh.rpc.api.Food])</p></blockquote><p>服务端日志：可见反序列化搞丢了Food类型</p><blockquote><p>[com.fu1sh.rpc.handler.NettyServerHandler]-接收到客户端请求：RpcRequest(interfaceName&#x3D;com.fu1sh.rpc.api.Animal, methodName&#x3D;eat, params&#x3D;[{name&#x3D;猪食, price&#x3D;30}], paramTypes&#x3D;[class com.fu1sh.rpc.api.Food])</p></blockquote><p>这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化。</p><h5 id="Kryo序列化器"><a href="#Kryo序列化器" class="headerlink" title="Kryo序列化器"></a>Kryo序列化器</h5><p>基于字节，空间利用率高；序列化时记录属性对象的类型信息</p><p>kryo使用 Input 和 Output 类来操作数据进出Kryo， 这些类并不是线程安全的。所以通常使用ThreadLocal来为每个需要序列化操作的线程存储一个kryo变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>    <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>    kryo.register(RpcRequest.class);<br>    kryo.register(RpcResponse.class);<br>    <span class="hljs-keyword">return</span> kryo;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(baos)) &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>        kryo.writeObject(output, obj);<br>        kryoThreadLocal.remove(); <span class="hljs-comment">//移除当前线程kryo局部变量防止内存泄漏</span><br>        <span class="hljs-keyword">return</span> output.toBytes();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;kryo serialize error&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>    <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(bais)) &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> kryo.readObject(input, clazz);<br>        kryoThreadLocal.remove();<br>        <span class="hljs-keyword">return</span> o;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(<span class="hljs-string">&quot;kryo deserialize error&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcClientProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RpcClient rpcClient;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcClientProxy</span><span class="hljs-params">(RpcClient rpcClient)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rpcClient = rpcClient;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcRequest</span>(method.getDeclaringClass().getName(), method.getName()<br>                ,args ,method.getParameterTypes());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rpcClient.sendRequest(request);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理的 <code>invoke</code> 方法封装了对接口方法的调用，将这些调用统一封装成 <code>RpcRequest</code> 对象，然后通过 <code>rpcClient.sendRequest</code> 发送，调用者不需要关注底层实现细节</p><p>动态代理同时提供了灵活性，能够在运行时动态地创建代理对象并处理接口方法的调用，可以方便地扩展和修改请求的处理逻辑，例如在 <code>invoke</code> 方法中添加日志记录、性能监控、权限检查等。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO</title>
    <link href="/2024/07/01/NIO/"/>
    <url>/2024/07/01/NIO/</url>
    
    <content type="html"><![CDATA[<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p><strong>同步</strong>（Synchronous）：同步任务按顺序执行，一个任务完成后才开始下一个任务。调用方在等待任务完成时会被阻塞，直到任务结束并返回结果。</p><p><strong>异步</strong>（Asynchronous）：异步任务可以同时执行，不必等待前一个任务完成。调用方在任务开始后立即返回，可以继续执行其他任务，不会被阻塞。结果通常通过回调、事件或Promise等方式处理。</p><h3 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h3><p><strong>阻塞</strong>：当一个线程在等待某个条件满足（如I&#x2F;O操作完成、锁释放等）时，它会被挂起（阻塞）并暂停执行，直到条件满足。系统会将其置于等待队列中，直到阻塞条件解除。</p><p><strong>非阻塞</strong>：当一个线程在等待某个条件满足时，它不会被挂起，而是立即返回一个状态（如成功、失败、或需要重试），线程可以继续处理其他任务或尝试再次执行未完成的任务。</p><h3 id="同步阻塞、非阻塞"><a href="#同步阻塞、非阻塞" class="headerlink" title="同步阻塞、非阻塞"></a>同步阻塞、非阻塞</h3><h4 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a><strong>同步阻塞（BIO）</strong></h4><p>以流的方式处理数据，底层是字节流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//socket通信</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port)) &#123;<br>    logger.info(<span class="hljs-string">&quot;服务启动中&quot;</span>);<br>    Socket socket;<br>    <span class="hljs-keyword">while</span> ((socket = serverSocket.accept()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//服务端accept()方法会阻塞等待直到有客户端连接</span><br>        logger.info(<span class="hljs-string">&quot;Accepted connection from &#123;&#125;&quot;</span>, socket.getRemoteSocketAddress());<br>        threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerThread</span>(socket, requestHandler, serviceRegistry));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    logger.error(<span class="hljs-string">&quot;连接出错了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a><strong>同步非阻塞（NIO）</strong></h4><p>面向数据块</p><h5 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a><strong>buffer</strong></h5><p>一个可以写入数据的内存块，使用缓冲区读写数据遵循以下四个步骤</p><ol><li>写数据</li><li>调用buffer.flip()方法，从写模式切换到读模式</li><li>读数据</li><li>调用buffer.clear()或buffer.compat()方法</li></ol><p><strong>buffer类的一些操作源码：</strong></p><ol><li>初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//调用mark()方法标记position位置，以便之后reset</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//下一个操作的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit; <span class="hljs-comment">//position能到的最大位置，默认是capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-comment">//Allocates a new int buffer.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> createCapacityException(capacity);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapIntBuffer</span>(capacity, capacity, <span class="hljs-literal">null</span>); <span class="hljs-comment">//返回一个堆缓冲区</span><br>&#125;<br><br><span class="hljs-comment">//Wraps an int array into a buffer.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title function_">wrap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span><br>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapIntBuffer</span>(array, offset, length, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException x) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>put</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><br>    hb[ix(nextPutIndex())] = x; <span class="hljs-comment">//hb数组position位置赋值为x</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextPutIndex</span><span class="hljs-params">()</span> &#123;                          <span class="hljs-comment">// package-private</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> position;<br>    <span class="hljs-keyword">if</span> (p &gt;= limit)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferOverflowException</span>();<br>    position = p + <span class="hljs-number">1</span>; <span class="hljs-comment">//position加一</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>flip</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读之前一定要flip切换到读模式，也就是把position归0（使用wrap创建的buffer不用，因为position为0）</span><br><span class="hljs-keyword">public</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;<br>    limit = position; <span class="hljs-comment">//limit设为最后一个数据位置的下一个位置</span><br>    position = <span class="hljs-number">0</span>; <span class="hljs-comment">//position归0开始读</span><br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>clear方法清空缓冲区；compact方法只会清空已读取的数据，而还未读取的数据继续保存在Buffer中；</li></ol><h5 id="channel"><a href="#channel" class="headerlink" title="channel"></a><strong>channel</strong></h5><ul><li>channel可以同时读写，流只能单独读或者写</li><li>channel可以实现异步读写数据</li><li>channel可以从buffer读取数据，也可以写数据到buffer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//RandomAccessFile操作文件，第二个参数mode：</span><br><span class="hljs-comment">// r：只读；rw：读写；rws/rwd：写操作同步刷新到磁盘</span><br><br><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> raf.getChannel()) &#123;<br><br>    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes())); <span class="hljs-comment">//读</span><br>    System.out.println(<span class="hljs-string">&quot;After write: position : &quot;</span> + channel.position());<br>    channel.position(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, read));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br></code></pre></td></tr></table></figure><p>channel还有个文件锁的功能，尝试获取与 <code>FileChannel</code> 关联的文件区域的独占或共享锁，shared变量声明是独占还是共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阻塞式，如果无法立即获取锁（因为其他线程或进程已经持有了锁），那么调用线程会被阻塞</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FileLock <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)</span><br><span class="hljs-comment">//非阻塞式，尝试立即获取锁，如果锁不可用则不会阻塞，而是返回 null。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FileLock <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)</span><br></code></pre></td></tr></table></figure><h5 id="selector"><a href="#selector" class="headerlink" title="selector"></a><strong>selector</strong></h5><p>一个组件，可以检测多个NIO channel，看看读或者写事件是否就绪。</p><p>多个Channel以事件的方式可以注册到同一个Selector，从而达到用一个线程处理多个请求成为可能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-comment">//ServerSocketChannel 用于服务端，负责监听和接受连接请求。</span><br><span class="hljs-comment">//SocketChannel 用于客户端或服务端，负责连接和进行数据传输。</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>     <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open()) &#123;<br>    serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>    <span class="hljs-comment">//要使用选择器，必须使用非阻塞方式，这样才不会像阻塞IO一样卡在accept()方法</span><br>    serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>        System.out.println(<span class="hljs-string">&quot;监听到&quot;</span>+ count +<span class="hljs-string">&quot;个事件&quot;</span>);<br>        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">//如果当前key对应的通道已经做好准备accept</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;客户端连接：&quot;</span> + socketChannel.getRemoteAddress());<br>                <span class="hljs-comment">//将这个连接也注册到选择器</span><br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">//如果当前连接有可读的数据并且可以写，就开始处理</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>                <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>                    byteBuffer.flip();<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, read));<br>                &#125;<br>                socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到&quot;</span>.getBytes()));<br>            &#125;<br>            iterator.remove();<span class="hljs-comment">//调用 iterator.remove() 是为了从 selectedKeys 集合中移除已经处理过的 SelectionKey。如果不移除，下一次循环时这些 SelectionKey 还会被再次处理，可能会导致重复处理同一个事件。</span><br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span><br>     SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>));<br>     <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;已连接服务器！&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;请输入发送的内容：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        socketChannel.write(ByteBuffer.wrap(line.getBytes()));<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        socketChannel.read(buffer);<br>        buffer.flip();<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回的：&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, buffer.limit()));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="reactor模式"><a href="#reactor模式" class="headerlink" title="reactor模式"></a>reactor模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Reactor，统筹全局</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, Closeable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = ServerSocketChannel.open();<br>        <span class="hljs-built_in">this</span>.selector = Selector.open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            <span class="hljs-comment">//要使用选择器，必须使用非阻塞方式，这样才不会像阻塞IO一样卡在accept()方法</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>(serverSocketChannel, selector));<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>                System.out.println(<span class="hljs-string">&quot;监听到&quot;</span> + count + <span class="hljs-string">&quot;个事件&quot;</span>);<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-built_in">this</span>.dispatch(iterator.next());<span class="hljs-comment">//SelectionKey实际上就是Acceptor或者Handler，这里转发过去调用run方法启动。</span><br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span> <span class="hljs-params">(SelectionKey key)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> key.attachment();<br>        <span class="hljs-keyword">if</span> (attachment <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>            ((Runnable) attachment).run();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        serverSocketChannel.close();<br>        selector.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Acceptor 负责监听和接收连接请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = serverSocketChannel;<br>        <span class="hljs-built_in">this</span>.selector = selector;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端连接：&quot;</span> + socketChannel.getRemoteAddress());<br>            <span class="hljs-comment">//将这个连接也注册到选择器</span><br>            socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            socketChannel.register(selector, SelectionKey.OP_READ, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(socketChannel));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Handler 处理每个客户端连接的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadPoolExecutor pool;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(SocketChannel socketChannel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socketChannel = socketChannel;<br>        pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>,<br>                <span class="hljs-number">60</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">20</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>            <span class="hljs-keyword">if</span> (read &lt; <span class="hljs-number">0</span>) &#123;<br>                socketChannel.close();<br>                System.out.println(<span class="hljs-string">&quot;客户端断开连接！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            pool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (byteBuffer.remaining() == <span class="hljs-number">0</span>) &#123;<br>                        byteBuffer.flip();<br>                        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+ Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> +<br>                                <span class="hljs-string">&quot;处理客户端消息： &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, byteBuffer.remaining()));<br>                        byteBuffer.clear();<br>                    &#125;<br>                    socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到&quot;</span>.getBytes()));<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="主从reactor模式"><a href="#主从reactor模式" class="headerlink" title="主从reactor模式"></a>主从reactor模式</h5><h4 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h4><p>客户端关闭导致服务端空轮询</p><p>粘包拆包问题</p><ul><li>消息定长</li><li>每个包末尾使用特殊分隔符</li><li>将消息分为头部和本体，头部保存数据包的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2024/06/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p><strong>IPV4</strong></p><p>本机：127.0.0.1</p><p>四个字节，每一字节0~255，42亿种，2011年就用完了</p><p><strong>IPV6</strong></p><blockquote><p>2001:0db8:85a3:0000:0000:8a2e:0370:7334</p></blockquote><p>8个无符号整数组成</p><p>16个字节，地球上每一粒沙子都可以分配一个</p><p><strong>公网&#x2F;私网&#x2F;NAT</strong></p><p>公网ip：互联网（全球唯一）</p><p>私网ip：局域网（常见192.168.）</p><p>NAT（网络地址转换）：当私网内部的设备需要访问互联网时，路由器会将设备的私网IP地址转换为一个公网IP地址，并在返回通信时将其转换回私网IP地址。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口表示计算机上一个程序的进程</p><ul><li><p>不同的进程有不同的端口号，用来区分软件</p></li><li><p>0 ~ 2^16 （65535）个</p></li><li><p>TCP&#x2F;UDP：单个协议下端口号不能相同，TCP和UDP互相不冲突</p></li><li><p>端口分类</p><ul><li><p>公有端口 0 ~ 1023</p><ul><li>HTTP：80</li><li>HTTPS：443</li><li>FTP：21</li></ul></li><li><p>程序注册端口 1024 ~ 49151</p><ul><li>MySQL：3306</li><li>Redis：6379</li></ul></li><li><p>动态端口 49152 ~ 65535</p></li></ul></li></ul><blockquote><p>netstat 查看网络相关信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat //显示所有活动的连接<br>netstat -a //显示所有连接和监听端口<br>netstat -n //以数字形式显示地址和端口号（不进行DNS解析）<br>netstat -o //显示与每个连接相关的进程ID（PID）<br>netstat -p tcp //显示特定协议的连接<br>netstat -tulnp //Linux特有，显示所有连接和监听端口，带PID和程序名<br></code></pre></td></tr></table></figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>打电话，连接，稳定</p><p>客户端、服务端</p><p>传输完成，释放连接，效率低</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>发短信，不连接，不稳定</p><p>客户端服务端没有明确的界限</p><p>不管准备好与否，都可以发给你</p><p>DDOS：洪水攻击</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解与反射</title>
    <link href="/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>标记某个被注解的东西（类， 方法等），让其他程序根据这个东西上面的注解信息来执行对他的操作</p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>Target</li></ul><p><img src="/@Target%E5%85%83%E6%B3%A8%E8%A7%A3.png" alt="Target作用域"></p><ul><li>Retention</li></ul><p><img src="/@Retention.png" alt="Retention保留"></p><ul><li>Documented：表示注解是否被 javadoc 工具记录，默认情况下注解是不包含在 javadoc 中的。</li><li>Inherited：表示注解是否可以被继承，默认情况下注解是不会被子类继承的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Person &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-meta">@Person(age = 20)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Person(age = 18, name = &quot;fred&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        <span class="hljs-keyword">return</span> food;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> test.class.getMethod(<span class="hljs-string">&quot;eat&quot;</span>, String.class); <br>            <span class="hljs-keyword">if</span> (eat.isAnnotationPresent(Person.class)) &#123; <span class="hljs-comment">//判断该元素上是否有Person注解</span><br>                <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> eat.getAnnotation(Person.class);<span class="hljs-comment">//获取方法上的注解</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> person.name();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> person.age();<br>                System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>            &#125;<br><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> test.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">//反射获取字段</span><br>            <span class="hljs-type">Person</span> <span class="hljs-variable">personOnA</span> <span class="hljs-operator">=</span> a1.getAnnotation(Person.class); <br>            System.out.println(personOnA.age());<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//junit 源码</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; expected() <span class="hljs-keyword">default</span> None.class;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">None</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取类的class对象</span><br>Class&lt;?&gt; clazz = MyClass.class;<br><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>Class&lt;?&gt; clazz = obj.getClass();<br><br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.MyClass&quot;</span>);<br><br><span class="hljs-comment">// 获取所有公共方法，包括继承的公共方法</span><br>Method[] methods = clazz.getMethods();<br><br><span class="hljs-comment">// 获取所有声明的方法（包括私有），不包括继承的方法</span><br>Method[] declaredMethods = clazz.getDeclaredMethods();<br><br><span class="hljs-comment">// 获取特定参数类型的方法，获取不到私有方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;methodName&quot;</span>, String.class);<br><br><span class="hljs-comment">// 获取字段</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;fieldName&quot;</span>);<br><br><span class="hljs-comment">// 获取字段的值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(obj);<br><br><span class="hljs-comment">// 设置字段的值</span><br>field.set(obj, <span class="hljs-string">&quot;newValue&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2024/06/26/JVM/"/>
    <url>/2024/06/26/JVM/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><p><img src="/2024/06/26/JVM/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="JVM体系结构"></p><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//构造方法也是方法，存储在方法区</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wolf</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//方法区</span><br>        System.out.println(name + <span class="hljs-string">&quot; age &quot;</span> + age + <span class="hljs-string">&quot; wolf&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;fred&quot;</span>, <span class="hljs-number">23</span>);<br>        dog.wolf();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行时，JVM各区域存储的信息</p><p><img src="/2024/06/26/JVM/jvm%E5%AE%9E%E4%BE%8B.png" alt="JVM实例"></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区</strong>是Java虚拟机规范（JVM Specification）中定义的逻辑部分。<strong>永久代</strong>（Permanent Generation，PermGen）是HotSpot JVM在Java 8之前对方法区的具体实现。<strong>元空间</strong>（Metaspace）是Java 8及以后版本中对方法区的新的实现，取代了永久代。</p><p>被所有线程共享，存储静态变量，常量（final），常量池（包括字符串常量和基本类型常量），类信息（类的名称、父类、接口、字段、方法等）</p><h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>存储对象的引用、方法调用相关的信息（局部变量、操作数栈、返回地址等），管理简单，速度快，但空间有限，生命周期短。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p><img src="/2024/06/26/JVM/%E5%A0%86%E5%86%85%E5%AD%98.png" alt="堆内存示意图"></p><blockquote><p>使用VM options调整JVM启动参数</p></blockquote><p><strong>堆内存大小配置</strong>：</p><ul><li><code>-Xms</code>：设置JVM堆内存的初始大小。</li><li><code>-Xmx</code>：设置JVM堆内存的最大大小。</li></ul><p><strong>年轻代和老年代的比例</strong>：</p><ul><li><code>-XX:NewRatio</code>：这个参数用于设置老年代与年轻代的比例。默认值通常为2，即老年代大小是年轻代的两倍。比如，如果设置为<code>-XX:NewRatio=3</code>，则老年代大小是年轻代的三倍。</li><li><code>-XX:MaxNewSize</code>：设置年轻代的最大大小。</li><li><code>-XX:NewSize</code>：设置年轻代的初始大小。</li></ul><p><strong>查看GC详细参数</strong>：</p><ul><li><code>-XX:+PrintGCDetails</code></li></ul><p><strong>使用jprofiler查看heap dump文件</strong>：</p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">totalMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory();<br>        System.out.println(totalMemory + <span class="hljs-string">&quot;-&gt;&quot;</span> + totalMemory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;mb&quot;</span>);<br>        System.out.println(maxMemory + <span class="hljs-string">&quot;-&gt;&quot;</span> + maxMemory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;mb&quot;</span>);<br><br>        List&lt;HeapTest&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapTest</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/06/26/JVM/heapDump.png" alt="jProfiler可以看到ArrayList被撑爆了"></p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>​引用计数算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为该对象不再被使用，是“垃圾”了。</p><ul><li>缺点：每次对对象赋值时均要更新计数器，且计数器本身也占用内存，故jdk1.1已弃用</li></ul><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p><strong>Eden区</strong>：</p><ul><li>Eden区是新对象最初分配的地方。</li><li>当Eden区满时，会触发一次Minor GC（新生代的垃圾收集）。</li><li>在Minor GC过程中，复制算法会将存活的对象复制到Survivor区的一个空闲区域（一般是To区）。</li></ul><p><strong>Survivor区</strong>：</p><ul><li>在Minor GC过程中，存活的对象会从Eden区和From区复制到To区。</li><li>每次Minor GC后，From区和To区的角色会互换，即To区变为新的From区，From区变为空闲区（To）。</li></ul><p>优点：无内存碎片，内存效率高，时间复杂度低</p><p>缺点：需要一片额外空白内存空间，内存利用率低</p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>​为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 <code>GC</code> 操作。</p><p>优点：内存利用率高</p><p>缺点：每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，内存碎片多</p><h4 id="标记-整理-压缩算法（Mark-Compact）"><a href="#标记-整理-压缩算法（Mark-Compact）" class="headerlink" title="标记-整理&#x2F;压缩算法（Mark-Compact）"></a>标记-整理&#x2F;压缩算法（Mark-Compact）</h4><p>标记阶段：与标记-清除算法类似，标记出所有活动对象。</p><p>整理阶段：将所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><p>优缺点：相比标记-清除算法，减少了内存碎片的产生，但是移动对象可能会增加算法的复杂性和执行时间。</p><blockquote><p>GC：分代收集算法</p></blockquote><p>即新生代的对象存活率低，使用复制算法，老年代存活率高，内存区域大，使用标记清除 + 标记压缩算法（先使用标记清除，内存碎片多到一定量就压缩清除一次）</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>后台运行</strong>：守护线程通常用于在后台执行辅助任务，例如垃圾收集、日志记录、监控等。</p><p><strong>生命周期依赖于非守护线程</strong>：当所有非守护线程结束时，JVM会终止所有仍在运行的守护线程并退出。</p><p><strong>低优先级</strong>：通常守护线程的优先级较低，因为它们的任务不如用户线程（非守护线程）重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;我是守护线程&quot;</span> + Thread.currentThread().getName());<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;DaemonThread&quot;</span>);<br><br>    thread.setDaemon(<span class="hljs-literal">true</span>);<br>    thread.start();<br><br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    System.out.println(<span class="hljs-string">&quot;我是主线程，我即将退出&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">我是守护线程DaemonThread<br>我是守护线程DaemonThread<br>我是守护线程DaemonThread<br>我是主线程，我即将退出<br></code></pre></td></tr></table></figure><p>守护线程适用于以下场景：</p><ol><li><strong>垃圾收集器</strong>：JVM自带的垃圾收集线程就是一个守护线程，用于在后台清理不再使用的对象。</li><li><strong>日志记录</strong>：在后台记录应用程序的运行日志。</li><li><strong>监控</strong>：用于监控应用程序的状态，例如资源使用情况、性能指标等。</li></ol><h3 id="类加载器-双亲委派机制"><a href="#类加载器-双亲委派机制" class="headerlink" title="类加载器&#x2F;双亲委派机制"></a>类加载器&#x2F;双亲委派机制</h3><ul><li>Bootstrap ClassLoader ：jre&#x2F;lib</li><li>ExtClassLoader ： jre&#x2F;lib&#x2F;ext下的jar</li><li>AppClassLoader ： 加载用户路径ClassPath下的包</li><li>自定义类加载器 ： 加载用户自定义路径下的包</li></ul><blockquote><p>双亲委派机制：先自底向上检查是否已经加载，若未加载则从Bootstrap开始往下查看自己是否可以加载，若失败则抛出ClassNotFoundException</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">//              -----??-----</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.即首先Bootstrap findClass -&gt; ExtClassLoader -&gt; AppClassLoader</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>jar tf rt.jar</code>查看jdk8&#x2F;jre&#x2F;lib下的rt.jar包（bootstrap加载器加载的类库）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">java/lang/Exception.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/ThreadDeath.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Error.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Throwable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/System.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/ClassLoader.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Cloneable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/Type.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/AnnotatedElement.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/GenericDeclaration.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Class.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/CharSequence.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Comparable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/io/Serializable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/String.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Object.class<br></code></pre></td></tr></table></figure><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>native方法是用C和C++编写的底层方法，Java调用native方法的线程会进入该线程的本地方法栈，调用本地方法接口JNI</p><p>扩展Java的使用，融合不同的语言为Java使用</p><p>在内存中专门开辟的一片区域，本地方法栈，登记native方法</p><p>在JVM中，每个线程都有自己的本地方法栈，用于存储该线程的本地方法调用。当Java线程调用一个本地方法时：</p><ol><li>JVM创建一个新的本地方法栈帧并将其推入该线程的本地方法栈。</li><li>该线程在本地方法栈帧中执行本地代码。</li><li>执行完成后，JVM将结果返回给Java代码，栈帧被移出本地方法栈。</li></ol><p>这种设计确保了每个线程都有自己的本地方法调用栈帧，不会与其他线程的本地方法调用混淆，从而保证了线程安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>; <span class="hljs-comment">//Thread类通过本地方法start0启动线程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2024/06/22/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/06/22/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><p>虽然在学习CS61B的时候自己动手写了一个简易版的HashMap，但是跟实际的完全没有可比性，最近开始深入底层，遂记录。</p><h3 id="初始参数"><a href="#初始参数" class="headerlink" title="初始参数"></a>初始参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//转红黑树阈值，链表中元素大于此就将其转为红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; <span class="hljs-comment">//树转链表阈值，树中元素低于此就转为链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>; <span class="hljs-comment">//整个表中元素超过该值时才可以开启树形化操作 ？？？？还是数组长度？？？</span><br></code></pre></td></tr></table></figure><h3 id="初始方法"><a href="#初始方法" class="headerlink" title="初始方法"></a>初始方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &gt;&gt;&gt;表示无符号右移</span><br><span class="hljs-comment">// 对key的hashCode右移16位再异或，可以增加hash的复杂度，降低hash冲突的概率</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br><span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br><span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* onlyIfAbsent:默认为false，表示若key相同，用新值覆盖旧值</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">//第一次插入元素，初始化，HashMap为了节约内存在使用时才初始化数组</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>    <span class="hljs-comment">//路由地址算法，即hash % n，这里n为数组长度，始终是2的幂，故可以用位运算来优化</span><br>    <span class="hljs-comment">//数组该地址对应的节点为空，创建一个新节点即可</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">//当前节点就是目标节点</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-comment">//没找到目标节点，且当前节点是红黑树节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-comment">//当前节点是普通链表节点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-comment">//尾插法</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//找到目标节点，立即break;</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//存在key对应的mapping</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-comment">// 覆盖旧值</span><br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * newCap: the new capacity, MUST be a power of two</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;   <span class="hljs-comment">// 获取旧表</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;  <span class="hljs-comment">// 获取旧表的容量old capacity</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;  <span class="hljs-comment">// 获取旧的扩容阈值</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果旧表的容量大于0</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">// 如果旧容量已经达到最大容量</span><br>            threshold = Integer.MAX_VALUE;  <span class="hljs-comment">// 将阈值设置为最大值</span><br>            <span class="hljs-keyword">return</span> oldTab;  <span class="hljs-comment">// 返回旧表</span><br>        &#125;<br>        newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 新容量是旧容量的两倍</span><br>        <span class="hljs-keyword">if</span> (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 新的扩容阈值也是旧阈值的两倍</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;  <span class="hljs-comment">// 如果旧容量为0但旧阈值大于0，设置新容量为旧阈值</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// oldThr == 0 &amp;&amp; oldCap == 0 此为第一次初始化map时的操作</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="hljs-comment">// 设置新容量为默认初始容量</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  <span class="hljs-comment">// 设置新的扩容阈值 16 * 0.75 = 12</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;  <span class="hljs-comment">// 更新阈值</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];  <span class="hljs-comment">// 创建新表</span><br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果旧表不为空</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="hljs-comment">// 遍历旧表中的每个桶</span><br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果当前桶不为空</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放旧表中的引用，帮助垃圾回收</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)  <span class="hljs-comment">// 如果当前桶中只有一个节点</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;  <span class="hljs-comment">// 直接将节点放到新表中的相应位置</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)  <span class="hljs-comment">// 如果当前桶是树节点</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);  <span class="hljs-comment">// 调用split方法，将树节点拆分并放到新表中</span><br>                <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果当前桶是链表节点，按位重新分配</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 低位链表的头尾节点</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 高位链表的头尾节点</span><br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;  <span class="hljs-comment">// 记录下一个节点</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果哈希值与旧容量按位与为0，放到低位链表</span><br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则放到高位链表</span><br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 遍历整个链表</span><br><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果低位链表不为空</span><br>                        loTail.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 终止链表</span><br>                        newTab[j] = loHead;  <span class="hljs-comment">// 将低位链表放到新表中的相应位置</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果高位链表不为空</span><br>                        hiTail.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 终止链表</span><br>                        newTab[j + oldCap] = hiHead;  <span class="hljs-comment">// 将高位链表放到新表中的相应位置</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;  <span class="hljs-comment">// 返回新表</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="为什么都要比较两次？"><a href="#为什么都要比较两次？" class="headerlink" title="为什么都要比较两次？"></a>为什么都要比较两次？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先用&#x27;==&#x27;比较key对象的内存地址，如果地址相同则肯定是同一个对象</span><br><span class="hljs-comment">// 如果不是同一个对象，再用&#x27;equals&#x27;比较对象的内容，如果内容相同</span><br>(k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))<br>(v = e.value) == value || (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)) <span class="hljs-comment">//containsValue方法</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程</title>
    <link href="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个程序，wechat.exe。每个进程都有自己独立的一块内存空间</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程中的一个执行任务，同类的多个线程共享进程的堆区和方法区，每个线程有独立的PC，虚拟机栈和本地方法栈</p><p>java是不能开启线程的，Thread的start()方法通过调用本地方法<code>private native void start0();</code>来启动线程。</p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">NEW, <span class="hljs-comment">//新创建了一个线程对象，但还没有调用start()方法。</span><br><br>RUNNABLE,<span class="hljs-comment">//Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</span><br><br>BLOCKED,<span class="hljs-comment">//表示线程阻塞于锁。</span><br><br>WAITING,<span class="hljs-comment">//进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span><br><br>TIMED_WAITING,<span class="hljs-comment">//该状态不同于WAITING，它可以在指定的时间后自行返回。</span><br><br>TERMINATED;<span class="hljs-comment">//表示该线程已经执行完毕。</span><br></code></pre></td></tr></table></figure><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default priority that is assigned to a thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum priority that a thread can have.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPriority</span><span class="hljs-params">(<span class="hljs-type">int</span> newPriority)</span> &#123; <span class="hljs-comment">// source code</span><br>    ThreadGroup g;<br>    checkAccess();<br>    <span class="hljs-keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>((g = getThreadGroup()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;<br>            newPriority = g.getMaxPriority();<br>        &#125;<br>        setPriority0(priority = newPriority);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>CPU一核，快速交替执行多个线程 操作同一个资源</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>CPU多核同时执行多个线程</p><h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><p>1、synchronized是Java内置关键字，Lock是类</p><p>2、synchronized无法判断获取锁的状态，Lock可以</p><p>3、synchronized会自动释放锁，Lock必须手动释放，否则会<strong>死锁</strong></p><p>4、synchronized未获取到锁的线程会一直等待，Lock锁不一定会一直等待下去</p><p>5、synchronized可重入锁，不可以中断，非公平；Lock可重入锁，不可以中断，可设置公平与否</p><p>6、synchronized适合锁少量代码块，Lock适合锁大量同步代码</p><blockquote><p>可重入锁：synchronized， ReentrantLock，可以多次获取同一把锁</p></blockquote><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="synchronized锁版本"><a href="#synchronized锁版本" class="headerlink" title="synchronized锁版本"></a>synchronized锁版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pc</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> food;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (food != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为了防止虚假唤醒，需要将wait函数放在while循环中，而不能用if</span><br>            <span class="hljs-built_in">this</span>.wait();<br>        &#125;<br>        food ++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (food == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.wait();<br>        &#125;<br>        food --;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock锁版本"><a href="#Lock锁版本" class="headerlink" title="Lock锁版本"></a>Lock锁版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pc</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> food;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (food != <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            food ++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (food == <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            food --;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码，add方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            Object[] es = getArray(); <span class="hljs-comment">//拿到原始array</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>            es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>            es[len] = e;<br>            setArray(es); <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/** The array, accessed only via getArray/setArray. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><p>通过自定义一个lock对象，更加精细地控制同步，CopyOnWriteArrayList中的所有同步方法（mutators）都需要先获取这把锁才能执行操作，如上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The lock protecting all mutators.  (We have a mild preference</span><br><span class="hljs-comment">* for builtin monitors over ReentrantLock when either will do.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br></code></pre></td></tr></table></figure><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>和上面一样，底层是CopyOnWriteArrayList，使用CopyOnWriteArrayList的addIfAbsent方法来添加新元素并去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the element, if not present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this list, if absent</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the element was added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addIfAbsent</span><span class="hljs-params">(E e)</span> &#123;<br>    Object[] snapshot = getArray();<br>    <span class="hljs-keyword">return</span> indexOfRange(e, snapshot, <span class="hljs-number">0</span>, snapshot.length) &lt; <span class="hljs-number">0</span> <span class="hljs-comment">//indexOfRange查找当前数组范围内要新增的元素e是否存在，不存在返回-1，可以add</span><br>        &amp;&amp; addIfAbsent(e, snapshot);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 题外话：HashSet底层是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a new, empty set; the backing &#123;<span class="hljs-doctag">@code</span> HashMap&#125; instance has</span><br><span class="hljs-comment">    * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>       map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>   &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>       <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-literal">null</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code> 通过分段锁（Segment）和 CAS 操作保证了并发访问的安全性。每个 Segment 类似于一个小的 <code>HashMap</code>，它们分别维护桶数组的一部分，减少了锁的粒度，提高了并发访问性能。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  CountDownLatch 减法计数器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 离开&quot;</span>);<br>                countDownLatch.countDown();  <span class="hljs-comment">// 每个工作线程执行完成后调用countDown()方法，减少计数器</span><br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<span class="hljs-comment">// 主线程等待所有工作线程完成</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CyclicBarrier 加法计数器</span><br><span class="hljs-comment">// 构造方法：public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">7</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;开启大门&quot;</span>))); <br><span class="hljs-comment">// 7: 指定需要同步等待的线程数量，即到达屏障点的线程数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 阻塞&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                cyclicBarrier.await(); <span class="hljs-comment">// 当线程调用 await() 方法时，它会被阻塞，直到所有线程都调用了await() 方法，然后屏障会开放，启动自定义的线程执行相应操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;).start();<br></code></pre></td></tr></table></figure><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Semaphore 信号量限流</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 抢到车位！&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 离开！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br></code></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>相比于传统队列，阻塞队列引入了两组新的添加删除操作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队满则阻塞等待，一直等待直到空出位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       Objects.requireNonNull(e);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>       lock.lockInterruptibly();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == items.length)<br>               notFull.await();<br>           enqueue(e);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 队空阻塞等待，一直等待</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>       lock.lockInterruptibly();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>               notEmpty.await();<br>           <span class="hljs-keyword">return</span> dequeue();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 重载了offer方法，阻塞等待指定时间，超时则自动结束程序</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 重载了poll方法</span><br>E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><blockquote><p>同步队列 <code>SynchronousQueue</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BlockingQueue&lt;String&gt; synchronousQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><span class="hljs-comment">//1.生产者-消费者模式</span><br><span class="hljs-comment">//2.线程池任务提交</span><br><span class="hljs-comment">//3.运行时任务交换</span><br><span class="hljs-comment">//4.负载均衡</span><br></code></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>相比于Runnable，多了一个返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(thread);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;A&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    System.out.println(futureTask.get());<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running。。。&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call() called&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="阿里开发手册-线程池的创建"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">2</span>, <span class="hljs-comment">// corePoolSize</span><br>        <span class="hljs-number">5</span>, <span class="hljs-comment">// maximumPoolSize</span><br>        <span class="hljs-number">5L</span>, <span class="hljs-comment">// keepAliveTime</span><br>        TimeUnit.SECONDS, <span class="hljs-comment">// java.util.concurrent.TimeUnit unit</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">3</span>), <span class="hljs-comment">// 阻塞队列</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略</span><br>);<br><br><span class="hljs-comment">// 拒绝策略：线程数超过maximumPoolSize + BlockingQueue的size时</span><br>AbortPolicy(): 抛出异常`java.util.concurrent.RejectedExecutionException`<br>CallerRunsPolicy(): 交给调用execute方法的线程执行<br>DiscardPolicy(): 默默丢弃被拒绝的任务<br>DiscardOldestPolicy(): 丢弃最旧的未处理任务，然后尝试执行被拒绝的这个任务<br>    <br><span class="hljs-comment">// maximumPoolSize设置原则</span><br><span class="hljs-comment">// CPU密集型：maximumPoolSize = Runtime.getRuntime.availableProcessors() + 1; 加一是为了确保某些线程在等待时，仍有线程可以执行任务</span><br><span class="hljs-comment">// IO密集型：大一点，大于那些十分耗IO的线程数</span><br>    <br>  <br><span class="hljs-comment">//ThreadPoolExecutor的执行方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>; <br>Future&lt;?&gt; submit(Runnable task) <span class="hljs-comment">//有返回值，future。通过Future的get()方法同步等待线程执行完成返回</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize: 线程池中保持存活的核心线程数，即使这些线程是空闲的也不会被回收。</p></li><li><p>maximumPoolSize: 线程池中允许的最大线程数。当任务的数量超过 <code>corePoolSize</code> 并且阻塞队列已满时，如果线程数量没有达到 <code>maximumPoolSize</code>，线程池会创建新的线程来执行任务。</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过 <code>corePoolSize</code> 时，多余的空闲线程在超过 <code>keepAliveTime</code> 时间后将被终止回收。这一参数仅在线程数大于 <code>corePoolSize</code> 时才会生效。</p></li><li><p>workQueue: 阻塞队列</p></li><li><p>handler: 任务数量超过 <code>maximumPoolSize</code> + 队列容量时的拒绝策略</p></li></ul><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">//函数式接口是一个只包含一个抽象方法（abstract method）的接口</span><br><span class="hljs-comment">// 抽象方法是一个没有实现的方法，只包含方法签名（即方法的声明），但不包含方法体。抽象方法必须在实现类中被重写。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Applies this function to the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment">     */</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><br><span class="hljs-comment">//函数型接口，输入T，输出R</span><br>Function&lt;String, Integer&gt; function = Integer::parseInt; <br>function.apply(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//断言型接口，输入T，返回boolean</span><br>Predicate&lt;Integer&gt; predicate = x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <br>predicate.test(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//消费型接口，输入T，无返回值</span><br>Consumer&lt;String&gt; consumer = System.out::println;<br>consumer.accept(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//供给型接口，无输入，有返回值</span><br>Supplier&lt;String&gt; supplier = () -&gt; <span class="hljs-string">&quot;123&quot;</span>;<br>supplier.get(); <span class="hljs-comment">//返回&quot;123&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User1</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">23</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">24</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">25</span>);<br>List&lt;User1&gt; list = Arrays.asList(u1, u2, u3, u4, u5);<br><br>list.stream() <span class="hljs-comment">//Stream&lt;User1&gt;</span><br>        .filter(u -&gt; u.getId() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .filter(u -&gt; u.getAge() &gt; <span class="hljs-number">23</span>)<br>        .map(u -&gt; u.getName().toUpperCase()) <span class="hljs-comment">//Stream&lt;String&gt;</span><br>        .sorted(Comparator.reverseOrder())<br>        .limit(<span class="hljs-number">1</span>)<br>        .forEach(System.out::println);<br><span class="hljs-comment">// 输出E</span><br></code></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>并行处理框架，用于执行可以被递归地拆分成更小任务的工作负载。旨在充分利用多核处理器的能力来提升并行计算的性能。</p><p>**任务分割 (Fork)**：将一个大任务分解成多个较小的子任务。</p><p>**任务合并 (Join)**：在子任务完成后，将它们的结果合并起来形成最终结果。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//supplyAsync 有返回值的异步回调</span><br><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; supplyAsync&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 除0异常</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>&#125;);<br><br>System.out.println(future.whenComplete((t, u) -&gt; &#123; <span class="hljs-comment">// 成功走whenComplete</span><br>    System.out.println(<span class="hljs-string">&quot;t是任务成功执行时的正常返回值---&gt;&quot;</span> + t.toUpperCase()); <span class="hljs-comment">// HELLO WORLD</span><br>    System.out.println(<span class="hljs-string">&quot;u是执行失败时的错误信息---&gt;&quot;</span> + u); <span class="hljs-comment">// 成功为null</span><br>&#125;).exceptionally((e) -&gt; &#123; <span class="hljs-comment">// 失败走exceptionally</span><br>    System.out.println(e.getMessage());<br>    <span class="hljs-keyword">return</span> String.valueOf(<span class="hljs-number">404</span>);<br>&#125;).get());<br></code></pre></td></tr></table></figure><h3 id="JMM和volatile"><a href="#JMM和volatile" class="headerlink" title="JMM和volatile"></a>JMM和volatile</h3><blockquote><p>JMM: Java内存模型，是一种约定，主要规定了线程自己的本地内存和主存之间的共享变量交互的规则</p></blockquote><p>JMM同步约定：</p><p>1.线程解锁前，必须把共享变量立即写回主存</p><p>2.线程加锁前，必须读取主存共享变量的最新值到自己的工作内存</p><p><img src="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm.png" alt="JMM模型"></p><p>JMM定义的规则：</p><ul><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</p></li><li><p>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</p></li></ul><blockquote><p>volatile: JVM提供的轻量级同步机制，关键字</p></blockquote><p>1.保证可见性：这是因为 <code>volatile</code> 变量会直接存储在主存中，每次读取时都直接从主存读取，而不是从线程的工作内存（缓存）中读取。</p><p>2.不保证原子性</p><p>3.禁止指令重排，保证指令执行的顺序性：在编译器和处理器层面，使用 <code>volatile</code> 会插入内存屏障，防止对该变量的读&#x2F;写操作与其他内存操作进行重排序，从而保证了某些顺序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (num == <span class="hljs-number">0</span>) &#123;<br><br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>    num += <span class="hljs-number">1</span>;<br>    System.out.println(num);<br>&#125;<br><span class="hljs-comment">//程序打印1，但是一直执行并不结束，因为A线程中的num值一直为0，并未更新</span><br><span class="hljs-comment">//private static volatile int num = 0; 使用volatile保证num变量的可见性</span><br><span class="hljs-comment">//即一个线程对 num 的修改对其他线程是立即可见的</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//volatile不能保证对num操作的原子性，最后num的结果始终小于10000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    num ++;<br>&#125;<br><span class="hljs-comment">//num ++ 并不是一个原子操作。在多线程环境下，这些步骤可能被不同的线程打断，从而导致竞争条件。例如，一个线程读取 num 的值为 5，在它增加值之前，另一个线程也读取了同样的值 5 并增加了它们的值。最终的结果是两个线程都将值 6 写回 num，而预期的结果应该是 7。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                add();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//除了main和gc线程之外，还有上面没执行完的线程</span><br>        Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">//就让主线程让出CPU</span><br>    &#125;<br><br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + num);<br>&#125;<br><br><span class="hljs-comment">// 修改，1.使用atomic包中的原子类保证原子性 2。使用synchronized关键字</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    num.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Lazy instance; <span class="hljs-comment">//volatile禁止指令重排，保证instance创建成功，而不会出现（1）先分配内存空间，（2）instance指向该内存空间，（3）接着再初始化对象的情况发生，这种情况其他线程可能返回一个不为null但未被初始化的对象</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Lazy</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ok&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Lazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//双重检测锁定</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Lazy.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;      <br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lazy</span>();<span class="hljs-comment">//正常创建对象指令 (1)分配内存空间</span><br>            &#125;  <span class="hljs-comment">//   (2)执行构造方法初始化对象</span><br>        &#125;  <span class="hljs-comment">//         (3)把instance对象指向该内存空间</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Lazy::getInstance).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用枚举类实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Cannot reflectively create enum objects 反射不能创建枚举对象，因此是安全的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">singleEnum</span> &#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-keyword">public</span> singleEnum <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>乐观锁就是操作共享变量时乐观地认为不会有其他线程对数据进行修改，不加锁，只有在提交时（更新时）判断其他线程在这之前有没有对变量进行修改，失败就回滚或者提示。可以通过版本号机制或者CAS算法实现</p></blockquote><blockquote><p>悲观锁总是悲观地假设最坏的情况，操作时加锁，一次只能一个线程访问，其他线程只能等待。MySQL的读写锁，synchronized关键字等</p></blockquote><h4 id="版本号控制"><a href="#版本号控制" class="headerlink" title="版本号控制"></a>版本号控制</h4><ul><li>取出记录时，获取当前<code>version</code></li><li>更新时，带上这个<code>version</code></li><li>执行更新时， <code>set version = newVersion where version = oldVersion</code></li><li>如果<code>version</code>不对，就更新失败</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><blockquote><p>compare and swap的缩写</p></blockquote><p>三个参数：</p><ul><li>需要读写的内存位置<code>V</code></li><li>进行比较的预期原值<code>A</code></li><li>拟写入的新值<code>B</code></li></ul><p>缺点：</p><ul><li><p>ABA问题</p><p>比如说一个线程<code>T1</code>从内存位置<code>V</code>中取出<code>A</code>，这时候另一个线程<code>T2</code>也从内存中取出<code>A</code>，并且<code>T2</code>进行了一些操作变成了<code>B</code>，然后<code>T2</code>又将<code>V</code>位置的数据变成<code>A</code>，这时候线程<code>T1</code>进行<code>CAS</code>操作发现内存中仍然是<code>A</code>，然后<code>T1</code>操作成功。尽管线程<code>T1</code>的<code>CAS</code>操作成功，但可能存在潜藏的问题。</p></li><li><p>自旋CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@IntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 自旋锁</span><br>        v = getIntVolatile(o, offset); <span class="hljs-comment">// 获取对象在偏移处的volatile最新值（volatile保证可见性，被其他线程更新的值）</span><br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta)); <span class="hljs-comment">// CAS操作，不解释了</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><p>AtomicInteger</p><p>AtomicReference<V></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;bob&quot;</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>(dog1, dog2), <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>(dog2, dog1), <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123; <span class="hljs-comment">//拿狗当锁</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    Dog dogA;<br>    Dog dogB;<br><br>    MyThread1(Dog A, Dog B) &#123;<br>        <span class="hljs-built_in">this</span>.dogA = A;<br>        <span class="hljs-built_in">this</span>.dogB = B;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (dogA) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;锁定了&quot;</span> + dogA);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (dogB) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;锁定了&quot;</span> + dogB);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>使用 **<code>jps -l</code>**查看进程的进程号</p><p>使用 **<code>jstack &quot;进程号&quot;</code>**定位死锁问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;t1&quot;</span>:<br>        at com.fu1sh.juc.MyThread1.run(DeadLockTest.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x000000071be545c8</span>&gt; (a com.fu1sh.juc.Dog)<br>        - locked &lt;<span class="hljs-number">0x000000071be54588</span>&gt; (a com.fu1sh.juc.Dog)<br>        at java.lang.Thread.run(java.base@<span class="hljs-number">17.0</span><span class="hljs-number">.10</span>/Thread.java:<span class="hljs-number">842</span>)<br><span class="hljs-string">&quot;t2&quot;</span>:<br>        at com.fu1sh.juc.MyThread1.run(DeadLockTest.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x000000071be54588</span>&gt; (a com.fu1sh.juc.Dog)<br>        - locked &lt;<span class="hljs-number">0x000000071be545c8</span>&gt; (a com.fu1sh.juc.Dog)<br>        at java.lang.Thread.run(java.base@<span class="hljs-number">17.0</span><span class="hljs-number">.10</span>/Thread.java:<span class="hljs-number">842</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/06/17/Redis/"/>
    <url>/2024/06/17/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Linux下登录Redis"><a href="#Linux下登录Redis" class="headerlink" title="Linux下登录Redis"></a>Linux下登录Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 -a YourPassword --raw //raw显示原数据<br></code></pre></td></tr></table></figure><h3 id="Redis的数据格式"><a href="#Redis的数据格式" class="headerlink" title="Redis的数据格式"></a>Redis的数据格式</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set name fuish<br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br><span class="hljs-string">&quot;fuish&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; del <span class="hljs-title function_">name</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; exists <span class="hljs-title function_">name</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set age <span class="hljs-number">22</span><br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; keys * <span class="hljs-comment">//keys patten ：模式匹配键</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;x&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; keys *ge<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set msg 中文消息也是以二进制保存<br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get msg<br><span class="hljs-string">&quot;\xe4\xb8\xad\xe6\x96\x87\xe6\xb6\x88\xe6\x81\xaf\xe4\xb9\x9f\xe6\x98\xaf\xe4\xbb\xa5\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6\xe4\xbf\x9d\xe5\xad\x98&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; redis-cli -h <span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span> -p <span class="hljs-number">6379</span> -a **** --raw <span class="hljs-comment">//加上--raw参数表示以原始形式显示内容</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get msg<br>中文消息也是以二进制保存<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg <span class="hljs-comment">//查看key过期时间</span><br>-<span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; expire msg <span class="hljs-number">10</span> <span class="hljs-comment">// 设置key的过期时间，10s</span><br><span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg<br><span class="hljs-number">6</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg<br><span class="hljs-number">2</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setex name <span class="hljs-number">10</span> fuish <span class="hljs-comment">//设置带有过期时间的键值对，10s</span><br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl name<br><span class="hljs-number">4</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl name<br><span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setnx name kk <span class="hljs-comment">// 键不存在时才设置键的值</span><br><span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br>kk<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setnx name fuish<br><span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br>kk<br></code></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush list a b c d e  <span class="hljs-comment">//push elements in the head of the list</span><br>(integer) <span class="hljs-number">5</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpop list <span class="hljs-comment">// remove element in the tail</span><br><span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpop list<br><span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; llen <span class="hljs-title function_">list</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush list  d e f <span class="hljs-title function_">g</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">7</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;g&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ltrim list <span class="hljs-number">2</span> <span class="hljs-number">4</span>  <span class="hljs-comment">//trim </span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd animal <span class="hljs-title function_">dog</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers animal<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd animal dog <span class="hljs-comment">// Duplicate element is NOT allowed in Set</span><br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember animal dog <span class="hljs-comment">// Is dog a member of Set Animal</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem animal dog <span class="hljs-comment">// Remove dog</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd s1 dog cat <span class="hljs-title function_">pig</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd s2 cat <span class="hljs-title function_">pig</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sinter s1 s2 <span class="hljs-comment">// Intersection of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;pig&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sunion s1 s2 <span class="hljs-comment">// Union of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;pig&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;  sdiff s1 s2 <span class="hljs-comment">// Difference of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd schools <span class="hljs-number">700</span> 清华 <span class="hljs-number">680</span> 浙大 <span class="hljs-number">660</span> 复旦 <span class="hljs-number">640</span> 成电<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange schools <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br>成电<br>复旦<br>浙大<br>清华<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange schools <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<br>成电<br><span class="hljs-number">640</span><br>复旦<br><span class="hljs-number">660</span><br>浙大<br><span class="hljs-number">680</span><br>清华<br><span class="hljs-number">700</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zscore schools 清华<br><span class="hljs-number">700</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank schools 清华 <span class="hljs-comment">// Index of &quot;清华&quot;</span><br><span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank schools 清华 <span class="hljs-comment">// Reverse the rank of &quot;清华&quot; and output</span><br><span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank schools 成电<br><span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank schools 清华 <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog name fuish<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog age <span class="hljs-number">22</span><br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog msg hello<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br>msg<br>hello<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel dog msg<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel dog msg<br><span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists dog name<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hkeys dog<br>name<br>age<br><br></code></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>不同于数据库事务是一个原子操作，要么全部成功要么全部失败。Redis事务只是一批任务的执行集合，允许个别失败，不影响其他任务的成功执行</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB：Redis-DataBase"><a href="#RDB：Redis-DataBase" class="headerlink" title="RDB：Redis DataBase"></a>RDB：Redis DataBase</h4><ul><li><p>配置文件自动每隔指定的时间间隔将Redis中的数据写入硬盘中</p></li><li><p>save命令，生成dump.rbd，rdb 文件是紧凑的二进制文件，适合备份和传输。创建快照过程中Redis是阻塞的，性能开销大</p></li><li><p>bgsave命令：Redis 通过子进程来完成快照操作，主进程可以同步接收请求。但是如果在快照之间发生故障，可能会丢失最新的一些数据。</p></li></ul><h4 id="AOF-：Append-Only-File"><a href="#AOF-：Append-Only-File" class="headerlink" title="AOF ：Append-Only File"></a>AOF ：Append-Only File</h4><ul><li>Redis 可以将每个写操作都追加到一个日志文件中（AOF 文件）。</li><li>Redis重启时，重新执行AOF文件中的命令来重建数据集。</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式用于监控Redis实例的健康状况，并在主节点故障时进行自动故障转移。它是一种高可用性解决方案，确保Redis集群能够在主节点发生故障时继续正常运行。</p><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ol><li><strong>监控</strong>：Sentinel不断检查主节点和从节点是否正常运行。</li><li><strong>通知</strong>：当某个节点出现问题时，Sentinel可以通知系统管理员或其他应用程序。</li><li><strong>自动故障转移</strong>：如果主节点故障，Sentinel会自动将一个从节点提升为新的主节点，并将其他从节点指向新的主节点。</li><li><strong>配置提供</strong>：客户端可以通过Sentinel获取当前的主节点地址，从而连接到正确的主节点。</li></ol><h3 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>定义：客户端请求的数据在缓存和数据库中都找不到，缓存永不生效，请求全打到数据库。</p><p>解决方法</p><ul><li>缓存空对象<ul><li>优点： 实现简单，维护方便</li><li>缺点： 额外的内存消耗，且可能造成短期的数据不一致问题</li></ul></li><li>布隆过滤器<ul><li>优点：内存占用少，没有多余的key</li><li>缺点：实现复杂，且存在误判可能</li></ul></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>定义：同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案</p><ul><li>给不同key的TTL添加随机值</li><li>搭建Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h4 id="缓存击穿（热点key问题）"><a href="#缓存击穿（热点key问题）" class="headerlink" title="缓存击穿（热点key问题）"></a>缓存击穿（热点key问题）</h4><p>定义：一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>解决方案</p><ul><li><p>互斥锁：同一时间只能有一个线程拿到锁执行缓存重建</p><ul><li>优点：简单方便，没有多余的内存消耗，保证强一致性</li><li>缺点：线程等待获取锁的时间过长，可能有死锁风险</li></ul></li><li><p>逻辑过期</p><ul><li>不设置TTL，加一个expire time，当前线程查询缓存发现逻辑过期时间已经过期后，获取互斥锁，开启一个新线程来为自己执行重建数据库的操作。其他线程查询这个缓存均返回过期数据就行，无需等待</li><li>缺点：不保证一致性，有额外的内存消耗，实现复杂</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结</title>
    <link href="/2024/05/16/HTTP%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/16/HTTP%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h1><p>1、HTTP是什么？<br>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</p><ul><li>超文本：它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li><li>传输：HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</li><li>协议：它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</li></ul><p>2、HTTP状态码</p><ul><li>200 OK：成功</li><li>3xx：表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx：表示客户端发送的报文有误，服务器无法处理，属于客户端的错误码。</li><li>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</li></ul><p>3、HTTP字段</p><ul><li>Host：客户端发送请求时，用来指定服务器的域名。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Host:</span> www.A.com<br></code></pre></td></tr></table></figure></li><li>Content-Length 字段：服务器返回数据的长度。</li><li>Connection 字段：客户端要求服务器使用「HTTP 长连接」机制，<code>Connection: Keep-Alive</code></li><li>Content-Encoding 字段：服务器返回的数据使用了什么压缩格式。</li></ul><h1 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET&#x2F;POST"></a>GET&#x2F;POST</h1><p>1、GET 和 POST 方法都是安全和幂等的吗？</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>RFC 规范定义下：</p><ul><li><p>GET 方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</p></li><li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</p></li></ul><h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><p>把重复性的 HTTP「请求-响应」的数据缓存在本地</p><p>1、强制缓存</p><ul><li>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。通过HTTP 响应头部（Response Header）的字段<code>Cache-Control</code>和<code>Expires</code>控制</li></ul><p>2、协商缓存</p><ul><li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。与服务端协商之后，通过协商结果来判断是否使用本地缓存。</li></ul><h1 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h1><h2 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h2><p>优化：</p><ul><li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>缺点：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>请求只能从客户端开始，服务器只能被动响应；</li><li>没有请求优先级控制。</li></ul><h2 id="HTTP-2-相比-HTTP-1-1-性能上的改进"><a href="#HTTP-2-相比-HTTP-1-1-性能上的改进" class="headerlink" title="HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进"></a>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进</h2><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p>缺点：</p><ul><li>一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">2</span> 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 <span class="hljs-number">1</span> 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 <span class="hljs-number">1</span> 个字节数据到达时，HTTP/<span class="hljs-number">2</span> 应用层才能从内核中拿到数据，这就是 HTTP/<span class="hljs-number">2</span> 队头阻塞问题。<br></code></pre></td></tr></table></figure></li></ul><h2 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h2><p> HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br> <img src="/2024/05/16/HTTP%E6%80%BB%E7%BB%93/1-HTTP3.webp" alt="小林Coding"> </p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和String类的compareTo方法</title>
    <link href="/2024/05/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CString%E7%B1%BB%E7%9A%84compareTo%E6%96%B9%E6%B3%95/"/>
    <url>/2024/05/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CString%E7%B1%BB%E7%9A%84compareTo%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>可以将Lambda表达式理解为一个匿名函数； Lambda表达式允许将一个函数作为另外一个函数的参数； 我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码作为实参）,也可以理解为函数式编程，将一个函数作为参数进行传递。</p><ul><li>实例</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>       <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>       thread.<span class="hljs-title function_">start</span>();<br>       thread.<span class="hljs-title function_">close</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使这段代码更加简洁，可以使用匿名内部类重构：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-comment">//这里的 new 了 Runnable() 接口，在这个 new 的接口里面，我们写了这个接口的实现类。</span><br>        <span class="hljs-comment">//这里可以看出，我们把一个重写的 run() 方法传入了一个构造函数中。</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            &#125;<br>        &#125;).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续简化，使用Lambda：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>))</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="String的compareTo-方法"><a href="#String的compareTo-方法" class="headerlink" title="String的compareTo()方法"></a>String的compareTo()方法</h1><ul><li>源码</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> implements java.io.Serializable, Comparable&lt;<span class="hljs-type">String</span>&gt;, CharSequence &#123;<br><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-type">String</span> anotherString)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = value.length;<br>        <span class="hljs-type">int</span> len2 = anotherString.value.length;<br>        <span class="hljs-type">int</span> lim = Math.<span class="hljs-built_in">min</span>(len1, len2);<br>        <span class="hljs-type">char</span> v1[] = value;<br>        <span class="hljs-type">char</span> v2[] = anotherString.value;<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>            <span class="hljs-type">char</span> c1 = v1[k];<br>            <span class="hljs-type">char</span> c2 = v2[k];<br>            <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                <span class="hljs-keyword">return</span> c1 - c2;<br>            &#125;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len1 - len2;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="剑指offer-把数组排成最小的数"><a href="#剑指offer-把数组排成最小的数" class="headerlink" title="剑指offer.把数组排成最小的数"></a>剑指offer.把数组排成最小的数</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。输出格式为字符串。</p><p>样例:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3, 32, 321]</span><br><br>输出：<span class="hljs-number">321323</span><br></code></pre></td></tr></table></figure><ul><li><p>思路：自定义排序规则，<code>nums[i] &lt; nums[j]</code> 当且仅当 <code>nums[i] + nums[j](字符串连接) &lt; nums[j] + nums[i]</code></p></li><li><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">printMinNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-comment">// 将整数数组转换为字符串数组</span><br>        <span class="hljs-type">String</span>[] strNums = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            strNums[i] = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 自定义排序逻辑，按连接后的字符串进行比较</span><br>        Arrays.<span class="hljs-built_in">sort</span>(strNums, (o1, o2) -&gt; (o1 + o2).<span class="hljs-built_in">compareTo</span>(o2 + o1));<br>        <span class="hljs-comment">// 拼接排序后的字符串数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> str : strNums) &#123;<br>            sb.<span class="hljs-built_in">append</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列（没有重复数字）</title>
    <link href="/2024/05/14/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%89/"/>
    <url>/2024/05/14/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/VvJkup/description/">LCR 083. 全排列</a></p></blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个不含重复数字的整数数组 nums ，返回其<strong>所有可能的全排列</strong> 。可以<strong>按任意顺序</strong>返回答案。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数<strong>互不相同</strong></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 全局变量记录答案</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//记录每个排列</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> u)</span> &#123; <span class="hljs-comment">//定义u记录递归深度</span><br>        <span class="hljs-keyword">if</span> (u == nums.length) &#123; <span class="hljs-comment">//到底了就说明生成了一个排列，加入答案List中</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path)); <span class="hljs-comment">//注意不能把path直接加入res中，而是要新建一个对象。否则后续更新path会导致res中的path更改。</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123; <span class="hljs-comment">//遍历nums中的每个值</span><br>            <span class="hljs-keyword">if</span> (!path.contains(i)) &#123; <span class="hljs-comment">//若本次排列中不包含这个值,如i = 3,path = [1, 2, 4]</span><br>                path.add(i); <span class="hljs-comment">//将该值加入排列,path = [1, 2, 4, 3]</span><br>                dfs(nums, u + <span class="hljs-number">1</span>); <span class="hljs-comment">//递归添加排列的下一个位置,即寻找path = [1, 2, 4, 3, _]的空格处应该填入的值</span><br>                path.removeLast(); <span class="hljs-comment">//恢复现场，path = [1, 2, 4, _]</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>$ O(n! * n)$</p></blockquote><p>空间复杂度</p><blockquote><p>$ O(n!)$ </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>equals和==的区别</title>
    <link href="/2024/05/12/Java%E4%B8%ADequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/05/12/Java%E4%B8%ADequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h3><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul><li>int（4Byte）， double（8）， float（4）， long（8）， short（2）， byte（1）， char（2）， boolean（）</li></ul><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ul><li>类， 接口， 数组</li></ul><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和&#x3D;&#x3D;的区别"></a>equals和&#x3D;&#x3D;的区别</h3><h5 id="比较值是否相等"><a href="#比较值是否相等" class="headerlink" title="&#x3D;&#x3D; 比较值是否相等"></a>&#x3D;&#x3D; 比较值是否相等</h5><ul><li>作用于基本数据类型的变量，则直接比较其存储的值是否相等</li><li>作用于引用类型的变量，则比较的是所指向的对象的地址是否相等<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">其实<span class="hljs-operator">=</span><span class="hljs-operator">=</span>比较的不管是基本数据类型，还是引用数据类型的变量，比较的都是值，只是引用类型变量存的值是对象的地址.<br></code></pre></td></tr></table></figure></li></ul><h5 id="equals比较是否是同一个对象"><a href="#equals比较是否是同一个对象" class="headerlink" title="equals比较是否是同一个对象"></a>equals比较是否是同一个对象</h5><ul><li>equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。</li></ul><h5 id="null"><a href="#null" class="headerlink" title="&#x3D;&#x3D; null"></a>&#x3D;&#x3D; null</h5><p>为什么用 <code>== null</code>，而不用 <code>equals(null)</code> ?</p><ul><li><code>obj.equals(null)</code> 如果 <code>obj</code> 也为 <code>null</code> 的话，会抛出空指针异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的子结构</title>
    <link href="/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<ul><li>题目描述</li></ul><p><img src="/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> boolean hasSubtree(TreeNode pRoot1, TreeNode pRoot2) &#123;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">null</span> || pRoot2 == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//遇到空节点直接返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isPart(pRoot1, pRoot2)) &#123; <span class="hljs-comment">//遍历树A的所有非空节点，判断树A中以R为根的子树是否与树B有一样的结构</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasSubtree(pRoot1.left, pRoot2) || hasSubtree(pRoot1.right, pRoot2); <span class="hljs-comment">// 递归遍历A的所有子节点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> boolean isPart(TreeNode p1, TreeNode p2) &#123;<br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//树B遍历到了空，说明当前分支匹配，返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span> || p1.<span class="hljs-keyword">val</span> != p2.<span class="hljs-keyword">val</span>) &#123; <span class="hljs-comment">//树A为空且树B不为空，或者两个节点都不为空但数值不同，均返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isPart(p1.left, p2.left) &amp;&amp; isPart(p1.right, p2.right); <span class="hljs-comment">// 否则说明当前这个点匹配，递归遍历左子树和右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown表格</title>
    <link href="/2024/05/04/MarkDown%E8%A1%A8%E6%A0%BC/"/>
    <url>/2024/05/04/MarkDown%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<ol><li>表格居中<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;style&gt;</span><br>.center <br>&#123;<br>  width: auto;<br>  display: table;<br>  margin-left: auto;<br>  margin-right: auto;<br>&#125;<br><span class="hljs-variable">&lt;/style&gt;</span><br><br><span class="hljs-variable">&lt;div class=&quot;center&quot;&gt;</span><br>|<span class="hljs-string">数组下标 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> 4 </span>|<br>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<br>|<span class="hljs-string"> h </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string"> -1 </span>|<br>|<span class="hljs-string"> e </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 4 </span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string"> 4 </span>||<br>|<span class="hljs-string"> ne </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> -1 </span>||<br><span class="hljs-variable">&lt;/div&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol><ul><li>效果<style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style></li></ul><div class="center"><table><thead><tr><th align="center">数组下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">-1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">e</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">4</td><td align="center"></td></tr><tr><td align="center">ne</td><td align="center">-1</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center"></td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>MarkDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown插入图片</title>
    <link href="/2024/04/27/MarkDown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2024/04/27/MarkDown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<ol><li>本地路径下的图片</li></ol><ul><li><p>本地相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!<span class="hljs-selector-attr">[本地路径]</span>(image.png)         (图片在md文件的同一级)<br>!<span class="hljs-selector-attr">[本地路径]</span>(pic\image.png)     (图片在md文件的下一级)<br>或者：<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.png&quot;</span>&gt;<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;pic\image.png&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>本地绝对路径不建议使用，很多情况加载不出来</p></li></ul><ol start="2"><li>控制图片大小</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">设置图片的宽和高像素值：&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;图片路径&quot;</span> width <span class="hljs-operator">=</span> <span class="hljs-number">300</span> height <span class="hljs-operator">=</span> <span class="hljs-number">200</span>&gt;<br>设置缩放的比例：&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;图片路径&quot;</span> width <span class="hljs-operator">=</span> <span class="hljs-number">60</span>%&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>控制图片位置</li></ol><ul><li>有left、right、center等属性<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;div <span class="hljs-attribute">align</span>=center&gt;  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.png&quot;</span> <span class="hljs-attribute">width</span>=60%&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>MarkDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟一面</title>
    <link href="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/"/>
    <url>/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="菜鸟实习生校招"><a href="#菜鸟实习生校招" class="headerlink" title="菜鸟实习生校招"></a>菜鸟实习生校招</h3><p><strong>首先</strong>：回答问题的时候不要表现得像在背八股文一样，眼睛瞟着一边做出思考的样子，非常像在背八股文。简历上的每一个条目都要弄懂，并且要思考为什么要用这个东西，比如阿里云（用他的优势是什么，为什么不用华为云）。</p><ol><li>自我介绍：老师您好！我叫fred，…..</li><li>项目：三个项目中你觉得最有意思的项目是哪个（意思是你最熟悉哪个），答RPC。</li><li>讲一下RPC</li></ol><ul><li>远程过程调用(Remote Procedure Call)，两个不同的服务器上的服务提供的方法不在同一个内存空间，通过RPC可以帮我们调用某个远程服务器上服务的某个方法，这个过程就像本地调用一样简单，同时我们不需要关注底层网络编程的具体细节。</li><li>RPC原理：①客户端、②客户端stub（代理类）主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端、③网络传输（socket、Netty、Jetty）、④服务端stub（指接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类）、⑤服务端</li><li>本RPC项目的结构：<br><img src="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/image-1.png"></li></ul><ol start="4"><li>Netty是什么</li></ol><ul><li>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</li></ul><ol start="5"><li>Netty相比于其他网络传输优势在哪？</li></ol><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><ol start="6"><li>Netty如何实现长连接，为什么不用短连接要用长连接，心跳包的收发过程。</li></ol><ul><li>减少连接建立和断开的开销: 建立和断开连接都需要消耗资源，包括网络带宽、CPU 时间和内存等。使用长连接可以减少这些开销，因为连接在一段时间内保持打开状态，而不需要频繁地进行建立和断开操作。</li><li>提高性能和效率: 长连接可以减少因连接建立和断开所带来的延迟，从而提高数据传输的效率和性能。特别是对于实时通信、推送服务等应用场景，长连接能够更快地实现消息的实时传输。</li><li>实现长连接的关键在于保持连接的活跃状态，以防止连接由于长时间没有数据传输而被关闭。在实际应用中，通常会采用心跳机制来维持连接的活跃状态。心跳包是定期发送的小型数据包，用于检测连接的状态和保持连接的活跃性。</li></ul><ol start="7"><li>TCP&#x2F;IP三次握手，四次挥手：见小林coding</li><li>序列化是什么，有哪些序列化方式，为什么用kryo，不用其他的</li></ol><ul><li>序列化：把对象转化为可传输的字节序列过程称为序列化。</li><li>序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</li><li>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。</li><li>序列化的方式：JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protobuff、FST（不支持跨语言）</li><li>kryo优势：高性能，序列化后数据量小，速度快，灵活性强，支持自定义序列化器</li><li>基于Json的序列化器缺陷：某个类的属性反序列化时，如果属性声明为Object，就会造成反序列化出错， 会把Object类型反序列化成String类型，并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。</li></ul><ol start="9"><li><p>为什么要把对象序列化成二进制发送，不序列化可以发送吗，一定要序列化成二进制吗<br><img src="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/image2.png"></p></li><li><p>同步阻塞调用</p></li><li><p>git的rebase操作</p></li><li><p>TreadLocal</p></li><li><p>深拷贝和浅拷贝：</p></li></ol><ul><li>浅拷贝创建一个新对象，但新对象内部的元素是对原始对象中元素的引用。也就是说，新对象与原始对象共享子对象或属性（共享同一块内存）。</li><li>深拷贝创建一个新对象，并递归地复制所有子对象或属性。新对象与原始对象完全独立，修改新对象不会影响原始对象。</li></ul><ol start="14"><li><p>无锁队列</p></li><li><p>中序遍历应用场景</p></li><li><p>一个请求从前端到后端的执行流程</p></li><li><p>线程池的参数<br><strong>总结</strong>：先搞清楚简历上的每一个关键词，并延伸，多思考为什么这么做，而不是这个东西的原理，比如使用kryo相比于JSON序列化的优势，之后再补充</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面筋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL从入门到入门</title>
    <link href="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="部署与启动MySQL"><a href="#部署与启动MySQL" class="headerlink" title="部署与启动MySQL"></a>部署与启动MySQL</h1><p><a href="https://blog.csdn.net/qq_45441466/article/details/109670194">阿里云安装MySQL</a></p><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service mysql <span class="hljs-literal">start</span> / service mysqld <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><h3 id="关系型数据库VS非关系型数据库"><a href="#关系型数据库VS非关系型数据库" class="headerlink" title="关系型数据库VS非关系型数据库"></a>关系型数据库VS非关系型数据库</h3><p>关系型：二维表格模型，ACID特性（Atomicity，Consistency，Isolation，    Durability）。有MySQL、Oracle、SQL Server。慢，海量数据读写，扩展性和可用性<br>非关系型：NoSQL，键值对存储，分布式，不保证ACID。有MongoDB、Redis、CouchDB。快，key-value查询，海量数据访问</p><h3 id="MySQL执行流程"><a href="#MySQL执行流程" class="headerlink" title="MySQL执行流程"></a>MySQL执行流程</h3><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.webp" alt="借用小林Coding的图"></p><p><strong>Server层</strong></p><p>1、连接器</p><ul><li>与客户端进行 TCP 三次握手建立连接</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限</li></ul><p>2、查询缓存</p><ul><li>以key-value形式保存，key为SQL语句，value为SQL查询结果</li><li>MySQL 8.0已经删除</li></ul><p>3、解析器</p><ul><li>词法分析：把SQL语句分解成关键词</li><li>语法分析：构建SQL语法树，方便后续模块获取表名、字段名等</li></ul><p>4、执行SQL</p><ul><li>预处理器：检查 SQL 查询语句中的表或者字段是否存在、将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列</li><li>优化器：将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li><li>执行器：与存引擎交互，过程为：<ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul></li></ul><p>5、总结</p><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列；</li><li>优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h3 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h3><p>1、整数类型的UNSIGNED属性，表示不允许负值的无符号整数，可将正整数的上限提高一倍<br>2、字符串类型：CHAR和VARCHAR，CHAR是定长字符串，VARCHAR是变长字符串。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CHAR</span> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 <span class="hljs-number">1</span> 或 <span class="hljs-number">2</span> 个额外字节记录字符串的长度，检索时不需要处理。<br></code></pre></td></tr></table></figure><p>3、定点类型DECIMAL和浮点类型FLOAT&#x2F;DOUBLE: DECIMAL可以存储精确的小数值（货币相关），FLOAT&#x2F;DOUBLE只能存储近似的小数值<br>4、时间类型： </p><ul><li>DATETIME(8字节)：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 </li><li>TIMESTAMP(4字节)：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>1、MySQL存储引擎架构：采用插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。目前MySQL默认使用InnoDB</p><h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>1、索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了B+树作为索引结构。索引存储在文件系统中，占用物理空间。</p><p>2、索引结构优劣对比</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对于树型索引结构，树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。<br></code></pre></td></tr></table></figure><ul><li>Hash：不支持范围查询</li><li>二叉搜索树：极端情况会成为一个链表</li><li>二叉平衡树（AVL）：频繁旋转降低性能、每个树节点存储一个数据，若查询的数据分布在多个节点，会进行多次磁盘IO</li><li>红黑树：平衡性较弱，可能导致树高变高。但插入删除操作仅需O(1)，因此TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。</li><li>B 树：数据分布在整棵树中，检索的过程相当于对范围内的每个节点的关键字做二分查找</li><li>B+ 树：数据只存在于叶子结点，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li></ul><p>3、索引分类</p><p>按功能（逻辑分类）</p><ul><li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL。</li><li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入。</li><li>全文索引：它查找的是文本中的关键词，主要用于全文检索。</li></ul><p>按列数（逻辑分类）</p><ul><li>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</li><li>组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。</li></ul><p>物理分类</p><ul><li>聚簇索引（clustered index）：数据和索引存储在一块，找到了索引就找到了需要的数据，那么这个索引就是聚簇索引。主键索引是聚簇索引。</li><li>二级索引：数据与索引分开存储，索引结构的叶子节点挂的是对应的主键<br><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.png" alt="聚集索引和回表查询"></li></ul><h3 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h3><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p>什么时候适用索引？</p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><p>什么时候不需要创建索引？</p><ul><li>字段中存在大量重复数据时，如性别；</li><li>表数据太少时；</li><li>经常更新的字段不需要创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ul><li>测试数据如下</li></ul><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/1.png" alt="tb_user表"></p><ul><li><p>创建索引 </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_name <span class="hljs-keyword">on</span> tb_user(name)<span class="hljs-punctuation">;</span><span class="hljs-comment">//普通索引</span><br><span class="hljs-keyword">create</span> UNIQUE <span class="hljs-keyword">index</span> idx_user_phone <span class="hljs-keyword">on</span> tb_user(phone)<span class="hljs-punctuation">;</span><span class="hljs-comment">//唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user(profession, age, status)<span class="hljs-punctuation">;</span><span class="hljs-comment">//联合索引</span><br></code></pre></td></tr></table></figure></li><li><p>查看索引 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95.png" alt="查看索引"></p></li><li><p>删除索引 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure></li></ul><h3 id="索引性能分析"><a href="#索引性能分析" class="headerlink" title="索引性能分析"></a>索引性能分析</h3><ul><li>explain<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/explain.png" alt="explain语法"></li></ul><h3 id="最左前缀匹配法则"><a href="#最左前缀匹配法则" class="headerlink" title="最左前缀匹配法则"></a>最左前缀匹配法则</h3><p>使用上面创建的联合索引<code>idx_user_pro_age_sta</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> &quot;软件工程&quot; <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">----或者----</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> profession <span class="hljs-operator">=</span> &quot;软件工程&quot;;<br>查询语句中profession的位置不影响使用索引<br></code></pre></td></tr></table></figure><p>索引会从创建索引时最左边的字段<code>profession</code>开始匹配，若存在就走索引，依次匹配下去，下图就是三个索引均用到了</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="使用全部索引"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&quot;软件工程&quot;</span> and status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>age</code>没有匹配，则<code>status</code>也无法匹配</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/5.png" alt="仅用到profession索引"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age = <span class="hljs-number">31</span> and status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>最左前缀<code>profession</code>没有匹配，此条查询未走索引</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/6.png" alt="未走索引"></p><h3 id="索引失效原则"><a href="#索引失效原则" class="headerlink" title="索引失效原则"></a>索引失效原则</h3><ul><li>使用函数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//查询手机号后两位等于15的user</span><br> <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> <span class="hljs-title">substring</span>(<span class="hljs-params">phone, <span class="hljs-number">10</span>, <span class="hljs-number">2</span></span>)</span> = <span class="hljs-string">&#x27;15&#x27;</span>; <span class="hljs-comment">//phone索引失效</span><br></code></pre></td></tr></table></figure><ul><li><p>字符串未加引号</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone = <span class="hljs-number">17799990015</span>; <span class="hljs-comment">//查询是能查询出来的，但是没走phone的索引</span><br></code></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;软件%&#x27;</span>; <span class="hljs-comment">//尾部模糊匹配，索引不失效</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%工程&#x27;</span>; <span class="hljs-comment">//头部模糊匹配，索引失效</span><br></code></pre></td></tr></table></figure></li><li><p>or 连接的条件</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;10&#x27;</span> or age = <span class="hljs-string">&#x27;30&#x27;</span>; <span class="hljs-comment">//若or前面的条件有索引，后面的条件没有索引，索引失效</span><br></code></pre></td></tr></table></figure><ul><li>数据分布情况</li></ul><p>MySQL视情况决定走不走索引</p><h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user use <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//建议数据库使用该索引</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user ignore <span class="hljs-keyword">index</span>(idx_user_pro_age_sta) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//让数据库忽略该索引</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user force <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//强制数据库使用该索引</span><br></code></pre></td></tr></table></figure><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_email_5 <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>))<span class="hljs-punctuation">;</span><span class="hljs-comment">//数字5代表取email的前五个字符作为前缀索引，节省索引空间，降低建立索引的消耗</span><br></code></pre></td></tr></table></figure><h3 id="覆盖索引和回表查询"><a href="#覆盖索引和回表查询" class="headerlink" title="覆盖索引和回表查询"></a>覆盖索引和回表查询</h3><p>创建一个 phone 和 name 的联合索引，表中目前索引有：</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/7.png" alt="查看索引"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,phone,<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone = <span class="hljs-string">&#x27;17799990010&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;韩信&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/8.png" alt="分析索引执行情况"></p><ul><li><p>回表查询：由于 phone 和 name 均有唯一索引，而当前查询只走了 idx_user_phone 这条索引，故会根据 idx_user_phone 下的 id 值进行回表查询，查询 name </p></li><li><p>覆盖索引：<code>select id,name from tb_user wherename = &#39;韩信&#39;;</code>，idx_user_name 这条索引的叶子结点下挂的就是 id 值， 不需要回表查询，就叫覆盖索引</p></li></ul><h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>通过 long_query_time 参数定义一个SQL耗时多长才被定义为慢查询，默认10s</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>日志格式</p><ul><li>STATEMENT：记录对数据进行修改的SQL语句，如update，insert</li><li>ROW：基于行的日志，记录每一行的数据变更</li><li>MIXED：混合statement和row，默认statement</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java导出word文档--XWPFDocument</title>
    <link href="/2024/04/05/Java%E5%AF%BC%E5%87%BAword%E6%96%87%E6%A1%A3-XWPFDocument/"/>
    <url>/2024/04/05/Java%E5%AF%BC%E5%87%BAword%E6%96%87%E6%A1%A3-XWPFDocument/</url>
    
    <content type="html"><![CDATA[<h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">XWPFDocument document = <span class="hljs-keyword">new</span> <span class="hljs-built_in">XWPFDocument</span>(); <span class="hljs-comment">//创建了一个新的空白 Word 文档</span><br>XWPFParagraph Paragraph = document.<span class="hljs-built_in">createParagraph</span>(); <span class="hljs-comment">//这行代码创建了一个新的段落对象，并将其添加到刚刚创建的 Word 文档中</span><br>Paragraph.<span class="hljs-built_in">setAlignment</span>(ParagraphAlignment.CENTER); <span class="hljs-comment">//设置对齐方式</span><br>XWPFRun run = Paragraph.<span class="hljs-built_in">createRun</span>(); <span class="hljs-comment">//XWPFRun 对象代表 Word 文档中的一个文本运行（run）,可以通过操作这个文本运行对象来设置文本内容、样式、字体等属性。</span><br>run.<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//这里是输入到word的文本</span><br>run.<span class="hljs-built_in">setBold</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置字体加粗</span><br>run.<span class="hljs-built_in">setFontSize</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//设置字体大小（12磅对应小四）</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用数组模拟邻接表</title>
    <link href="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="数组模拟邻接表的难点"><a href="#数组模拟邻接表的难点" class="headerlink" title="数组模拟邻接表的难点"></a>数组模拟邻接表的难点</h2><p>看了一圈博客、ACwing的解释仍然云里雾里，大多数同学都在绞尽脑汁想给大家讲明白每个数组代表什么含义，什么 <strong>e[]</strong> 数组啊，<strong>ne[]</strong> 数组等等。其实差的只是最后一步，就是模拟完add(a, b)建表之后，再带着大家走一遍顺着邻接表读取的过程，瞬间就会豁然开朗，此篇文章适合已经了解了数组模拟邻接表的基本代码和原理但仍然云里雾里的同学。</p><h4 id="一、建表"><a href="#一、建表" class="headerlink" title="一、建表"></a>一、建表</h4><ul><li><p>补充一点初始条件：idx初值为0，h[]数组中的每个值已被初始化为-1，即：h[-1, -1, -1, -1, -1]。你先不管为什么初始化为-1，看到后面就明白了。</p></li><li><p>先贴代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void add(a, b) &#123;<br>    e<span class="hljs-comment">[idx]</span> = b;<br>    ne<span class="hljs-comment">[idx]</span> = h<span class="hljs-comment">[a]</span>;<br>    h<span class="hljs-comment">[a]</span> = idx ++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如下图，请按照add(1, 2)、add(2, 4)、add(1, 3)、add(3, 4)的顺序构建邻接表，现在你不用管那些数组是什么意思，只需要按照add方法往几个数组中更新值就行<br><img src="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/image.png"></p></li><li><p>最后得到和我一样的几个数组就算胜利：</p><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style></li></ul><div class="center"><table><thead><tr><th align="center">数组下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">-1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">e</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">4</td><td align="center"></td></tr><tr><td align="center">ne</td><td align="center">-1</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center"></td></tr></tbody></table></div><ul><li><p>此时idx的值为3</p></li><li><p>再次补充前置知识：初始情况下，邻接表为中元素1后面没有连接任何元素，可以理解为 <strong>1 -&gt; -1</strong>，这里-1代表后面没有元素。<strong>add(1, 2)</strong> 后，即在1后面插入2，就变成 <strong>1 -&gt; 2 -&gt; -1</strong>，<strong>add(1, 3)<strong>后，变成</strong>1 -&gt; 3 -&gt; 2 -&gt; -1</strong>，可以发现add操作是在表头后面插入新元素的，而不是在链表的尾部插入。</p></li></ul><h4 id="二、开始模拟"><a href="#二、开始模拟" class="headerlink" title="二、开始模拟"></a>二、开始模拟</h4><ul><li>只需一遍，你就会明白</li><li>如果我们想获取结点1对应的这个链表，即获取 <strong>1 -&gt; 3 -&gt; 2</strong>，首先找到 <strong>h[1] &#x3D; 2</strong>，那么 <strong>e[2] &#x3D; 3</strong> 就是结点1的在表中的下一个结点，即 <strong>1 -&gt; 3</strong>；接着<strong>ne[2] &#x3D; 0</strong>就代表再下一个结点在<strong>e[0]<strong>处，</strong>e[0] &#x3D; 2</strong>， 即<strong>1 -&gt; 3 -&gt; 2</strong>；接着<strong>ne[0] &#x3D; -1</strong>就代表没有下一个结点了，即<strong>1 -&gt; 3 -&gt; 2 -&gt; -1</strong>，怎么样是不是很简单。</li><li>所以可以总结出：e数组就是存放下一个结点的数组，而ne数组是存放去e数组的哪个位置找结点的数组</li></ul><p><img src="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/image-1.png"></p><ul><li>再看这张图，可以发现，我们调用add()函数建表时就是用idx来给每条边编号的，同时<strong>h</strong>数组中存放的就是每个结点到它的下一个第一个结点的边的编号，例如 <strong>2 -&gt; 4</strong>，查询<strong>h[2] &#x3D; 1</strong>，即为图中对应边的编号。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

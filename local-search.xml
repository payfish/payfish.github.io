<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>docker容器一直重启的解决办法</title>
    <link href="/2024/08/22/docker%E5%AE%B9%E5%99%A8%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2024/08/22/docker%E5%AE%B9%E5%99%A8%E4%B8%80%E7%9B%B4%E9%87%8D%E5%90%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>项目通过docker compose部署上线时，出现了容器疯狂重启的情况，昨天是nacos不断挂掉重启，连带着seata也一直重启，排查发现是内存不足的原因，重新分配内存后得以解决。</p><p>今天seata和Sentinel又开始了，我寻思内存已经够用了啊，nacos都没事了，怎么这两个又出问题了，搜索一番终于解决，记录一下原因和解决方案。</p><h3 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h3><p>使用docker logs seata查看日志，只有一行错误信息：</p><blockquote><p>unable to allocate file descriptor table - out of memorylibrary initialization failed</p></blockquote><h3 id="系统级修改"><a href="#系统级修改" class="headerlink" title="系统级修改"></a>系统级修改</h3><p>错误信息表示系统的文件描述符（file descriptor）限制不足，可能导致服务（如 Seata）无法正常启动或运行。</p><p>使用 <code>ulimit -n</code> 查看当前用户的文件描述符限制，只有1024</p><p>修改系统级别的ulimit参数：<code>vim /etc/security/limits.conf</code> ，设置</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>soft nofile 65536<br><span class="hljs-bullet">* </span>hard nofile 65536<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/pam.d/common-session</code> 和 <code>/etc/pam.d/common-session-noninteractive</code> 文件，添加</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">session <span class="hljs-keyword">required</span> pam_limits.so<br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/sysctl.conf</code> 文件，添加</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">fs.<span class="hljs-keyword">file</span>-<span class="hljs-built_in">max</span> = <span class="hljs-number">65536</span><br></code></pre></td></tr></table></figure><p>重启<code>sudo sysctl -p</code>，并重启系统</p><h3 id="修改docker-compose-yml文件"><a href="#修改docker-compose-yml文件" class="headerlink" title="修改docker-compose.yml文件"></a>修改docker-compose.yml文件</h3><p>为重启的容器添加<code>ulimits:</code>字段限制:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">version: <span class="hljs-string">&#x27;3.8&#x27;</span><br>services:<br>  seata:<br>    image: seata/seata-server<br>    ulimits:<br>      nofile:<br>        hard: <span class="hljs-number">65535</span><br>        soft: <span class="hljs-number">65535</span><br>  sentinel-dashboard:<br>    image: sentinel/sentinel-dashboard<br>    ulimits:<br>      nofile:<br>        hard: <span class="hljs-number">65535</span><br>        soft: <span class="hljs-number">65535</span><br></code></pre></td></tr></table></figure><p>重新启动docker compose，修改成功，容器正常运行</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker compose down<br>docker compose up -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Bugs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker安装最新版redis以及正确配置</title>
    <link href="/2024/08/19/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88redis%E4%BB%A5%E5%8F%8A%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/08/19/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88redis%E4%BB%A5%E5%8F%8A%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>最近docker数据源大量失效，拉不下来镜像不是你的问题，可以自己检索还能用的镜像源</p><blockquote><p>docker pull redis</p></blockquote><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>首先需要手动创建&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf这个文件，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /docker/redis/conf &amp;&amp; touch /docker/redis/conf/redis.conf<br></code></pre></td></tr></table></figure><p>再在&#x2F;docker&#x2F;redis下创建一个data文件夹，用来存放rdb和aof文件</p><h4 id="下载配置文件"><a href="#下载配置文件" class="headerlink" title="下载配置文件"></a>下载配置文件</h4><p>接着去[官网](<a href="https://redis.io/docs/latest/operate/oss_and_stack/management/config/">Redis configuration | Docs</a>)下载redis.conf文件，下载最新版即可（因为我们pull的是最新版）。</p><p>需要修改端口号和保护模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">bind</span> 127.0.0.1 -::1 只允许本地访问，注释掉，改为允许所有端口访问</span><br>bind 0.0.0.0<br><br>protected-mode no #确保 protected-mode 设为 no<br></code></pre></td></tr></table></figure><h4 id="上传配置文件"><a href="#上传配置文件" class="headerlink" title="上传配置文件"></a>上传配置文件</h4><p>将配置文件复制到我们之前创建的<code>/docker/redis/conf/redis.conf</code>中，需要用到vim，可自行学习，下面简单说一下步骤</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>、首先全部复制我们修改好的配置文件<br><span class="hljs-number">2</span>、<span class="hljs-keyword">vim</span> /docker/redis/<span class="hljs-keyword">conf</span>/redis.<span class="hljs-keyword">conf</span><br><span class="hljs-number">3</span>、按i键<br><span class="hljs-number">4</span>、粘贴<br><span class="hljs-number">5</span>、输入:<span class="hljs-keyword">wq</span><br><span class="hljs-number">6</span>、回车<br></code></pre></td></tr></table></figure><h4 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h4><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d \</span><br><span class="language-bash">  --name redis \</span><br><span class="language-bash">  -p 6379:6379 \</span><br><span class="language-bash">  -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf \ <span class="hljs-comment">#配置文件挂载</span></span><br>  -v /docker/redis/data:/data \ <span class="hljs-comment">#数据挂载</span><br>  --restart unless-stopped \<br>  redis:latest \<br>  redis-server /etc/redis/redis.conf --requirepass <span class="hljs-string">&quot;123456&quot;</span><span class="hljs-comment">#使用配置文件启动，设置密码</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker/redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feed流</title>
    <link href="/2024/08/18/Feed%E6%B5%81/"/>
    <url>/2024/08/18/Feed%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是Feed流"><a href="#什么是Feed流" class="headerlink" title="什么是Feed流"></a>什么是Feed流</h3><p>完成了一个需求，展示关注的人发布的博文，这里面就涉及到feed流系统的设计。Feed 流产品在我们手机APP中几乎无处不在，比如微信朋友圈、新浪微博、今日头条等。只要大拇指不停地往下划手机屏幕，就有一条条的信息不断涌现出来。就像给宠物喂食一样，只要它吃光了就要不断再往里加，故此得名Feed（饲养）。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>Feed：Feed流中的每一条消息或者状态都是Feed，比如你微博关注的明星发布的微博，朋友圈朋友发的一篇文章</li><li>Feed流：将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获取最新的订阅源内容</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>TimeLine：基于关注关系并按时间排列，按照Feed流内容更新的时间先后顺序，将内容展示给用户，早期的微博、朋友圈都是典型的timeline。</li><li>Rank：基于算法推荐，按照某些因素计算内容的权重，以决定展示内容的先后顺序</li></ul><h3 id="Feed模式"><a href="#Feed模式" class="headerlink" title="Feed模式"></a>Feed模式</h3><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>推模式：作者发布新的动态时，要推送给其所有的粉丝。</p><p>优点：每次用户想要读取关注作者的文章都可以从自己的收件箱直接读取，读取延时低</p><p>缺点：内存占用高，一个作者的动态要写N份到其粉丝的收件箱中，逻辑复杂，粉丝数多的时候会是灾难</p><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p>拉模型：作者发布动态时只发送到自己的发件箱，用户拉取关注的每个作者的动态，聚合后展示</p><p>优点：拉模型不需要存储额外的数据，逻辑简单</p><p>缺点：每次用户想要读取关注作者的文章，都需要重新拉取，读取延迟较高，关注人数多的时候会出现灾难</p><h4 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h4><ul><li>推只推给活跃粉丝</li><li>僵尸粉只配自己拉</li></ul><h3 id="基于推模式实现Feed流实战"><a href="#基于推模式实现Feed流实战" class="headerlink" title="基于推模式实现Feed流实战"></a>基于推模式实现Feed流实战</h3><p>使用Redis的ZSet作为粉丝的收件箱，使用时间戳对博文排序，Key为博文id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//feed博文id到所有粉丝收件箱</span><br>List&lt;Follow&gt; followUsers = followService.query().eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, user.getId()).list();<br><span class="hljs-keyword">for</span> (Follow follow : followUsers) &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> follow.getUserId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>    stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());<br>&#125;<br></code></pre></td></tr></table></figure><p>粉丝在查询自己的收件箱时可能出现分页问题。Feed流本质上是一个动态列表，列表内容会随着时间不断变化。传统的前端分页参数使用page_size和page_num，分表表示每页几条，以及当前是第几页，对于静态列表没问题，但是对于一个动态列表，可能会出现分页时还有人新发布笔记的情况，如果继续按照数据的角标分页，就会导致重复展示之前页面展示过的数据。</p><p>比如当前列表blogId为（5、4、3、2、1），一页展示三条，第一页就是（5、4、3），此时发布了新的博客（id &#x3D; 6）并推送到了Redis收件箱：（6、5、4、3、2、1），按照角标的话，第二页就会展示（3、2、1），重复查询了id &#x3D; 3 的博客</p><p>所以这里采用上一页的最后一项（比如5、4、3、3、2、1，一页三条的话最后一项就是3）来标记下一页的起始位置，同时指定一个offset（这里有2个3）用来跳过已经在上一页末尾显示过的重复项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 粉丝接收feed流</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> max</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> offset</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;<br>    <span class="hljs-comment">//查询自己的收件箱</span><br>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().<br>            reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (typedTuples == <span class="hljs-literal">null</span> || typedTuples.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">//解析数据：blogId，时间戳, offset</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">offset1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    List&lt;Long&gt; blogIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());<br>    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;<br>        blogIds.add(Long.valueOf(typedTuple.getValue()));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> typedTuple.getScore().longValue();<br>        <span class="hljs-keyword">if</span> (t == minTime) &#123;<br>            offset1 += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            minTime = t;<br>            offset1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//根据blogIds查询对应的blog，添加blog的点赞信息，封装滚动分页查询对象返回</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, blogIds);<br>    List&lt;Blog&gt; blogs = query()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, blogIds)<br>            .last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br>    <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;<br>        updateBlogByUserInfo(blog);<br>        isBlogLiked(blog);<br>    &#125;<br>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">scrollResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();<br>    scrollResult.setList(blogs);<br>    scrollResult.setOffset(offset1);<br>    scrollResult.setMinTime(minTime);<br>    <span class="hljs-keyword">return</span> Result.ok(scrollResult);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Feed流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal内存泄漏</title>
    <link href="/2024/08/15/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2024/08/15/ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserHolder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveUser</span><span class="hljs-params">(UserDTO user)</span>&#123;<br>        tl.set(user);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserDTO <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> tl.get();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeUser</span><span class="hljs-params">()</span>&#123;<br>        tl.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocal实例只有一个，每个线程都会拿到一个自己的ThreadLocalMap，用这个map来存储UserDTO变量，key是ThreadLocal实例，值是变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//set源码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        createMap(t, value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="强引用弱引用"><a href="#强引用弱引用" class="headerlink" title="强引用弱引用"></a>强引用弱引用</h3><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3>]]></content>
    
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx反向代理</title>
    <link href="/2024/08/13/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <url>/2024/08/13/nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h4><p>VPN（Virtual Private Network），代理服务器位于香港等，充当客户端的代理，你对于国外服务器的访问实际上是先到代理服务器，由代理服务器帮你完成请求，并将结果转发给你。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>代理服务端</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h3 id="IP哈希"><a href="#IP哈希" class="headerlink" title="IP哈希"></a>IP哈希</h3><p>session共享问题，一般使用redis实现</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全局唯一ID实现方案探究</title>
    <link href="/2024/08/10/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%8E%A2%E7%A9%B6/"/>
    <url>/2024/08/10/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为什么需要全局唯一ID</p></blockquote><p>单体架构基本都是单库且业务单表的结构，每个业务表的ID几乎都是通过AUTO_INCREMENT 默认从1开始自增。而在分布式系统下分库分表的设计，使得多个库或多个表存储相同的业务数据，这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>Universally Unique Identifier，UUID是由一组32位数的16进制数字所构成，例如<code>59f51e7ea5ca453bbfaf2c1579f09f1d</code></p><p>UUID有很多版本</p><ul><li>基于时间的UUID：通过当前时间，随机数，和本地Mac地址来计算出来</li><li>基于名字的UUID（MD5）：通过计算名字和名字空间的MD5散列值得到</li><li>随机UUID：根据随机数，或者伪随机数生成UUID，JDK自带的UUID工具就是这个版本</li></ul><p>缺点</p><ul><li><strong>不易于存储</strong>：UUID太长，一个16进制数字半个字节，总共16字节128位，以 36 个字符的字符串格式表示（8-4-4-4-12），其中32个字符和4个连字符’ - ‘。</li><li><strong>对MySQL索引不利</strong>：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能</li><li><strong>信息不安全</strong>：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，暴露使用者的位置。</li></ul><h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>分布式数据库本身其实也可以实现全局唯一ID，比如有三个数据库db1、db2、db3。只需为数据库设置相同的递增间距（<code>auto_increment_increment</code>）和不同的起点（<code>auto_increment_offset</code>）即可，如：</p><ul><li>db1: 1&#x2F;4&#x2F;7&#x2F;10</li><li>db2: 2&#x2F;5&#x2F;8&#x2F;11</li><li>db3: 3&#x2F;6&#x2F;9&#x2F;12</li></ul><p>这种方法明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。</p><p>但是缺点也很明显，首先它<strong>强依赖DB</strong>，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是<strong>数据一致性在特殊情况下难以保证</strong>。主从切换时的不一致可能会导致重复发号。其次就是<strong>ID发号性能瓶颈限制在单台MySQL的读写性能</strong>。</p><h3 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h3><p>Redis的INCR命令是原子自增操作，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。</p><p>自定义ID格式64位，首位符号位，后31位时间戳，末32位序列号</p><blockquote><p>&lt;–0–0000 0000 0000 0001 1111 0000 0000 111–0000 0000 0000 0000 1111 1111 0000 1111–&gt;</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIDGenerator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1704067200L</span>; <span class="hljs-comment">//起始时间戳2024/1/1 0:0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowEpochSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeStamp</span> <span class="hljs-operator">=</span> nowEpochSecond - BEGIN_TIMESTAMP;<span class="hljs-comment">//时间戳</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + prefix + date);<br>        <span class="hljs-keyword">return</span> timeStamp &lt;&lt; COUNT_BITS | l;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>increment(&quot;icr:&quot; + prefix + date)</code> 可以实现每天生成一个不同的key，便于按年月日查询当天当月或者当年生成的ID数量，比如 prefix 是 “order”，那么对应的key就是”icr:order2024:08:10”。</p><blockquote><p>redis+lua脚本</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> beginTimestamp = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">local</span> countBits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<br><br><span class="hljs-comment">-- 获取当前时间的秒级时间戳</span><br><span class="hljs-keyword">local</span> now = redis.call(<span class="hljs-string">&#x27;TIME&#x27;</span>)<br><span class="hljs-keyword">local</span> nowEpochSecond = <span class="hljs-built_in">tonumber</span>(now[<span class="hljs-number">1</span>])<br><br><span class="hljs-comment">-- 计算相对时间戳</span><br><span class="hljs-keyword">local</span> timeStamp = nowEpochSecond - beginTimestamp<br><br><span class="hljs-comment">-- 自增并获取自增值</span><br><span class="hljs-keyword">local</span> sequence = redis.call(<span class="hljs-string">&#x27;INCR&#x27;</span>, key)<br><br><span class="hljs-comment">-- 生成唯一ID</span><br><span class="hljs-keyword">local</span> id = (timeStamp &lt;&lt; countBits) | sequence<br><br><span class="hljs-keyword">return</span> id<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIDGenerator</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1704067200L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; script;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        script.setScriptText(loadScript(<span class="hljs-string">&quot;redis_id_generator.lua&quot;</span>));<br>        script.setResultType(Long.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String prefix)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;icr:&quot;</span> + prefix + date;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(script, Collections.singletonList(key), String.valueOf(BEGIN_TIMESTAMP), String.valueOf(COUNT_BITS));<br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ID generation failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">loadScript</span><span class="hljs-params">(String scriptName)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> getClass().getResourceAsStream(<span class="hljs-string">&quot;/&quot;</span> + scriptName);<br>             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream))) &#123;<br>            <span class="hljs-keyword">return</span> reader.lines().collect(Collectors.joining(<span class="hljs-string">&quot;\n&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unable to load Lua script&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo序列化问题与解决记录</title>
    <link href="/2024/08/07/Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/07/Dubbo%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在使用Dubbo调用服务时出现了异常:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Fail <span class="hljs-keyword">to</span> decode request due <span class="hljs-keyword">to</span>: RpcInvocation [<span class="hljs-attribute">methodName</span>=queryItemByIds, <span class="hljs-attribute">parameterTypes</span>=<span class="hljs-literal">null</span>]<br></code></pre></td></tr></table></figure><p>服务提供方也报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">org.apache.dubbo.common.serialize.SerializationException: com.alibaba.fastjson2.JSONException: create instance error interface java.util.Set, offset 7<br></code></pre></td></tr></table></figure><p>调用该服务的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Long, Integer&gt; itemNumMap = detailDTOS.stream()<br>        .collect(Collectors.toMap(OrderDetailDTO::getItemId, OrderDetailDTO::getNum));<br>Set&lt;Long&gt; itemIds = itemNumMap.keySet();<br><span class="hljs-comment">//查询商品</span><br>List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);<br></code></pre></td></tr></table></figure><p>而另一个消费者调用该服务是正常的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());<br><span class="hljs-comment">//查询商品</span><br>List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);<br></code></pre></td></tr></table></figure><p>对比了一下应该是传入参数Set的类型不一致导致的异常，失败的调用传入的参数是keySet，只是Map的一个集合视图，无法被Dubbo序列化和反序列化，修改为HashSet后就可以成功调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Long&gt; itemIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(itemNumMap.keySet());<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2024/08/04/RabbitMQ/"/>
    <url>/2024/08/04/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息队列，提供异步通信，解决同步通信问题</p><h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run \<br> -e RABBITMQ_DEFAULT_USER=fuish \<br> -e RABBITMQ_DEFAULT_PASS=123321 \<br> -v mq-plugins:/plugins \<br> --name mq \<br> --hostname mq \<br> -p 15672:15672 \<br> -p 5672:5672 \<br> --network baima\<br> -d \<br> rabbitmq:3.8-management<br></code></pre></td></tr></table></figure><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机没有存储消息的能力，只是将消息路由到与之绑定的队列中</p><ul><li>fanout：广播消息给所有绑定的队列</li><li>direct：队列和交换机绑定时需指定<code>RoutingKey</code>，消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。绑定的队列只有其<code>Routingkey</code>与消息的 <code>RoutingKey</code>完全一致，才会接收到消息</li><li>topic：允许队列在绑定<code>BindingKey</code> 的时候使用通配符！</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>存储消息，等待消费者监听，消费者监听队列就可以拿到里面的消息</p>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nacos</title>
    <link href="/2024/08/02/nacos/"/>
    <url>/2024/08/02/nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p>数据库：nacos默认的数据库是derby，可以配置MySQL作为nacos的数据库，去<a href="https://github.com/alibaba/nacos/blob/develop/distribution/conf/mysql-schema.sql">官方仓库</a>下载mysql-schema.sql脚本，配置到数据库中</p></li><li><p>环境变量：使用docker部署，只需要将下面的环境变量文件挂载到nacos容器的env-file下，见启动docker命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">PREFER_HOST_MODE=hostname<br>MODE=standalone<br>SPRING_DATASOURCE_PLATFORM=mysql<br>MYSQL_SERVICE_HOST=##MySQL地址##<br>MYSQL_SERVICE_DB_NAME=nacos<br>MYSQL_SERVICE_PORT=3306<br>MYSQL_SERVICE_USER=root<br>MYSQL_SERVICE_PASSWORD=**<br>MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai<br></code></pre></td></tr></table></figure><p>3.docker启动</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d \</span><br><span class="language-bash">--name nacos \</span><br><span class="language-bash">--env-file ./nacos/custom.env \</span><br><span class="language-bash">-p 8848:8848 \</span><br><span class="language-bash">-p 9848:9848 \</span><br><span class="language-bash">-p 9849:9849 \</span><br><span class="language-bash">--restart=always \</span><br><span class="language-bash">nacos/nacos-server:v2.1.0-slim</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--nacos配置管理--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--读取bootstrap文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>设置Bootstrap.yaml文件，这样SpringCloud启动时便可以自动读取Bootstrap文件中的nacos地址，从而去nacos的配置中心拉去各种共享配置，以及实现配置的热更新。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">cart-service</span> <span class="hljs-comment"># 服务名称</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">server-addr:</span> <span class="hljs-string">*ip*:8848</span> <span class="hljs-comment"># nacos地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span><br>        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 共享配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-jdbc.yaml</span> <span class="hljs-comment"># 共享mybatis配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span> <span class="hljs-comment"># 共享日志配置</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-swagger.yaml</span> <span class="hljs-comment"># 共享日志配置</span><br></code></pre></td></tr></table></figure><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><p>业务需要对购物车的最大容量限制做热更新，新增配置文件，<code>@ConfigurationProperties</code> 用于将配置文件中的属性绑定到一个 Java Bean 上。相当于<code>@RefreshScope</code> + <code>@Value</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer maxAmount;<br>&#125;<br></code></pre></td></tr></table></figure><p>在nacos的控制台配置中心中新增cart-service.yaml文件，从而可以通过修改控制台中的属性值实现无需重启服务自动更新maxAmount值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">hm:</span><br>  <span class="hljs-attr">cart:</span><br>    <span class="hljs-attr">maxAmount:</span> <span class="hljs-number">6</span> <span class="hljs-comment"># 购物车商品数量上限</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2024/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2024/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Seata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sentinel服务保护</title>
    <link href="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/"/>
    <url>/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel是一个为微服务提供<strong>流量控制</strong>、<strong>流量整形</strong>、 <strong>并发限制</strong>、<strong>熔断</strong>、<strong>系统自适应过载保护等</strong>多方面保护机制的微服务哨兵。由alibaba开发。</p><p>Netflix还开发过一款Hystrix，当然已经不再维护。</p><h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h3><p>一次请求进入服务后经过的每一个被Sentinel监控的资源链，默认Sentinel会监控SpringMVC的每一个EndPoint（HTTP接口&#x2F;Controller中的方法）。限流熔断都是针对簇点链路中的资源设置的，资源名默认就是Controller中方法的请求路径。</p><p>如：<code>@RequestMapping(&quot;/carts&quot;)</code>，资源名称就是&#x2F;carts，而如今我们的RestFul风格的Controller中，很多路径都是&#x2F;carts，只有操作类型不一样，如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;添加商品到购物车&quot;)</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addItem2Cart</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> CartFormDTO cartFormDTO)</span><br>    <br><span class="hljs-meta">@ApiOperation(&quot;更新购物车数据&quot;)</span><br><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateCart</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Cart cart)</span><br></code></pre></td></tr></table></figure><p>因此需要添加以下配置，使用操作类型名称作为资源名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">http-method-specify:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF.png" alt="簇点链路资源名称"></p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p><strong>TPS</strong>：Transactions Per Second。服务器每秒处理的事务数量。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。在分布式系统中完成一笔事务需要多个系统的配合。比如我们在电商系统购物，需要订单、库存、账户、支付等多个服务配合完成，有的服务需要异步返回，这样完成一笔事务花费的时间可能会很长。如果按照<code>TPS</code>来进行限流，时间粒度可能会很大大，很难准确评估系统的响应性能。</p><p><strong>HPS</strong>：Hits per Second。每秒点击次数，指每秒钟服务端收到客户端的请求数量</p><p><strong>QPS</strong>：Queries Per Second。服务端每秒能够响应的客户端查询请求数量。</p><p>目前多用做流控，设置规则QPS&#x3D;7，即每秒最多7次访问</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E6%B5%81%E6%8E%A7%E8%AE%BE%E7%BD%AE.png" alt="流控设置"></p><p>使用Jmeter测试，效果如下:</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C.png"></p><p>Jmeter中失败的请求返回的响应状态码为429（Too Many Requests），响应数据为：<code>Blocked by Sentinel (flow limiting)</code></p><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源，比如设置为5，同一时间只允许5个并发线程访问</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E8%AE%BE%E7%BD%AE.png"></p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p><h3 id="熔断与降级"><a href="#熔断与降级" class="headerlink" title="熔断与降级"></a>熔断与降级</h3><p><strong>熔断</strong>：当调用失败达到一定的次数，或者慢调用达到一定次数，就将熔断器打开一段时间，这段时间内都不允许消费者向提供者发送请求了。当熔断时间到了，就将熔断器设置为半打开状态，允许消费者发送请求，统计成功次数，若达到指定成功次数，关闭熔断器恢复请求链路，否则打开熔断器</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E7%86%94%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="熔断流程"></p><p><strong>降级</strong>：服务发生熔断后，让请求走事先配置的处理方法，这个方法就是降级逻辑（fallback），服务降级是对非核心服务降级</p><h4 id="dubbo整合sentinel实现熔断降级实战"><a href="#dubbo整合sentinel实现熔断降级实战" class="headerlink" title="dubbo整合sentinel实现熔断降级实战"></a>dubbo整合sentinel实现熔断降级实战</h4><p><strong>背景</strong>：购物车服务cart-service中的查询购物车服务，需要调用商品服务item-service的方法，在之前的章节中我们分别使用了openfeign和dubbo进行了远程调用，这里基于dubbo整合sentinel进行服务熔断测试。</p><p>首先需要导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.csp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在服务提供方item-service的服务实现类中，休眠线程500毫秒，主动模拟慢调用逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@DubboService(interfaceClass = IItemService.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;ItemMapper, Item&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IItemService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span>@SentinelResource注解</span><br>    <span class="hljs-meta">@SentinelResource(value = &quot;queryItemByIds&quot;, fallback = &quot;fallbackQueryItemByIds&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(Collection&lt;Long&gt; ids)</span> &#123;<br>        ThreadUtil.sleep(<span class="hljs-number">500</span>); <span class="hljs-comment">//模拟慢调用</span><br>        <span class="hljs-keyword">return</span> BeanUtils.copyList(listByIds(ids), ItemDTO.class);<br>    &#125;<br><br>    <span class="hljs-comment">//不知道为啥始终走不到这个降级逻辑</span><br>    <span class="hljs-comment">//废话，熔断后根本没有发起dubbo调用，怎么可能到达这里</span><br>    <span class="hljs-keyword">public</span> List&lt;ItemDTO&gt; <span class="hljs-title function_">fallbackQueryItemByIds</span><span class="hljs-params">(Collection&lt;Long&gt; ids, Throwable ex)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;查询商品服务繁忙，请稍后再试&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> CollUtils.emptyList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在购物车服务的启动类下配置了全局fallback处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.hmall.cart.mapper&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-comment">//@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartServiceApplication</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(CartServiceApplication.class, args);<br>        DubboAdapterGlobalConfig.setConsumerFallback((invoker, invocation, e) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;降级了，参数：&#123;&#125;, 服务名：&#123;&#125;, 方法：&#123;&#125;&quot;</span>, invocation.getArguments(),<br>                    invocation.getServiceName(), invocation.getMethodName());<br>            <span class="hljs-keyword">return</span> (Result) AsyncRpcResult.newDefaultAsyncResult(invocation);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前端页面访问一次购物车，可以看到如下簇点链路信息，我们的服务接口IItemService和服务方法均注册成功。</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF2.png" alt="簇点链路"></p><p>为服务方法设置熔断规则，各参数信息如下：</p><ul><li>最大RT：最大请求耗时，超过了就计入慢调用比例</li><li>比例阈值：（0.5）十次调用有五次都是慢的</li><li>熔断时长：熔断器开启的时长，时间结束后进入half-open状态</li><li>最小请求数：最少要发几次请求sentinel才开始统计慢调用、异常比例等等</li><li>统计时长：统计的周期，比如1秒内，请求达到了10次，5次都是慢调用，则开启熔断器</li></ul><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/1.png" alt="熔断参数设置"></p><p>多访问几次查询购物车服务，可以发现时而访问成功，时而失败，sentinel监控面板显示如下信息：</p><p><img src="/2024/07/31/Sentinel%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/%E7%86%94%E6%96%AD%E7%9B%91%E6%8E%A7.png" alt="监控"></p><p>控制台输出fallback逻辑：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">com.hmall.cart.CartServiceApplication    : 降级了，参数：<span class="hljs-string">[[1713453, 5089253]]</span>, 服务名：null, 方法：queryItemByIds<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sentinel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学算法</title>
    <link href="/2024/07/29/%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/07/29/%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="求质数"><a href="#求质数" class="headerlink" title="求质数"></a>求质数</h3><blockquote><p>埃式筛选法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] pi(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-type">int</span> []r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (r[i] == <span class="hljs-number">0</span>) &#123;<br>            r[i] = r[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt;= n; j += i) &#123;<br>                r[j] = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r[i] = r[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<span class="hljs-comment">//O(loglog(n))</span><br></code></pre></td></tr></table></figure><blockquote><p>欧拉筛，线性筛</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">eura</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">boolean</span> []is_prime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>]; <br>    Arrays.fill(is_prime, <span class="hljs-literal">true</span>);<br>    List&lt;Integer&gt; primes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<span class="hljs-comment">//存储质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            primes.add(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : primes) &#123; <span class="hljs-comment">//遍历质数列表</span><br>            <span class="hljs-keyword">if</span> (p * i &gt; n) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//越界</span><br>            is_prime[i * p] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//标记合数</span><br>            <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//只用到小于当前数i的最小因子的质数就退出</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> primes.size();<br>&#125;<span class="hljs-comment">//O(n)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gateway网关</title>
    <link href="/2024/07/25/GateWay%E7%BD%91%E5%85%B3/"/>
    <url>/2024/07/25/GateWay%E7%BD%91%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h3><p>网关-网络的关口，门卫。数据从一个网络传输到另一个网络需要经过网关来做数据的路由和转发，以及数据安全的校验工作。从此以后，前端请求不再直接访问后端服务，而是访问网关（也是一个微服务）。</p><ul><li>路由：选择数据要去的服务的目的地址</li><li>转发：转发数据给对应的服务</li><li>校验：在网关层面进行数据鉴权</li></ul><p><img src="/2024/07/25/GateWay%E7%BD%91%E5%85%B3/%E7%BD%91%E5%85%B3.jpg" alt="网关工作示意图"></p><p>SpringCloud提供了两种网关实现：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><blockquote><p>响应式编程模型，即通过异步和非阻塞的方式处理数据流和事件。</p></blockquote><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--网关--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--负载均衡--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">gateway:</span><br>  <span class="hljs-attr">routes:</span> <span class="hljs-comment">#路由</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item-service</span>  <span class="hljs-comment">#路由唯一标识</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span>  <span class="hljs-comment">#路由目标地址</span><br>      <span class="hljs-attr">predicates:</span> <span class="hljs-comment">#断言，判断请求是否符合当前路由</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cart-service</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cart-service</span><br>      <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/carts/**</span><br>  <span class="hljs-attr">default-filters:</span> <span class="hljs-comment">#过滤器，也可以添加在每一个路由中</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestParameter=red,</span> <span class="hljs-string">blue</span> <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 过滤器执行示意</span><br><span class="hljs-meta">@ApiOperation(&quot;分页查询商品&quot;)</span><br><span class="hljs-meta">@GetMapping(&quot;/page&quot;)</span><br><span class="hljs-keyword">public</span> PageDTO&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByPage</span><span class="hljs-params">(PageQuery query, <span class="hljs-meta">@RequestParam(&quot;red&quot;)</span> String res)</span> &#123;<br>    System.out.println(res); <span class="hljs-comment">//输出blue</span><br></code></pre></td></tr></table></figure><h3 id="JWT校验流程"><a href="#JWT校验流程" class="headerlink" title="JWT校验流程"></a>JWT校验流程</h3><ul><li>用户登录后，用户微服务user-service使用预定义的jwt秘钥为用户生成一个JWT令牌（token），返回给客户端</li><li>用户之后对任何微服务的请求都必须带上这个token，服务端校验token（为空、篡改、过期等），成功后才执行请求的方法，返回数据。</li></ul><h3 id="使用网关进行登录校验"><a href="#使用网关进行登录校验" class="headerlink" title="使用网关进行登录校验"></a>使用网关进行登录校验</h3><p>每个微服务都实现JWT校验逻辑未免太过复杂，而我们的网关正好会对所有的请求路由和转发，在网关层进行JWT校验在合适不过。</p><p>不过，这里存在几个问题：</p><ul><li><p>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</p><blockquote><p>– 网关过滤器</p></blockquote></li><li><p>网关校验JWT之后，如何将用户信息传递给微服务？</p><blockquote><p>– SpringMVC拦截器拦截网关转发的所有http请求，将用户信息保存到ThreadLocal中</p></blockquote></li><li><p>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？ </p><blockquote><p>– OpenFeign请求拦截器，一个微服务在通过Feign调用另一个微服务时，发起http请求之前先从ThreadLocal中拿到userId，将userId作为请求头加入http请求，再发送请求到另一个微服务</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//网关过滤器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequiredArgsConstructor</span><br><span class="hljs-meta">@EnableConfigurationProperties(AuthProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthProperties authProperties;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();<span class="hljs-comment">// Spring 框架提供的路径模式匹配器</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-comment">//1.get request</span><br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        <span class="hljs-comment">//1.1 check request path to see if it needs a login interception</span><br>        <span class="hljs-type">RequestPath</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> request.getPath();<br>        <span class="hljs-keyword">if</span> (pathIsExclude(path)) &#123;<br>            <span class="hljs-keyword">return</span> chain.filter(exchange);<br>        &#125;<br>        <span class="hljs-comment">//2.get token from header</span><br>        <span class="hljs-comment">//3.verify token, check if user has login</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;String&gt; headers = request.getHeaders().get(<span class="hljs-string">&quot;authorization&quot;</span>);<br>        <span class="hljs-keyword">if</span> (headers != <span class="hljs-literal">null</span> &amp;&amp; !headers.isEmpty()) &#123;<br>            token = headers.get(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">//4.do jwt verifying</span><br>        Long userId;<br>        <span class="hljs-keyword">try</span> &#123;<br>            userId = jwtTool.parseToken(token); <span class="hljs-comment">//校验token逻辑</span><br>        &#125; <span class="hljs-keyword">catch</span> (UnauthorizedException e) &#123;<br>            <span class="hljs-comment">//Unauthorized!</span><br>            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();<br>            response.setStatusCode(HttpStatus.UNAUTHORIZED);<br>            <span class="hljs-keyword">return</span> response.setComplete(); <span class="hljs-comment">//return 401</span><br>        &#125;<br>        <span class="hljs-comment">//5.pass userinfo to next filter</span><br>        <span class="hljs-type">ServerWebExchange</span> <span class="hljs-variable">swe</span> <span class="hljs-operator">=</span> exchange.mutate().request(builder -&gt;<br>                builder.header(<span class="hljs-string">&quot;user-id&quot;</span>, userId.toString())).build();<br>        <span class="hljs-keyword">return</span> chain.filter(swe);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断路径是否合法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> path</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">pathIsExclude</span><span class="hljs-params">(RequestPath path)</span> &#123;<br>        List&lt;String&gt; excludePaths = authProperties.getExcludePaths();<br>        <span class="hljs-keyword">for</span> (String pathPatten : excludePaths) &#123;<br>            <span class="hljs-keyword">if</span> (antPathMatcher.match(pathPatten, String.valueOf(path))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义Filter的优先级，需要低于NettyRoutingFilter的优先级Integer.MAX_VALUE</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SpringMVC拦截器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user-id&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(userId)) &#123; <span class="hljs-comment">//有些路径是不需要登录拦截的：/search /users/login /items</span><br>                                        <span class="hljs-comment">//因此不会有user-id这个请求头，所以必须判断非空</span><br>        UserContext.setUser(Long.valueOf(userId));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//放行</span><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    UserContext.removeUser();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//OpenFeign请求拦截器</span><br><span class="hljs-meta">@Bean</span><br>RequestInterceptor <span class="hljs-title function_">feignRequestInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> requestTemplate -&gt; &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserContext.getUser();<br>        <span class="hljs-keyword">if</span> (userId != <span class="hljs-literal">null</span>) &#123;<br>            requestTemplate.header(<span class="hljs-string">&quot;user-id&quot;</span>, userId.toString());<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gateway</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis-Plus</title>
    <link href="/2024/07/22/MyBatisPlus/"/>
    <url>/2024/07/22/MyBatisPlus/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 是一个 <a href="https://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。引入它不会对现有工程产生影响，如丝般顺滑。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><strong><code>@TableName(value = &quot;&quot;, schema = &quot;&quot;....)</code></strong></p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><blockquote><p>除了常见的value属性，还支持如下属性</p></blockquote><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table><p><strong><code>@TableId(value = &quot;id&quot;, type = IdType.AUTO)</code></strong></p><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><blockquote><p> IdType 是枚举类，默认值为ASSIGN_ID，支持的类型如下</p></blockquote><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td align="left">ID_WORKER</td><td align="left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td align="left">UUID</td><td align="left">32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td align="left">ID_WORKER_STR</td><td align="left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p><strong><code>@TableField</code></strong></p><ul><li>描述：普通字段注解</li></ul><blockquote><p>只有特殊情况下我们才需要给字段添加<code>@TableField</code>注解：</p></blockquote><ul><li><p>成员变量名与数据库字段名不一致</p></li><li><p>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符。</p></li><li><p>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符：&#96;&#96;</p><p>如 <code>order</code></p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>和 MyBatis 的配置几乎一样，</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">mybatis-plus:</span><br><span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.hmall.service.domain.po</span><br><span class="hljs-attr">global-config:</span><br><span class="hljs-attr">db-config:</span><br>  <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span> <span class="hljs-comment"># 全局id类型为自增长</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="替代MyBatis"><a href="#替代MyBatis" class="headerlink" title="替代MyBatis"></a>替代MyBatis</h4><blockquote><p>自定义的方法统统不再需要了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;User&gt; &#123;<br><span class="hljs-comment">//    void saveUser(User user);</span><br><span class="hljs-comment">//    void deleteUser(Long id);</span><br><span class="hljs-comment">//    void updateUser(User user);</span><br><span class="hljs-comment">//    User queryUserById(@Param(&quot;id&quot;) Long id);</span><br><span class="hljs-comment">//    List&lt;User&gt; queryUserByIds(@Param(&quot;ids&quot;) List&lt;Long&gt; ids);</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>取而代之的是BaseMapper提供给我们的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">userMapper.insert(user);<br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userMapper.selectById(<span class="hljs-number">5L</span>);<br>List&lt;User&gt; users = userMapper.selectBatchIds(List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">3L</span>, <span class="hljs-number">4L</span>));<br>userMapper.updateById(user);<br>List&lt;User&gt; <span class="hljs-title function_">queryUserByIds</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span>;<br></code></pre></td></tr></table></figure><h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>条件构造器，上面的方法只能基于id进行简单的crud，一些复杂的查询条件我们需要借助这玩意儿来生成。</p><p><img src="/2024/07/22/MyBatisPlus/wrapper%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="wrapper继承结构"></p><p><strong>QueryWrapper</strong>：查询条件构造器，当然也可以用来更新</p><blockquote><p><code>SELECT id,username,info,balance FROM user WHERE (balance &gt;= ? AND username LIKE ?)</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>)<br>            .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>) <span class="hljs-comment">//greater and equals</span><br>            .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>); <span class="hljs-comment">//LIKE &#x27;%值%&#x27;</span><br>    userMapper.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UpdateWrapper</strong>：更新条件构造器</p><blockquote><p><code>UPDATE user SET balance = balance + 1000 WHERE (id IN (?,?,?))</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateWrapper</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    UpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;User&gt;()<br>            .in(<span class="hljs-string">&quot;id&quot;</span>, ids)<br>            .setSql(<span class="hljs-string">&quot;balance = balance + 1000&quot;</span>);<br>    userMapper.update(<span class="hljs-literal">null</span>, wrapper);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LambdaQueryWrapper</strong>：</p><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串<code>魔法值</code>。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？</p><p>其中一种办法是基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的<code>方法引用</code>和<code>Lambda</code>表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper</p><blockquote><p><code>SELECT id,username,info,balance FROM user WHERE (balance &gt;= ? AND username LIKE ?)</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;User&gt;()<br>            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)<br>            .ge(User::getBalance, <span class="hljs-number">1000</span>)<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>);<br>    userMapper.selectList(wrapper).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义SQL</strong>：</p><p>必须用&#96;ew&#96;&#96;，SqlSelect 是自定义的待查询字段，customSqlSegment 是自定义的查询条件</p><blockquote><p><code>UPDATE user set balance = balance + ? WHERE (id IN (?,?,?))</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">listUserByCondition</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>        LambdaQueryWrapper&lt;User&gt; lbWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;User&gt;()<br>                .select(User::getId, User::getUsername, User::getInfo, User::getBalance)<br>                .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>                .in(User::getId, ids);<br>        userMapper.listUserByCondition(<span class="hljs-string">&quot;user&quot;</span>, lbWrapper).forEach(System.out::println);<br>    &#125;<br><span class="hljs-comment">//这里是UserMapper接口中的对应方法</span><br><span class="hljs-meta">@Select(&quot;select $&#123;ew.SqlSelect&#125; from $&#123;tableName&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span><br>List&lt;User&gt; <span class="hljs-title function_">listUserByCondition</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tableName&quot;)</span> String tableName, <span class="hljs-meta">@Param(&quot;ew&quot;)</span> Wrapper wrapper)</span>;<br></code></pre></td></tr></table></figure><p>自定义多表联查</p><blockquote><p>&#96;select u.id,u.username,u.info,u.balance from user u INNER JOIN address a ON u.id &#x3D; a.user_id WHERE (a.city &#x3D; ? AND u.id IN (?,?,?))</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testCustomJoinWrapper</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Long&gt; ids = List.of(<span class="hljs-number">1L</span>, <span class="hljs-number">2L</span>, <span class="hljs-number">4L</span>);<br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .select(<span class="hljs-string">&quot;u.id&quot;</span>, <span class="hljs-string">&quot;u.username&quot;</span>, <span class="hljs-string">&quot;u.info&quot;</span>, <span class="hljs-string">&quot;u.balance&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;a.city&quot;</span>, <span class="hljs-string">&quot;北京&quot;</span>)<br>            .in(<span class="hljs-string">&quot;u.id&quot;</span>, ids);<br>    userMapper.listUserCustomJoin(wrapper).forEach(System.out::println);<br>&#125;<br><span class="hljs-comment">//这里是UserMapper中的对应方法</span><br><span class="hljs-meta">@Select(&quot;select $&#123;ew.SqlSelect&#125; from user u INNER JOIN address a ON u.id = a.user_id   $&#123;ew.customSqlSegment&#125;&quot;)</span><br>List&lt;User&gt; <span class="hljs-title function_">listUserCustomJoin</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;<br><br></code></pre></td></tr></table></figure><h4 id="IServcie"><a href="#IServcie" class="headerlink" title="IServcie"></a>IServcie</h4><p>IServcie接口为我们封装了一系列CRUD操作，当我们自己的Service继承了IServcie，且我们自己Service的实现类继承了ServiceImpl（也就是IServcie的实现类）后，我们可以在Controller中直接调用IServcie提供的方法而不需要编写一句Service代码。当然复杂的除外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;User&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoneyById</span><span class="hljs-params">(Long id, Integer money)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IUserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoneyById</span><span class="hljs-params">(Long id, Integer money)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> getById(id);<br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || user.getStatus() == <span class="hljs-number">2</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;异常&quot;</span>);<br>        <span class="hljs-keyword">if</span> (user.getBalance() &lt; money) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;异常&quot;</span>);<br>        LambdaUpdateWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaUpdateWrapper</span>&lt;User&gt;()<br>                .eq(User::getId, id)<br>                .set(User::getBalance, user.getBalance() - money);<br>          <span class="hljs-comment">//.setSql(&quot;balance = balance - &quot; + money); // 这种方式存在 SQL 注入风险</span><br>       update(<span class="hljs-literal">null</span>, wrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Controller</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController()</span><br><span class="hljs-meta">@RequestMapping(&quot;/users&quot;)</span><br><span class="hljs-meta">@Api(tags = &quot;用户管理接口&quot;)</span><br><span class="hljs-meta">@RequiredArgsConstructor()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IUserService userService;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;新增用户&quot;)</span><br>    <span class="hljs-meta">@PostMapping()</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserFormDTO userFormDTO)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(userFormDTO, User.class);<br>        userService.save(user);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;删除用户&quot;)</span><br>    <span class="hljs-meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteUserById</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户id&quot;)</span> <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        userService.removeById(id);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;根据id查询用户&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> UserVO <span class="hljs-title function_">selectUserById</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户id&quot;)</span> <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(id);<br>        <span class="hljs-keyword">return</span> BeanUtil.copyProperties(user, UserVO.class);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;根据ids查询用户&quot;)</span><br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title function_">byIds</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户id集合&quot;)</span> <span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> List&lt;Long&gt; ids)</span> &#123;<br>        List&lt;User&gt; users = userService.listByIds(ids);<br>        <span class="hljs-keyword">return</span> BeanUtil.copyToList(users, UserVO.class);<br>    &#125;<br><br>    <span class="hljs-meta">@ApiOperation(&quot;根据id扣减余额&quot;)</span><br>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/deduct&#123;money&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductMoneyById</span><span class="hljs-params">(<span class="hljs-meta">@ApiParam(&quot;用户id&quot;)</span> <span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id,</span><br><span class="hljs-params">                                        <span class="hljs-meta">@ApiParam(&quot;扣减金额&quot;)</span> <span class="hljs-meta">@PathVariable(&quot;money&quot;)</span> Integer money)</span> &#123;<br>        userService.deductMoneyById(id, money);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h4><p><code>rewriteBatchedStatements=true</code> 是一个 MySQL 连接参数，用于优化批量插入操作的性能。它的作用是将多条 SQL 语句重写为一条更大、更高效的 SQL 语句，从而减少与数据库服务器之间的通信次数，提高插入操作的速度。</p><h4 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h4><p>顾名思义，删除时只是设置某个字段的值为某特殊值，而不是真正的删除，比如设置 deleted &#x3D; 1，MyBatisplus会自动帮我们在所有SQL语句最后加上对 deleted的判断。如下，删除操作其实是更新操作。</p><p>这样有利也有弊，数据堆积问题，影响查询效率</p><blockquote><p>UPDATE address SET deleted&#x3D;1 WHERE id&#x3D;? AND deleted&#x3D;0</p><p>SELECT id,user_id,province,city,town,mobile,street,contact,deleted FROM address WHERE id&#x3D;? AND deleted&#x3D;0</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//只需为MP加一行配置</span><br><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">global-config:</span><br>    <span class="hljs-attr">db-config:</span><br>      <span class="hljs-attr">logic-delete-field:</span> <span class="hljs-string">deleted</span><br></code></pre></td></tr></table></figure><h4 id="枚举处理器"><a href="#枚举处理器" class="headerlink" title="枚举处理器"></a>枚举处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">UserStatus</span> &#123;<br><br>    NORMAL(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;正常&quot;</span>),<br>    FREEZE(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;冻结&quot;</span>);<br><br>    <span class="hljs-meta">@EnumValue</span> <span class="hljs-comment">//MyBatis Plus 提供的注解，用于指定哪个字段值将被映射到数据库中的相应列。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> status;<br>    <span class="hljs-meta">@JsonValue</span> <span class="hljs-comment">//指定SpringMVC返回给前端的UserVO中的status字段显示的值</span><br>    <span class="hljs-comment">//具体来说，用于指定在将枚举类型序列化为 JSON 时，使用哪个字段值作为枚举的 JSON 表示。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span><br></code></pre></td></tr></table></figure><h4 id="JSON处理器"><a href="#JSON处理器" class="headerlink" title="JSON处理器"></a>JSON处理器</h4><p>我们想把User实体对象中的info字段也改为一个自定义类型存储，之前是String类型，需要引入JSON处理器，帮助我们处理数据库中info字段和User实体类中info字段的转换。</p><blockquote><p><code>autoResultMap</code> 是 MyBatis-Plus 提供的一个功能，用于自动处理结果集的映射，特别是当实体类中包含嵌套对象或自定义类型时。它通过自动生成结果映射（ResultMap）来简化开发过程</p></blockquote><blockquote><p><code>typeHandler</code>：User实体类info字段是UserInfo对象，而数据库info字段是JSON字符串：{“age”: 21, “intro”: “小比崽子”, “gender”: “male”}，查询用户或者新增用户时，JacksonTypeHandler帮助我们反序列化和序列化。</p></blockquote><p>简单来说，你的实体类中还嵌套了另一个自定义类型，User类嵌套了UserInfo类，就需要开启 <code>autoResultMap = true</code>，以及设置 <code>typeHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(value = &quot;user&quot;, autoResultMap = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 详细信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="hljs-keyword">private</span> UserInfo info;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h4 id="listByIds"><a href="#listByIds" class="headerlink" title="listByIds"></a>listByIds</h4><p>此方法使用的SQL语句是 <code>where id in (?, ?, ?)</code>，即使你传入的ids列表是有序的，查出来的结果也可能不按照原本的顺序</p><p>可以使用 <code>ORDER BY FIELD(id, 5, 3, 1)</code> （假设blogIds是（5,3,1））子句，保证查出来的结果集按照ids原有的顺序排序</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">String idStr = StrUtil.<span class="hljs-keyword">join(&quot;,&quot;, </span><span class="hljs-keyword">blogIds);</span><br><span class="hljs-keyword"></span>List&lt;<span class="hljs-keyword">Blog&gt; </span><span class="hljs-keyword">blogs </span>= query()<br>        .in(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-keyword">blogIds)</span><br><span class="hljs-keyword"></span>        .last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis-plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot注解大全</title>
    <link href="/2024/07/21/Springboot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/"/>
    <url>/2024/07/21/Springboot%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>SpringBoot注解让我们摆脱了繁琐的Spring XML配置，让我们的开发更加高效，这里对常见的SpringBoot注解做个总结。</p><h3 id="启动类上"><a href="#启动类上" class="headerlink" title="启动类上"></a>启动类上</h3><p><strong>SpringBootApplication</strong>：申明让spring boot自动给程序进行必要的配置，等同于 <code>@Configuration</code> ，<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code> 三个配置。</p><ul><li><p><strong>Configuration</strong>：用在类上，声明该类是配置类，等同于 Spring 的  XML 文件。</p></li><li><p><strong>EnableAutoConfiguration</strong>：启用 SpringBoot 的自动化配置，会根据你在 <code>pom.xml</code> 添加的依赖和 <code>application-dev.yml</code> 中的配置自动创建你需要的配置。</p></li><li><p><strong>ComponentScan</strong>：启用SpringBoot的组件扫描功能，将自动装配和注入指定包下的Bean实例。</p></li></ul><p><strong>MapperScan</strong>(“mapper接口包路径信息”)：扫描指定包下所有的接口类，然后所有接口在编译之后都会生成相应的实现类，也就是针对Mapper进行一个声明。加上这个注解之后，就不用在每个Mapper接口上使用@Mapper注解。</p><p><strong>EnableFeignClients</strong>：扫描指定包下（如果声明了）的使用了注解<code>@FeignClient</code>定义的Feign客户端。如 :</p><blockquote><p> <code>@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;)</code></p></blockquote><p><strong>EnableCaching</strong>：添加Spring Data Redis依赖之后，可用该注解开启Spring基于注解的缓存管理功能。</p><p><strong>EnableOpenApi</strong> ：Swagger 3.0 的启用注解，添加上这个注解之后就可以使用Swagger3.0的Api文档。</p><p><strong>EnableScheduling</strong> ：开启项目对定时任务的支持，此添加该注解之后，Spring容器会自动扫描被 <code>@Scheduled </code>注解的方法，被 <code>@Scheduled</code> 注解声明的方法为定时任务，在指定的时间进行自动的执行。</p><p><strong>EnableAsync</strong> ：表示项目支持异步方法调用。此添加该注解之后，Spring容器会自动扫描被 <code>@Async</code> 注解的方法或者类，对该方法进行异步操作。即该方法和调用者不在一个线程中进行。</p><p><strong>EnableTransactionManagement</strong> ：开启注解方式的事务管理。添加该注解后，Spring容器会自动扫描被 <code>@Transactional</code> 注解的方法和类。</p><blockquote><p> 所有的数据访问技术都有事务处理机制，这些技术提供了API用来开启事务、提交事务以完成数据操纵，或者在发生错误的时候回滚数据。Spring支持声明式事务，这是基于AOP实现的。</p></blockquote><ul><li><strong>声明式事务</strong>：指的是通过配置或注解的方式，声明哪些方法应该具有事务性，而不需要在业务代码中手动管理事务（例如，不需要显式地调用 <code>beginTransaction()</code>、<code>commit()</code> 或 <code>rollback()</code> 等方法）。</li><li>Spring 使用 AOP 来拦截被 <code>@Transactional</code> 注解的方法，在方法执行前后自动管理事务的开启、提交和回滚。AOP 允许在不修改业务代码的情况下，添加事务管理等横切关注点。</li></ul><h3 id="组件相关"><a href="#组件相关" class="headerlink" title="组件相关"></a>组件相关</h3><p><strong>Component</strong>：用于修饰SpringBoot中的组件，会被组件扫描并生成实例化对象。<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>都是特殊的组件注解。</p><p><strong>Controller</strong> ：用于修饰MVC中 <code>controller</code> 层的组件，SpringBoot中的组件扫描功能会识别到该注解，并为修饰的类实例化对象，通常与 <code>@RequestMapping</code> 联用，当SpringMVC获取到请求时会转发到指定路径的方法进行处理。</p><p><strong>Service</strong>：用于修饰 <code>service</code> 层的组件，<code>service</code> 层组件专注于系统业务逻辑的处理，同样会被组件扫描并生成实例化对象。</p><p><strong>Repository</strong>：用于修饰 <code>dao</code>层的组件，<code>dao </code>层组件专注于系统数据的处理，例如数据库中的数据，同样会被组件扫描并生成实例化对象。</p><p><strong>RestController</strong> ：<code>@Controller</code> 和 <code>@ResponseBody</code> 两个注解的结合体。将类标记为 Spring MVC 控制器，所有的请求处理方法的返回值直接写入 HTTP 响应体中，而不是解析为视图名。</p><blockquote><p><strong>ResponseBody</strong>：表示方法将返回JSON格式的数据，会自动将返回的对象转化为JSON数据。</p></blockquote><p><strong>ConfigurationProperties</strong>：用于配置类上，用来拿配置文件中的属性。例如 <code>@ConfigurationProperties(prefix = &quot;hm.jwt&quot;)</code></p><h3 id="实例相关"><a href="#实例相关" class="headerlink" title="实例相关"></a>实例相关</h3><p><strong>Bean</strong>：用于修饰方法，标识该方法会创建一个Bean实例，并交给Spring容器来管理。</p><h4 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="Component 和 Bean 的区别"></a>Component 和 Bean 的区别</h4><ul><li><p>Component作用在类上，Bean作用在方法上</p></li><li><p>Component注解表明一个类会作为组件类，并告知Spring要为这个类创建bean。</p></li><li><p>Bean注解告诉Spring这个方法将会返回一个对象，这个对象要注册为Spring应用上下文中的bean。通常方法体中包含了最终产生bean实例的逻辑。</p></li><li><p><code>@Bean</code> 必须声明在 <code>@Configuration</code> 注解修饰的类中的方法上 </p></li><li><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方只能通过 <code>@Bean</code> 注解来注册bean。比如当引用第三方库的类需要装配到Spring容器的时候，就只能通过 <code>@Bean</code> 注解来实现。</p></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><strong>Autowired</strong>：会根据对象的<strong>类型</strong>自动注入依赖对象，默认要求注入对象实例必须存在，可以配置 <code>required = false</code> 来注入不一定存在的对象。</p><p><strong>Resource</strong>：默认会根据对象的<strong>名称</strong>自动注入依赖对象，如果想要根据类型进行注入，可以设置 <code>type</code> 属性。</p><h4 id="Resource注入异常记录"><a href="#Resource注入异常记录" class="headerlink" title="@Resource注入异常记录"></a>@Resource注入异常记录</h4><p>一个项目中使用@Resource注入StringRedisTemplate的时候，实例名称写成了redisTemplate，直接报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs @Resource">@Resource<br>private StringRedisTemplate redisTemplate;<br></code></pre></td></tr></table></figure><blockquote><p>Bean named ‘redisTemplate’ is expected to be of type ‘org.springframework.data.redis.core.StringRedisTemplate’ but was actually of type ‘org.springframework.data.redis.core.RedisTemplate’</p></blockquote><p>回头一查才发现早已在这里对比过这两个注解的区别，记录一下加深印象</p><p><strong>Qualifier</strong>：当同一个对象有多个实例可以注入时，使用 <code>@Autowired </code>注解无法进行注入，这时可以使用 <code>@Qualifier</code> 注解指定实例的名称进行精确注入。</p><h3 id="SpringMVC相关"><a href="#SpringMVC相关" class="headerlink" title="SpringMVC相关"></a>SpringMVC相关</h3><p>**PathVariable(“id”)**：处理请求 url 路径中的参数 &#x2F;user&#x2F;5</p><p><strong>RequestParam</strong>：处理问号后面的参数，可以是如下三种形式：</p><ul><li>query param：GET请求拼接在地址里的参数。</li><li>form data：POST表单提交的参数。</li><li>multipart：文件上传请求的部分参数。</li></ul><p><strong>RequestBody</strong>：表示方法的请求参数为JSON格式，从Body中传入，将自动绑定到方法参数对象中。</p><blockquote><p>@Valid注解用于数据验证，可以确保传入对象或返回对象符合预定义的约束规则</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;添加商品到购物车&quot;)</span><br><span class="hljs-meta">@PostMapping</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addItem2Cart</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> CartFormDTO cartFormDTO)</span>&#123;<br>    cartService.addItem2Cart(cartFormDTO);<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@ApiModel(description = &quot;新增购物车商品表单实体&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartFormDTO</span> &#123;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;商品id&quot;)</span><br>    <span class="hljs-keyword">private</span> Long itemId;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;商品标题&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;商品动态属性键值集&quot;)</span><br>    <span class="hljs-keyword">private</span> String spec;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;价格,单位：分&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer price;<br>    <span class="hljs-meta">@ApiModelProperty(&quot;商品图片&quot;)</span><br>    <span class="hljs-keyword">private</span> String image;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ResponseBody</strong>：表示方法将返回JSON格式的数据，会自动将返回的对象转化为JSON数据。</p><p><strong>RequestMapping</strong>：当作用于类上时，可以统一类中所有方法的路由路径，当作用于方法上时，可单独指定方法的路由路径。</p><blockquote><p><code>method</code>属性可以指定请求的方式，如GET、POST、PUT、DELETE等。</p></blockquote><p><strong>PostMapping</strong>：主要用于创建资源。</p><p><strong>PutMapping</strong>：主要用于更新资源。</p><blockquote><p><strong>幂等性</strong>：</p></blockquote><ul><li><code>POST</code> 请求不是幂等的，重复相同的 POST 请求可能会创建多个资源。</li><li><code>PUT</code> 请求是幂等的，重复相同的 PUT 请求不会改变资源的状态。</li><li><code>GET</code> 请求是幂等的，重复相同的 GET 请求不会改变资源的状态。</li></ul><blockquote><p>可以对所有幂等的请求做缓存</p></blockquote><ul><li>通常只对GET请求的响应做缓存，因为PUT和DELETE均涉及到修改操作，缓存其响应没有太大意义</li><li>缓存需要有合适的过期策略，以确保数据的新鲜度。</li><li>当资源更新时，需要确保缓存的数据也及时更新，以避免缓存不一致的问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Annotation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenFeign最佳实践</title>
    <link href="/2024/07/21/OpenFeign%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/07/21/OpenFeign%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Spring Cloud OpenFeign 它是 Spring 官方推出的一种声明式服务调用与负载均衡组件。它底层基于 Netflix Feign，Netflix Feign 是 Netflix 设计的开源的声明式 WebService 客户端，用于简化服务间通信。</p><p>Spring Cloud openfeign 对 Feign 进行了增强，使其支持 <strong>Spring MVC</strong> 注解，另外还整合了 Ribbon 和 Nacos，从而使得 Feign 的使用更加方便。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--openFeign--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--负载均衡器--&gt;</span><br><span class="hljs-comment">&lt;!--此依赖会自动为 Feign 客户端配置一个负载均衡器。你不需要显式配置，Spring Cloud 会在后台处理。--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>我们有两个服务 cart-service 和 item-service，cart 服务需要用到 item 服务的查询方法，那么在原始的 cart 服务中，我们应该通过：<a href="http://localhost:8081/items/ids=10086,10088">http://localhost:8081/items/ids=10086,10088</a> 这种 url 请求 item 服务（通过一堆ids查询items），由于我们把所有服务注册到了 nacos ，现在引入 OpenFeign 基于动态代理帮助我们调用服务。</p><p>使用 OpenFeign 我们只需定义一个接口，而无需主动实现该接口，OpenFeign 会在调用服务时自动通过动态代理的方式创建代理对象进行操作。这里我们使用 SpringMVC 注解来定义请求路径和参数，@FeignClient(“item-service”) 注解声明 Feign 客户端，item-service 是要调用的服务名称。</p><blockquote><p> 注意服务名称不能包含 <code>_</code> 下划线 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(&quot;item-service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/items&quot;)</span><br>    List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，在 cart-service 的启动类上加入 <code>EnableFeignClients</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;)</span> <span class="hljs-comment">//因为将Feign拆分成另一个api模块，需要引入api依赖同时指定包扫描</span><br></code></pre></td></tr></table></figure><p>接着，在 cart -service 的实现类中 注入 Feign 客户端接口，之后就可以愉快地调用 item 服务的方法啦，（其实不是 item 的方法，因为 feign 是帮我们完成了构造 uri ，拉取服务，负载均衡，发送 http 请求的所有工作，相当于对 item-service 发起了一次新的 http 请求调用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ItemClient itemClient;<br>List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);<br></code></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>通过调试来看看OpenFeign在底层到底干了什么，在这句代码前打个断点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);<br></code></pre></td></tr></table></figure><p>发现 OpenFeign 通过动态代理构造了一个代理对象为我们执行方法，进入这个 FeignInvocationHandler，发现 <code>equals/hashCode/toString</code> 不走代理，我们的方法名 <code>queryItemByIds</code> 当然要走代理，继续进入：</p><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试1.png"></p><p>下面这一步是在 <code>invoke</code> 之前构造请求服务的 uri，Feign 通过 <code>RequestTemplate</code> 构建请求模板。</p><p>根据方法上的注解（如 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@RequestParam</code> 等），以及方法参数，填充请求模板中的 URL、请求方法、请求头和请求体。</p><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试2.png"></p><p>这里构造了形如 <code>http://item-service/items?ids=10000</code> 的请求，接下来还需要把 <code>item-service</code> 替换为 <code>nacos</code> 中对应服务名称的 <code>host + port</code>，下面这一步执行两个操作：</p><ul><li><p>构造 <code>Request</code> 对象，包含了最终的 URL、HTTP 方法、请求头和请求体等信息。</p></li><li><p>通过 <code>Client</code> 接口发送请求，<code>Client</code> 接口的实现类有多种（如 <code>Feign.Default</code>、<code>ApacheHttpClient</code>、<code>OkHttpClient</code> 等）。</p></li></ul><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试3.png"></p><p>在<code>Feign</code>的阻塞负载均衡客户端中，通过负载均衡客户端的<code>choose</code> 方法拿到了 <code>nacos</code> 中 <code>item</code> 服务的实例，实例中自然包含其<code>host:port</code>。</p><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试4.png"></p><p>拼接上形成最终 <code>http uri</code>: <code>reconstructedUri</code>，使用新的 URI 构造一个新的 <code>Request</code> 对象。最后通过 <code>LoadBalancerUtils</code> 把 <code>feign</code> 客户端、<code>Request</code> 对象、负载均衡等等一堆鬼东西全部扔进去执行 HTTP 请求。</p><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试7.png"></p><p><img src="D:\Github\payfish.github.io\source_posts\OpenFeign最佳实践\调试6.png"></p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>上面的 <code>delegate</code> 就是<code>feign</code> 客户端，默认是 <code>HttpURLConnection</code> ，不支持HTTP连接池，因此我们通常会使用带有连接池的客户端来代替默认的 <code>HttpURLConnection</code> 。比如 <code>Apache HttpClient</code> 或者 <code>OK Http</code>.</p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--OK http 的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>配置开启okhttp</li></ul><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp功能</span><br></code></pre></td></tr></table></figure><p>重启服务，搞定。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>OpenFeign 主要做了如下工作：</p><ul><li>基于接口和注解构造请求对象（URI)</li><li>去 nacos 寻找服务，得到服务实例（Instance）</li><li>负载均衡</li><li>动态代理生成代理对象处理请求</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2024/07/16/Docker/"/>
    <url>/2024/07/16/Docker/</url>
    
    <content type="html"><![CDATA[<h3 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h3><p><strong>镜像</strong>：镜像不仅包含应用本身，还包含应用运行时所需的环境、配置、系统函数库。因为包含了环境，所以镜像可以运行在各种操作系统上</p><p><strong>容器</strong>：Docker在运行镜像时创建的一个隔离环境（进程），跟其他的进程相互隔离、互不干扰</p><p>镜像你可以把它看成Java中的类，而容器可以看做是类的实例化对象</p><p><img src="/2024/07/16/Docker/docker%E9%83%A8%E7%BD%B2%E9%95%9C%E5%83%8F%E6%B5%81%E7%A8%8B.png" alt="docker部署镜像流程"></p><h3 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d \<br>  --name mysql \<br>  -p 3306:3306 \<br>  -e <span class="hljs-attribute">TZ</span>=Asia/Shanghai \<br>  -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD</span>=****** \<br>  mysql<br></code></pre></td></tr></table></figure><ul><li><code>docker run -d</code> ：创建并运行一个容器，<code>-d</code>则是让容器以后台进程运行</li><li><code>--name`` mysql </code> : 给容器起个名字叫<code>mysql</code>，你可以叫别的</li><li><code>-p 3306:3306</code> : 设置端口映射。<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定，例如MySQL进程默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式： <code>-p 宿主机端口:容器内端口</code>，示例中就是将宿主机的3306映射到容器内的3306端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> : 配置容器内进程运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code>，KEY和VALUE都由容器内进程决定</li><li>案例中，<code>TZ=Asia/Shanghai</code>是设置时区；</li></ul></li><li><code>mysql</code> : 设置<strong>镜像</strong>名称，Docker会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li>docker pull：从镜像仓库拉去镜像到本地</li><li>docker push：将制作好的镜像推送到镜像仓库</li><li>docker images：查看所有的本地镜像</li><li>docker rmi：删除本地镜像</li><li>docker build：通过DOCKERFILE打包制作镜像</li><li>docker save：保存镜像为一个压缩包</li><li>docker load：load压缩包为本地镜像</li><li>docker run：拉取镜像（如果本地没有），创建容器（每次创建一个新容器）</li><li>docker stop：停止容器，（停止容器内部的进程）</li><li>docker start：启动容器（启动停止的容器）</li><li>docker ps：查看容器的运行状态</li><li>docker rm：删除容器</li><li>docker logs：查看容器运行日志</li><li>docker exec：进入容器，执行操作</li><li>docker inspect：查看容器详细信息</li></ul><p><img src="/2024/07/16/Docker/%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4.png" alt="docker常见命令"></p><h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>volume</strong>是一个虚拟目录，是容器内目录和宿主机目录之间映射的桥梁</p><p>docker提供的容器内运行环境只是满足镜像运行的最小环境，使用docker exec命令进入容器后，连vi命令都无法使用，而在外面的宿主机中使用这些命令特别方便。</p><p>建立起数据卷挂载后，docker容器内数据卷目录会和宿主机下对应目录双向绑定，其间的内容同步更新</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>数据持久性：即使容器被删除，数据卷中的数据也不会丢失，可以被其他容器使用。</li><li>数据共享：数据卷可以被多个容器同时挂载，实现容器间的数据共享。这对于需要多个容器共享数据的场景非常有用。</li></ul><p><strong>数据卷有点像 <code>Linux</code> 中的硬链接</strong></p><ul><li><p><strong>硬链接</strong>：在是另外一个位置创建源文件的链接文件，相当于复制了一份，占用资源会倍增。硬链接一旦创建，源文件和链接文件任何一方修改文件都会同步修改。</p></li><li><p><strong>软链接</strong>：指向源文件地址的一个引用，不占用资源</p></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote><p>在执行docker run命令时，使用 <code>-v</code>  <strong>数据卷</strong> <code>:</code> <strong>容器内目录</strong>可以完成数据卷挂载</p></blockquote><ul><li><strong>匿名卷</strong>：只指定容器内的路径，docker会自动在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;下创建一个匿名卷，挂载到指定路径</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d -v /container/path <span class="hljs-keyword">my</span>-image<br></code></pre></td></tr></table></figure><ul><li><strong>命名卷</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">docker volume create my-volume <span class="hljs-comment">//可以手动创建</span><br>docker run -d -v my-volume:/container/path my-image <span class="hljs-comment">//运行容器时使用这个命名卷，若无docker会帮我们创建</span><br></code></pre></td></tr></table></figure><ul><li><strong>绑定挂载</strong>：绑定宿主机的目录到容器目录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//mysql 本地目录挂载实例</span><br>docker run -d \<br>  --name mysql \<br>  -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> \<br>  -e TZ=Asia/Shanghai \<br>  -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123</span> \<br>  -v ./mysql/data:/<span class="hljs-keyword">var</span>/lib/mysql \<br>  -v ./mysql/conf:/etc/mysql/conf.d \<br>  -v ./mysql/init:/docker-entrypoint-initdb.d \<br>  mysql<br></code></pre></td></tr></table></figure><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p><img src="/2024/07/16/Docker/%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84.png" alt="docker镜像结构"></p><h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其常见语法有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><h3 id="docker网络"><a href="#docker网络" class="headerlink" title="docker网络"></a>docker网络</h3><p>docker在安装之初便默认创建了一个网桥bridge，”Gateway”: “172.17.0.1”, “IPAddress”: “172.17.0.2”，运行容器时若不指定网络便会默认桥接进入这个网桥。</p><p>为了使我们的商场项目和MySQL运行在同一网桥下，以便访问，我们可以自定义一个网桥：<code>docker network create baima</code> ，通过 <code>docker network inspect baima</code>查看这个网桥的信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;baima&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ad4d38c784bcf47830bafe984d2a6fb9fff12cd407da65d937d6ce02fabfc4a9&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Created&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2024-07-18T16:08:52.000559732+08:00&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Scope&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bridge&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;EnableIPv6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;IPAM&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Config&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.0/16&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.18.0.1&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过<code>docker network connect baima mysql</code> 将mysql容器加入baima中，也可以在运行容器时通过添加 –network baima 参数，在创建容器时直接将其加入网段中。</p><h3 id="docker部署项目"><a href="#docker部署项目" class="headerlink" title="docker部署项目"></a>docker部署项目</h3><p>想要通过docker部署项目到云服务器上，因为我的后端服务是8080端口，所以要先去安全组开放一下端口。</p><p>接着通过maven将项目打包，自定义DOCKERFILE，一并上传到服务器。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># DOCKERFILE</span><br><span class="hljs-comment"># 基础镜像</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">11.0</span>-jre-buster<br><span class="hljs-comment"># 设定时区</span><br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone</span><br><span class="hljs-comment"># 拷贝jar包</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> hm-service.jar /app.jar</span><br><span class="hljs-comment"># 入口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>通过<code>docker build -t hmall .</code> 打包成镜像</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">[root@fu1sh ~]<span class="hljs-comment"># docker images</span><br>REPOSITORY   <span class="hljs-keyword">TAG</span>               <span class="hljs-title">IMAGE</span> ID       CREATED       SIZE<br>hmall        latest            d3063508f8b0   <span class="hljs-number">3</span> hours ago   <span class="hljs-number">370M</span>B<br>mysql        latest            <span class="hljs-number">3218</span>b38490ce   <span class="hljs-number">2</span> years ago   <span class="hljs-number">516M</span>B<br>openjdk      <span class="hljs-number">11.0</span>-jre-buster   <span class="hljs-number">57925</span>f2e4cff   <span class="hljs-number">2</span> years ago   <span class="hljs-number">301M</span>B<br></code></pre></td></tr></table></figure><p>通过 <code>docker run -d --name hm --network baima -p 8080:8080 hmall</code> 运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@fu1sh ~]# dps<br>CONTAINER ID   IMAGE     PORTS                                                  STATUS       NAMES<br>284a8e00bbfe   hmall     0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp              Up 3 hours   hm<br>5adc956a74df   mysql     0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 4 hours   mysql<br><br></code></pre></td></tr></table></figure><p>运行成功后就可以在浏览器访问我们的项目了。</p><h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><p>集成部署，不用一个一个部署，比如部署完mysql部署后端代码，最后部署nginx，这些统统可以通过docker-compose.yml文件一键部署启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs docker-compose.yml">version: &quot;3.8&quot;<br><br>services:<br>  mysql:<br>    image: mysql<br>    container_name: mysql<br>    ports:<br>      - &quot;3306:3306&quot;<br>    environment:<br>      TZ: Asia/Shanghai<br>      MYSQL_ROOT_PASSWORD: 123<br>    volumes:<br>      - &quot;./mysql/conf:/etc/mysql/conf.d&quot;<br>      - &quot;./mysql/data:/var/lib/mysql&quot;<br>    networks:<br>      - new<br>networks:<br>  new:<br>    name: baima<br></code></pre></td></tr></table></figure><p>这个文件和我们运行镜像的命令几乎一模一样，这里不再赘述。接着通过命令启动即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker compose <span class="hljs-selector-attr">[OPTIONS]</span> <span class="hljs-selector-attr">[COMMAND]</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center"><strong>类型</strong></th><th align="center"><strong>参数或指令</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center"><strong>OPTIONS</strong></td><td align="center">-f</td><td align="center">指定compose文件的路径和名称</td></tr><tr><td align="center"></td><td align="center">-p</td><td align="center">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td></tr><tr><td align="center"><strong>COMMAND</strong></td><td align="center">up</td><td align="center">创建并启动所有service容器</td></tr><tr><td align="center"></td><td align="center">down</td><td align="center">停止并移除所有容器、网络</td></tr><tr><td align="center"></td><td align="center">ps</td><td align="center">列出所有启动的容器</td></tr><tr><td align="center"></td><td align="center">logs</td><td align="center">查看指定容器的日志</td></tr><tr><td align="center"></td><td align="center">stop</td><td align="center">停止容器</td></tr><tr><td align="center"></td><td align="center">start</td><td align="center">启动容器</td></tr><tr><td align="center"></td><td align="center">restart</td><td align="center">重启容器</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拦截器与过滤器</title>
    <link href="/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>拦截器，顾名思义，是一个全局的拦截某些请求的东西，是AOP思想的具体实现，在Spring中Controller方法执行之前和之后都可以看到拦截器的身影。以下是一个web请求的执行流程</p><p><img src="/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%B5%81%E7%A8%8B.png" alt="请求的执行流程"></p><ul><li>浏览器发送请求到Tomcat服务器</li><li>需要静态资源直接去项目目录访问，动态资源才进入后端代码</li><li>经过几个过滤器过滤</li><li>进入中央处理器寻找对应的Controller中的方法</li><li>配置的拦截器会动态拦截控制器（Controller）中方法的执行，在方法执行前后进行操作，如jwt校验鉴权</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><blockquote><p>自定义的拦截器需要实现HandlerInterceptor接口，接口中有三个方法preHandle、postHandle等等，都是默认方法，不必强制实现，所有接口的实现类都会通过继承得到这个方法。源码里默认返回true，意思是直接放行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br>        <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);<br>        System.out.println(request.getHeader(<span class="hljs-string">&quot;host&quot;</span>)); <span class="hljs-comment">// request：请求对象，这里输出localhost:8081</span><br>        System.out.println(handler.getClass()); <span class="hljs-comment">// handler：可以获取方法相关信息，这里输出</span><br>        <span class="hljs-comment">//class org.springframework.web.method.HandlerMethod</span><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> (HandlerMethod) handler;<br>        System.out.println(handlerMethod.getMethod().getName()); <span class="hljs-comment">// 这里输出test</span><br>        response.setStatus(<span class="hljs-number">999</span>); <span class="hljs-comment">//response: 响应对象，在preHandle里可以任意修改</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//如果为false则拦截方法和postHandle和afterCompletion都不执行</span><br>    &#125;<br><br>    <span class="hljs-comment">//原始方法运行后运行，如果原始方法被拦截，则不执行</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);<br>        response.setStatus(<span class="hljs-number">888</span>); <span class="hljs-comment">// 修改失败，因为Controller方法执行结束后响应对象可能已经部分或完全提交</span><br>    &#125;<br><br>    <span class="hljs-comment">//拦截器最后执行的方法，无论原始方法是否执行。用于清理资源</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);<br>        response.setStatus(<span class="hljs-number">777</span>); <span class="hljs-comment">// 修改失败，此时响应已经完成并提交给客户端。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/12/%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8/%E6%8B%A6%E6%88%AA%E5%99%A8%E6%B5%81%E7%A8%8B.png" alt="拦截器方法的执行流程"></p><p>注册拦截器，配置要拦截的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> TestInterceptor interceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;开始注册拦截器&quot;</span>);<br>        registry.addInterceptor(interceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//如果这里还有Interceptor2，配置了多个拦截器形成了拦截器链，那么执行流程是按照配置的顺序先进后出</span><br>        <span class="hljs-comment">//具体来说就是:preHandle1-&gt;preHandle2—&gt;拦截方法-&gt;postHandle2-&gt;posthandle1-&gt;afterCompletion2</span><br>        <span class="hljs-comment">// -&gt;afterCompletion1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>可以通过.order(1)来控制拦截器的执行优先级，数字越小优先级越高</p></blockquote><p>Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/fuish&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Dog dog;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(HttpServletResponse response)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sound</span> <span class="hljs-operator">=</span> dog.bark(<span class="hljs-string">&quot;wof~wof~wof~wof~wof~wof~wof~&quot;</span>);<br>        <span class="hljs-comment">//response.setStatus(200); 当然控制器内也可以随意修改response对象。</span><br>        <span class="hljs-keyword">return</span> sound;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Dog实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span>&#123;<br><br>    <span class="hljs-meta">@Timer</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">bark</span><span class="hljs-params">(String sound)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;方法执行： &quot;</span> + sound);<br>        <span class="hljs-keyword">return</span> sound;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>好了，浏览器输入localhost:8081&#x2F;fuish&#x2F;test，就可以在控制台查收拦截器的执行过程了。（我自己配置的8081端口）</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">preHandle<br>localhost:8081<br>class org.springframework.web.method.HandlerMethod<br>test<br>方法执行： wof~wof~wof~wof~wof~wof~wof~<br>class com.spring.Dog<br>postHandle<br>afterCompletion<br></code></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器，是在java web中将你传入的request、response提前过滤掉一些信息，或者提前设置一些参数。然后再传入Servlet或Struts2的 action进行业务逻辑处理。比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉），或者在传入Servlet或Struts2的action前统一设置字符集，或者去除掉一些非法字符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <br><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span> <span class="hljs-comment">// 配置拦截路径</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">//只会随着服务器的启动初始化一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        Filter.<span class="hljs-built_in">super</span>.init(filterConfig);<br>    &#125;<br><br>    <span class="hljs-comment">//每次请求都会被调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br>        System.out.println(<span class="hljs-string">&quot;过滤器拦截: &quot;</span> + request.getRequestURI());<br>        filterChain.doFilter(servletRequest, servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;要走了也得过滤一道。最终返回的状态码：&quot;</span> + response.getStatus());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        Filter.<span class="hljs-built_in">super</span>.destroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">过滤器拦截: /fuish/test<br>preHandle<br>localhost:8081<br>class org.springframework.web.method.HandlerMethod<br>test<br>方法执行： wof~wof~wof~wof~wof~wof~wof~<br>class com.spring.Dog<br>postHandle<br>afterCompletion<br>要走了也得过滤一道。最终返回的状态码：999<br></code></pre></td></tr></table></figure><blockquote><p>可以发现过滤器的执行顺序同样遵循先进后出，过滤器链也是一样的</p></blockquote><blockquote><p>同样可以通过@Order(1)注解来控制过滤器的执行优先级，数字越小优先级越高</p></blockquote><h2 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h2><p><strong>Filter属于Servlet技术， Interceptor属于SpringMVC技术</strong></p><ul><li>自定义过滤器需要实现 javax.servlet.Filter接口，而这个接口是在Servlet规范中定义的，或者说过滤器需要依赖于Servlet容器，因此它只能在Web程序中使用</li><li>自定义拦截器需要实现org.springframework.web.servlet.HandlerInterceptor接口，存在于SpringMVC中，由Spring容器来管理，不依赖于Servlet容器，是可以单独使用的，因此不仅可以用在Web程序中，也可以用在Application、Swing等程序中</li></ul><p><strong>Filter对所有访问进行增强，Interceptor只对特定请求增强</strong></p><p><strong>Filter基于函数回调， Interceptor基于AOP思想</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interceptor、Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOC与AOP</title>
    <link href="/2024/07/10/AOP/"/>
    <url>/2024/07/10/AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是一种思想，全称叫做Inversion of Control，控制反转，意思是如果有两个对象A依赖于B，把本来A运行时需要主动创建B对象的操作交给IOC容器来帮我们做，创建B对象并注入A，实现了解耦</p><p>IOC也可以叫做DI，Dependency Injection，依赖注入，或者说DI是IOC思想的具体实现方式</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>AOP, (Aspect Orient Programming)，面向切面编程，拦截指定方法并对方法进行增强，不修改源代码的情况下给程序动态添加额外功能</p><ul><li><p><strong>横切关注点（cross-cutting concerns）</strong> ：多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</p></li><li><p>切面（Aspect）：对横切关注点进行封装的类，实现具体的功能。（切面 &#x3D; 切入点 + 通知，通俗点就是在什么时机，什么地方，做什么增强）</p></li><li><p>连接点（JoinPoint）：方法调用或方法执行的某个时刻。（能够被拦截的地方，Spring AOP 是基于动态代理的，所以是方法拦截的，每个成员方法都可以称之为连接点）</p></li><li><p>通知（Advice）：切面在某个连接点要执行的操作，有Before，After，AfterReturning，AfterThrowing，Around。在方法执行的什么时机（<strong>when</strong>：方法前&#x2F;方法后&#x2F;方法前后）做什么（<strong>what</strong>：增强的功能）</p></li><li><p>切点（Pointcut）：一个表达式，用来匹配哪些连接点需要被切面增强。（在哪些类，哪些方法上切入（<strong>where</strong>））</p></li><li><p>织入（weaving）：把切面加入到对象，并创建出代理对象的过程，这个由 Spring 来完成。</p></li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>AOP可以通过动态代理或操作字节码实现</p><p>Spring AOP基于动态代理实现，如果要代理的对象实现了接口，SpringAOP使用 JDK 动态代理创建代理对象，如果没有实现接口，使用Cglib生成一个要代理对象的子类来作为代理对象。</p><h3 id="AOP实例"><a href="#AOP实例" class="headerlink" title="AOP实例"></a>AOP实例</h3><h4 id="公共字段自动填充"><a href="#公共字段自动填充" class="headerlink" title="公共字段自动填充"></a>公共字段自动填充</h4><p>利用AOP实现对数据的一些公共字段如createTime，updateUser等的自动填充功能，无需再手动set</p><p><strong>自定义注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义注解，用于标识某个方法需要进行公共字段的自动填充</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoFill &#123;<br>    <span class="hljs-comment">//数据库操作类型： UPDATE, INSERT</span><br>    OperationType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//枚举定义数据库操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OperationType</span> &#123;<br>    UPDATE,<span class="hljs-comment">//更新操作</span><br>    INSERT<span class="hljs-comment">//插入操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>要被填充的方法</strong></p><p>以DishMapper举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 新增菜品</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dish</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AutoFill(OperationType.INSERT)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Dish dish)</span>;<br></code></pre></td></tr></table></figure><p><strong>切面类</strong></p><p>实现具体的填充功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">//标注这是一个切面类</span><br><span class="hljs-meta">@Component</span> <span class="hljs-comment">//加入Spring容器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoFillAspect</span> &#123;<br><br>    <span class="hljs-comment">//切点</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.sky.mapper.*.*(..)) &amp;&amp; @annotation(com.sky.annotation.AutoFill)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFillPointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">//通知</span><br>    <span class="hljs-meta">@Before(&quot;autoFillPointCut()&quot;)</span><span class="hljs-comment">//方法调用前执行autoFill方法，</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autoFill</span><span class="hljs-params">(JoinPoint joinPoint)</span> &#123; <span class="hljs-comment">// JoinPoint：连接点</span><br>        <span class="hljs-comment">//获取操作类型</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<span class="hljs-comment">//获取方法签名</span><br>        <span class="hljs-type">AutoFill</span> <span class="hljs-variable">autoFill</span> <span class="hljs-operator">=</span> signature.getMethod().getAnnotation(AutoFill.class);<span class="hljs-comment">//方法上的注解对象</span><br>        <span class="hljs-type">OperationType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> autoFill.value();<span class="hljs-comment">//数据库操作类型</span><br><br>        <span class="hljs-comment">//获取切入点方法的参数列表</span><br>        Object[] args = joinPoint.getArgs();<br>        <span class="hljs-keyword">if</span> (args == <span class="hljs-literal">null</span> || args.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 这里就是Dish实体类</span><br><br>        <span class="hljs-comment">//准备赋值的数据</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">currentId</span> <span class="hljs-operator">=</span> BaseContext.getCurrentId();<br><br>        <span class="hljs-comment">//根据操作类型，通过反射为对应的属性赋值</span><br>        <span class="hljs-keyword">if</span> (type == OperationType.INSERT) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreatTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,<br>                        Long.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setCreateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER,<br>                        Long.class);<br><br>                setCreateUser.invoke(entity, currentId);<br>                setUpdateUser.invoke(entity, currentId);<br>                setUpdateTime.invoke(entity, now);<br>                setCreatTime.invoke(entity, now);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == OperationType.UPDATE) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateTime</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME,<br>                        LocalDateTime.class);<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">setUpdateUser</span> <span class="hljs-operator">=</span> entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER,<br>                        Long.class);<br><br>                setUpdateUser.invoke(entity, currentId);<br>                setUpdateTime.invoke(entity, now);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><p>定义日志记录切面记录Controller中方法的运行细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义日志注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Fu1sh</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Logger &#123;<br><br>    String <span class="hljs-title function_">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@ConditionalOnClass(DispatcherServlet.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerAspect</span> &#123;<br><br>    <span class="hljs-comment">//*：匹配任意返回值的方法 </span><br>    <span class="hljs-comment">//com.hmall..controller：匹配包</span><br>    <span class="hljs-comment">//.*.*(..)：匹配包下任意类、任意方法、任意方法参数</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.hmall..controller.*.*(..)) &amp;&amp; @annotation(com.hmall.common.annotation.Logger)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loggerPointCut</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;loggerPointCut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">loggerAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> getRequest();<br>        WebLog webLog;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;================前置通知===============&quot;</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">//执行拦截的方法</span><br>            result = joinPoint.proceed();<br>            log.info(<span class="hljs-string">&quot;================返回通知===============&quot;</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">timeCost</span> <span class="hljs-operator">=</span> TimeUnit.SECONDS.toSeconds(l);<br>            <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> getAnnotationLogger(joinPoint);<br>            webLog = WebLog.builder() <span class="hljs-comment">//WebLog封装了将要展示的日志信息</span><br>                    .description(logger.description())<br>                    .startTime(start)<br>                    .timeCost(timeCost)<br>                    .url(request.getRequestURL().toString())<br>                    .uri(request.getRequestURI())<br>                    .ipAddress(request.getRemoteAddr())<br>                    .params(getParams(joinPoint))<br>                    .result(result)<br>                    .build();<br>            log.info(webLog.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            log.info(<span class="hljs-string">&quot;================异常通知===============&quot;</span>);<br>            log.error(e.getMessage(), e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.info(<span class="hljs-string">&quot;================后置通知===============&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">getParams</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">methodSignature</span> <span class="hljs-operator">=</span> getMethodSignature(joinPoint);<br>        String[] parameterNames = methodSignature.getParameterNames();<br>        Object[] parameterValues = joinPoint.getArgs();<br>        Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterNames.length; i++) &#123;<br>            params.put(parameterNames[i], parameterValues[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> params;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Logger <span class="hljs-title function_">getAnnotationLogger</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-keyword">return</span> getMethodSignature(joinPoint).getMethod().getAnnotation(Logger.class);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodSignature <span class="hljs-title function_">getMethodSignature</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br>        <span class="hljs-keyword">return</span> (MethodSignature) joinPoint.getSignature();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取http请求对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> HttpServletRequest <span class="hljs-title function_">getRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-keyword">return</span> requestAttributes != <span class="hljs-literal">null</span> ? requestAttributes.getRequest() : <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiOperation(&quot;用户登录接口&quot;)</span><br><span class="hljs-meta">@PostMapping(&quot;login&quot;)</span><br><span class="hljs-meta">@Logger(description = &quot;登录&quot;)</span> <span class="hljs-comment">//使用自定义日志注解记录日志信息</span><br><span class="hljs-keyword">public</span> UserLoginVO <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> <span class="hljs-meta">@Validated</span> LoginFormDTO loginFormDTO)</span>&#123;<br>    <span class="hljs-keyword">return</span> userService.login(loginFormDTO);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>RequestContextHolder是Spring 提供的工具类，它使用ThreadLocal存储当前请求的上下文信息，主要用途是从任意位置获取当前 <code>ServletRequest</code> 和其他请求相关的信息，特别是在不直接处理请求的组件（如 <code>@Service</code> 或 <code>@Component</code>）中。</p></blockquote><h3 id="AOP失效场景"><a href="#AOP失效场景" class="headerlink" title="AOP失效场景"></a>AOP失效场景</h3><h4 id="自调用"><a href="#自调用" class="headerlink" title="自调用"></a>自调用</h4><p>AOP 基于代理机制来工作，当一个类的方法在同一个类内部被另一个方法调用时，这种自调用是直接调用的，不会经过代理对象，从而导致切面失效。</p><h4 id="目标类未被-Spring-管理"><a href="#目标类未被-Spring-管理" class="headerlink" title="目标类未被 Spring 管理"></a>目标类未被 Spring 管理</h4><p>AOP 依赖于 Spring 管理的 Bean，如果目标类不是由 Spring 容器管理的 Bean，则切面不会生效。如果一个类通过 <code>new</code> 操作符实例化，而不是通过 Spring 容器注入，那么 AOP 不会生效，因为 Spring 不能为其创建代理对象。</p><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>final修饰的类不能被继承，修饰的方法不能被重写。</p><p><strong>JDK 动态代理</strong>：JDK 动态代理只能代理接口中的方法，而不涉及类的继承，因此 <code>final</code> 类和 <code>final</code> 方法的限制对 JDK 动态代理没有直接影响。但由于 JDK 动态代理只能代理接口方法，所以如果类没有实现接口，Spring 会默认使用 CGLIB 代理。</p><p><strong>CGLIB 代理</strong>：CGLIB 代理通过生成目标类的子类并重写方法来实现代理。如果类或方法是 <code>final</code> 的，CGLIB 代理就无法创建有效的代理对象，因为它无法继承 <code>final</code> 类或重写 <code>final</code> 方法，这会导致 AOP 切面失效。</p><h4 id="private方法同理"><a href="#private方法同理" class="headerlink" title="private方法同理"></a>private方法同理</h4><p>Spring AOP 仅支持公共方法（<code>public</code>）的切面，对于 <code>private</code>、<code>protected</code> 和 <code>package-private</code> 方法，切面不会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 事务逻辑不会生效，因为方法是私有的，无法被重写</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划-递归到记忆化搜索</title>
    <link href="/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    <url>/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="基础DP"><a href="#基础DP" class="headerlink" title="基础DP"></a>基础DP</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。<br>1.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2.<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3.<span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><blockquote><p>递归</p></blockquote><p><code>dfs(i)</code>表示从<code>0</code>爬到第<code>i</code>阶楼梯一共有多少种方法。最后一步可以爬1阶或者2阶，则<code>dfs(i)</code>等于<code>dfs(i - 1)</code> 和<code>dfs(i - 2)</code>之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">return</span> dfs(n);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(i - <span class="hljs-number">1</span>) + dfs(i - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/07/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%80%92%E5%BD%92%E5%88%B0%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/%E7%88%AC%E6%A5%BC%E6%A2%AF.png"></p><p><strong>dfs</strong> 的搜索过程为一颗二叉树，树高为$n$，节点个数为$2^n$，故搜索时间为$O(2^n)$，空间复杂度为$O(n)$，递归需要$O(n)$个栈空间</p><blockquote><p>记忆化搜索</p></blockquote><p>上面的做法会超时，太慢了，可以引入记忆化数组优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i] = dfs(i - <span class="hljs-number">1</span>, memo) + dfs(i - <span class="hljs-number">2</span>, memo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为递归是由上至下展开、由下至上收敛的过程。当递归到最小的问题（<code>i &lt;= 1</code>）时，逐步返回计算结果，并将这些结果存储在 <code>memo</code> 数组中。当递归回到较高层级时，已经计算过的结果保存在 <code>memo</code> 中，可以直接访问，避免重复计算。</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            f[i] = f[i - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以去掉递归中的「递」，只保留「归」的部分，即自底向上计算。具体来说，$f[i]$ 的定义和 $dfs(i)$ 的定义是一样的，都表示从 0 爬到 i 有多少种不同的方法。</p><p>相应的递推式（状态转移方程）也和 $dfs$ 一样：$f[i]&#x3D;f[i−1]+f[i−2]$</p><p>递推方法的核心在于通过自底向上的迭代计算，避免了递归中的重复计算和函数调用开销，达到了高效解决问题的目的。</p><p>当然，转换为三个变量滚动计算这里就不写了</p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><blockquote><p>递归</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, nums);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.max(dfs(i - <span class="hljs-number">1</span>, nums), dfs(i - <span class="hljs-number">2</span>, nums) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>超时，记忆化搜索</p><blockquote><p>记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, nums, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span>[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(i - <span class="hljs-number">1</span>, nums, memo), dfs(i - <span class="hljs-number">2</span>, nums, memo) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>memo</em> 数组的<strong>初始值</strong>一定不能等于要记忆化的值！上一题的方案数不可能为0，故没有初始化数组，但是这道题要记忆化的值是金额可以为0，故要初始化数组为-1</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            f[i + <span class="hljs-number">2</span>] = Math.max(f[i + <span class="hljs-number">1</span>], f[i] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n + <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<span class="hljs-comment">//f下标加2，即可避免越界</span><br><br><span class="hljs-comment">//换成三个变量滚动，节约空间</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(cur, pre + nums[i]);<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a></h3><p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cost = [<span class="hljs-number">1,100,1,1</span>,<span class="hljs-number">1,100,1,1</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：你将从下标为 <span class="hljs-number">0</span> 的台阶开始。<br></code></pre></td></tr></table></figure><blockquote><p>递归+记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []cost; <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cost = cost;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[cost.length + <span class="hljs-number">1</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(cost.length);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> memo[i] = Math.min(dfs(i - <span class="hljs-number">1</span>) + cost[i - <span class="hljs-number">1</span>], dfs(i - <span class="hljs-number">2</span>) + cost[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        f[i + <span class="hljs-number">2</span>] = Math.min(f[i + <span class="hljs-number">1</span>] + cost[i + <span class="hljs-number">1</span>], f[i] + cost[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n];<br>&#125;<br><span class="hljs-comment">//滚动</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minCostClimbingStairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.min(cur + cost[i + <span class="hljs-number">1</span>], pre + cost[i]);<br>        pre = cur;<br>        cur = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">组合总和 Ⅳ</a></h3><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-keyword">target</span> = <span class="hljs-number">4</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>所有可能的组合为：<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br>请注意，顺序不同的序列被视作不同的组合。<br></code></pre></td></tr></table></figure><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(nums, target, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>[] memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[target] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[target];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;   <br>            res += dfs(nums, target - i, memo);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">combinationSum4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> f[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= target; i ++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x &lt;= i) &#123;<br>                f[i] += f[i - x];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[target];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计构造”好”字符串的方案数"><a href="#统计构造”好”字符串的方案数" class="headerlink" title="统计构造”好”字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">统计构造”好”字符串的方案数</a></h3><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countGoodStrings</span><span class="hljs-params">(<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> zero, <span class="hljs-type">int</span> one)</span> &#123;<br>    <span class="hljs-type">int</span> f[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[high + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>, ans = <span class="hljs-number">0</span>;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= high; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= zero) f[i] = (f[i] + f[i - zero]) % mod;<br>        <span class="hljs-keyword">if</span> (i &gt;= one) f[i] = (f[i] + f[i - one]) % mod;<br>        <span class="hljs-keyword">if</span> (i &gt;= low) ans = (ans + f[i]) % mod;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计打字方案数"><a href="#统计打字方案数" class="headerlink" title="统计打字方案数"></a><a href="https://leetcode.cn/problems/count-number-of-texts/">统计打字方案数</a></h3><blockquote><p>分段 dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countTexts</span><span class="hljs-params">(String pressedKeys)</span> &#123;<br>        <span class="hljs-type">int</span> []index = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">//每个号码对应的字符串长度</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//debug半天，res必须为long，不然乘法过程中可能溢出</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, n = pressedKeys.length(); <br>        <span class="hljs-keyword">while</span> (i &lt; n) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; pressedKeys.charAt(i) == pressedKeys.charAt(i + <span class="hljs-number">1</span>)) &#123;<br>                i ++; <br>                len ++; <span class="hljs-comment">//统计每一段相同操作的长度，例如22255中222长度为3</span><br>            &#125;<br>            <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len + <span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> index[pressedKeys.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>];<br>            res = (res * dfs(s, len, memo)) % mod; <span class="hljs-comment">//乘法原理，222和55是独立的，分别统计222和55各自的可能，再相乘即为答案</span><br>            i ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res;<br>    &#125;<br><br>    <span class="hljs-comment">// 常规dfs记忆化搜索</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> len, <span class="hljs-type">int</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[len] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[len];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= s; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (len &gt;= i) &#123;<br>                res = (res + dfs(s, len - i, memo)) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[len] = (<span class="hljs-type">int</span>) res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a><a href="https://leetcode.cn/problems/delete-and-earn/">删除并获得点数</a></h3><p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除 <strong>所有</strong> 等于 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p><p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，接着要删除两个<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>。<br>之后，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数，再次删除<span class="hljs-number"> 3 </span>获得<span class="hljs-number"> 3 </span>个点数。<br>总共获得<span class="hljs-number"> 9 </span>个点数。<br></code></pre></td></tr></table></figure><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//mp.merge(i, 1, Integer::sum);</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">int</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">return</span> dfs(a, n - <span class="hljs-number">1</span>, mp, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []a, <span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; mp, <span class="hljs-type">int</span>[]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] &gt;= a[i] - <span class="hljs-number">1</span>) -- j;<br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(a, i - <span class="hljs-number">1</span>, mp, memo), a[i] * mp.get(a[i]) + dfs(a, j - <span class="hljs-number">1</span>, mp, memo));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个细节：<code>a[j - 1] &gt;= a[i] - 1</code>  和 <code>dfs(a, j - 1, mp, memo)</code> 这里的 j - 1 不能为 j ，否则可能因为 j 未减小导致无限递归。</p><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteAndEarn</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">while</span> (a[j] &lt; a[i] - <span class="hljs-number">1</span>) ++ j;<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i], f[j] + a[i] * mp.get(a[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="施咒的最大总伤害"><a href="#施咒的最大总伤害" class="headerlink" title="施咒的最大总伤害"></a><a href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/">施咒的最大总伤害</a></h3><p>一个魔法师有许多不同的咒语。</p><p>给你一个数组 <code>power</code> ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。</p><p>已知魔法师使用伤害值为 <code>power[i]</code> 的咒语时，他们就 <strong>不能</strong> 使用伤害为 <code>power[i] - 2</code> ，<code>power[i] - 1</code> ，<code>power[i] + 1</code> 或者 <code>power[i] + 2</code> 的咒语。</p><p>每个咒语最多只能被使用 <strong>一次</strong> 。</p><p>请你返回这个魔法师可以达到的伤害值之和的 <strong>最大值</strong> 。</p><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTotalDamage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.put(i, mp.getOrDefault(i, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>); <span class="hljs-comment">// 去重</span><br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);  <span class="hljs-comment">// 排序</span><br>        <span class="hljs-type">long</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-keyword">return</span> dfs(a, n - <span class="hljs-number">1</span>, mp, memo);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []a, <span class="hljs-type">int</span> i, Map&lt;Integer, Integer&gt; mp, <span class="hljs-type">long</span>[]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; <br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; a[j - <span class="hljs-number">1</span>] &gt;= a[i] - <span class="hljs-number">2</span>) -- j;  <span class="hljs-comment">// 找到第一个能使用咒语的位置（第一个小于power[i] - 2的位置）</span><br>        <span class="hljs-keyword">return</span> memo[i] = Math.max(dfs(a, i - <span class="hljs-number">1</span>, mp, memo), (<span class="hljs-type">long</span>) a[i] * mp.get(a[i]) + dfs(a, j - <span class="hljs-number">1</span>, mp, memo));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maximumTotalDamage</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Map&lt;Integer, Integer&gt; mp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            mp.merge(i, <span class="hljs-number">1</span>, Integer::sum);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> mp.size(), k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> []a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : mp.keySet()) &#123;<br>            a[k ++] = x;<br>        &#125;        <br>        Arrays.sort(a);<br>        <span class="hljs-type">long</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">while</span> (a[j] &lt; a[i] - <span class="hljs-number">2</span>) ++ j;<br>            f[i + <span class="hljs-number">1</span>] = Math.max(f[i], f[j] + (<span class="hljs-type">long</span>) a[i] * mp.get(a[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="统计放置房子的方式数"><a href="#统计放置房子的方式数" class="headerlink" title="统计放置房子的方式数"></a><a href="https://leetcode.cn/problems/count-number-of-ways-to-place-houses/">统计放置房子的方式数</a></h3><blockquote><p>dfs + 记忆化搜索</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">long</span> []memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(n, memo);<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod * res % mod) % mod;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span> <span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">long</span> []memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> memo[i] = (dfs(i - <span class="hljs-number">1</span>, memo) + dfs(i - <span class="hljs-number">2</span>, memo)) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">long</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        f[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; ++ i) &#123;<br>            f[i] = (f[i - <span class="hljs-number">1</span>]  + f[i - <span class="hljs-number">2</span>]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (f[n] % mod * f[n] % mod) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优化空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countHousePlacements</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, cur = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (pre + cur) % mod;<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (cur % mod * cur % mod) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>, n - <span class="hljs-number">2</span>), dfs(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)); <span class="hljs-comment">//考虑第1间和不考虑第一间</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i];<br>        <span class="hljs-keyword">return</span> Math.max(dfs(nums, k, i - <span class="hljs-number">1</span>), dfs(nums, k, i - <span class="hljs-number">2</span>) + nums[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推（按照上面一比一翻译）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>), dfs(nums, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">2</span>];<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; n; i ++) &#123;<br>            f[i + <span class="hljs-number">2</span>] = Math.max(f[i + <span class="hljs-number">1</span>], f[i] + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - start + <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">0</span>] + dfs(nums, <span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>), dfs(nums, <span class="hljs-number">1</span>, n));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, cur = pre;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i ++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Math.max(nums[i] + pre, cur);<br>            pre = cur;<br>            cur = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><blockquote><p>动态规划，空间优化版</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        pre = Math.max(pre, <span class="hljs-number">0</span>) + nums[i];<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀和：从前往后遍历过程中维护一个最小的前缀和值，用当前前缀和减去最小前缀和即为可能答案</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        sum += nums[i];<br>        res = Math.max(sum - mi, res);<br>        mi = Math.min(sum, mi);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="找到最大开销的子字符串"><a href="#找到最大开销的子字符串" class="headerlink" title="找到最大开销的子字符串"></a><a href="https://leetcode.cn/problems/find-the-substring-with-maximum-cost/">找到最大开销的子字符串</a></h3><blockquote><p>先映射，确定字符串s中每一个字符的cost，接下来就是最大子数组和的做法了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumCostSubstring</span><span class="hljs-params">(String s, String chars, <span class="hljs-type">int</span>[] vals)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">int</span> []mapping = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++ i) &#123;<br>        mapping[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; vals.length; ++ i) &#123;<br>        mapping[chars.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = vals[i];<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;<br>        pre = Math.max(pre, <span class="hljs-number">0</span>) + mapping[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任意子数组和的绝对值的最大值"><a href="#任意子数组和的绝对值的最大值" class="headerlink" title="任意子数组和的绝对值的最大值"></a><a href="https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/">任意子数组和的绝对值的最大值</a></h3><p>请你找出 <code>nums</code> 中 <strong>和的绝对值</strong> 最大的任意子数组（<strong>可能为空</strong>），并返回该 <strong>最大值</strong> 。</p><blockquote><p>多维护一个任意子数组的最小值变量mm</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxAbsoluteSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, n = nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        mx = Math.max(mx, <span class="hljs-number">0</span>) + nums[i];<br>        mm = Math.min(mm, <span class="hljs-number">0</span>) + nums[i];<br>        res = Math.max(Math.max(mx, - mm), res);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-次串联后最大子数组之和"><a href="#K-次串联后最大子数组之和" class="headerlink" title="K 次串联后最大子数组之和"></a><a href="https://leetcode.cn/problems/k-concatenation-maximum-sum/">K 次串联后最大子数组之和</a></h3><p>给定一个整数数组 <code>arr</code> 和一个整数 <code>k</code> ，通过重复 <code>k</code> 次来修改数组。</p><p>例如，如果 <code>arr = [1, 2]</code> ， <code>k = 3</code> ，那么修改后的数组将是 <code>[1, 2, 1, 2, 1, 2]</code> 。</p><p>返回修改后的数组中的最大的子数组之和。注意，子数组长度可以是 <code>0</code>，在这种情况下它的总和也是 <code>0</code>。</p><p>由于 <strong>结果可能会很大</strong>，需要返回的 <code>109 + 7</code> 的 <strong>模</strong> 。</p><blockquote><p>别被一个小小的变形吓跑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kConcatenationMaxSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) sum += i;<br>    res = kadane(arr, <span class="hljs-number">1</span>); <span class="hljs-comment">// k = 1,直接返回答案</span><br>    <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">1</span>) &#123;<br>        res = kadane(arr, <span class="hljs-number">2</span>); <span class="hljs-comment">// sum &lt;= 0,串联两次res最大</span><br>        <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//只有数组和大于0，串联k次才会使res增大，否则就是串联两次的最大子数组和最大</span><br>            res += (<span class="hljs-type">long</span>) sum * (k - <span class="hljs-number">2</span>) % mod; <span class="hljs-comment">//最大子数组和就是在串联两次的数组中间插入k-2个arr</span><br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res % mod;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kadane</span><span class="hljs-params">(<span class="hljs-type">int</span> []arr, <span class="hljs-type">int</span> k)</span> &#123; <span class="hljs-comment">//用来计算重复一次或者两次的最大子数组和</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n * k; i ++) &#123;<br>        pre = (Math.max(pre, <span class="hljs-number">0</span>) + arr[i % n]);<br>        res = Math.max(res, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">环形子数组的最大和</a></h3><p>给定一个长度为 <code>n</code> 的<strong>环形整数数组</strong> <code>nums</code> ，返回 <em><code>nums</code> 的非空 <strong>子数组</strong> 的最大可能和</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br></code></pre></td></tr></table></figure><blockquote><p>思路：同时维护最小子数组和mi，与最大子数组和mx，以及数组总和sum，sum - mi就是跨过边界的子数组最大和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, pmx = <span class="hljs-number">0</span>, pmi = <span class="hljs-number">0</span>, mx = Integer.MIN_VALUE, mi = Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        sum += nums[i];<br>        pmx = Math.max(pmx, <span class="hljs-number">0</span>) + nums[i];<br>        pmi = Math.min(pmi, <span class="hljs-number">0</span>) + nums[i];<br>        mi = Math.min(mi, pmi);<br>        mx = Math.max(mx, pmx);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mi == sum) <span class="hljs-keyword">return</span> mx; <span class="hljs-comment">//特殊情况数组全部元素为负，返回mx代表数组中最大的一个负数</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Math.max(mx, sum - mi);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拼接数组的最大分数"><a href="#拼接数组的最大分数" class="headerlink" title="拼接数组的最大分数"></a><a href="https://leetcode.cn/problems/maximum-score-of-spliced-array/">拼接数组的最大分数</a></h3><blockquote><p>就是求两个数组的差集数组<code>nums2 - nums1</code>的最大子数组和，再加上<code>nums1</code>的和；对于<code>nums2</code>再来一次该操作，最后返回二者最大的即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumsSplicedArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums1.length, sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> nums1[i], t2 = nums2[i];<br>        sum1 += t1;<br>        sum2 += t2;<br>        nums2[i] = t2 - t1;<br>        nums1[i] = t1 - t2;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mx1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res1 = <span class="hljs-number">0</span>, mx2 = <span class="hljs-number">0</span>, res2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;<br>        mx1 = Math.max(mx1 + i, <span class="hljs-number">0</span>) ;<br>        res1 = Math.max(res1, mx1);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums2) &#123;<br>        mx2 = Math.max(mx2 + i, <span class="hljs-number">0</span>);<br>        res2 = Math.max(res2, mx2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.max(sum2 + res1, sum1 + res2);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>封装成函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumsSplicedArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>    <span class="hljs-keyword">return</span> Math.max(kadane(nums1, nums2), kadane(nums2, nums1));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kadane</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums1, <span class="hljs-type">int</span> []nums2)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums1.length; ++ i) &#123;<br>        sum += nums1[i];<br>        mx = Math.max(mx + nums2[i] - nums1[i], <span class="hljs-number">0</span>) ;<br>        res = Math.max(res, mx);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res + sum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [2,3,-2,4]</span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br></code></pre></td></tr></table></figure><blockquote><p>思路就是维护一个乘积的最大值 <code>mx</code> 一个最小值 <code>mi</code>，每次遇到负数就交换最大最小值，遇到0就把 <code>mx</code> 和 <code>mi</code> 置为1，计算下一段</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProduct</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, mi = <span class="hljs-number">1</span>, mx = <span class="hljs-number">1</span>, res = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            mx = <span class="hljs-number">1</span>;<br>            mi = <span class="hljs-number">1</span>;<br>            res = Math.max(res, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> mx;<br>            mx = Math.max(i * mi, i);<br>            mi = Math.min(i * t, i);<br>            res = Math.max(res, mx);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mx = Math.max(i * mx, i);<br>            mi = Math.min(i * mi, i);<br>            res = Math.max(res, mx);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网格图DP"><a href="#网格图DP" class="headerlink" title="网格图DP"></a>网格图DP</h2><h3 id="珠宝的最高价值"><a href="#珠宝的最高价值" class="headerlink" title="珠宝的最高价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">珠宝的最高价值</a></h3><p>现有一个记作二维矩阵 <code>frame</code> 的珠宝架，其中 <code>frame[i][j]</code> 为该位置珠宝的价值。拿取珠宝的规则为：</p><ul><li>只能从架子的左上角开始拿珠宝</li><li>每次可以移动到右侧或下侧的相邻位置</li><li>到达珠宝架子的右下角时，停止拿取</li></ul><blockquote><p>dfs + 记忆化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][] frame;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>        <span class="hljs-built_in">this</span>.frame = frame;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y]; <span class="hljs-comment">// 用 &gt; 0判断也行</span><br>        <span class="hljs-keyword">return</span> memo[x][y] = Math.max(dfs(x - <span class="hljs-number">1</span>, y), dfs(x, y - <span class="hljs-number">1</span>)) + frame[x][y];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.max(f[i][j + <span class="hljs-number">1</span>], f[i + <span class="hljs-number">1</span>][j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[n][m];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>] = Math.max(f[i % <span class="hljs-number">2</span>][j + <span class="hljs-number">1</span>], f[(i + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>][j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[n % <span class="hljs-number">2</span>][m];<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jewelleryValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] frame)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> frame.length, m = frame[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>            f[j + <span class="hljs-number">1</span>] = Math.max(f[j + <span class="hljs-number">1</span>], f[j]) + frame[i][j];<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> f[m];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, memo);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (memo[m][n] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[m][n];<br>    <span class="hljs-keyword">return</span> memo[m][n] = dfs(m - <span class="hljs-number">1</span>, n, memo) + dfs(m, n - <span class="hljs-number">1</span>, memo);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(f, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>            f[j] += f[j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]obstacleGrid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.obstacleGrid = obstacleGrid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; obstacleGrid[x][y] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[x][y] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-keyword">return</span> memo[x][y] = dfs(x - <span class="hljs-number">1</span>, y, memo) + dfs(x, y - <span class="hljs-number">1</span>, memo);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] != <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) dp[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    dp[<span class="hljs-number">0</span>] = obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;<br>                dp[j] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><p>给定一个包含非负整数的 <code>*m* x *n*</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><blockquote><p>原地修改</p></blockquote><table><thead><tr><th align="center">1</th><th align="center">3</th><th align="center">1</th><th align="center"></th><th align="center">1</th><th align="center">4</th><th align="center">5</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>5</strong></td><td align="center"><strong>1</strong></td><td align="center">修改后–&gt;</td><td align="center"><strong>2</strong></td><td align="center"><strong>7</strong></td><td align="center"><strong>6</strong></td></tr><tr><td align="center"><strong>4</strong></td><td align="center"><strong>2</strong></td><td align="center"><strong>1</strong></td><td align="center"></td><td align="center"><strong>6</strong></td><td align="center"><strong>8</strong></td><td align="center"><strong>7</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) grid[j][<span class="hljs-number">0</span>] += grid[j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> grid[j][i] = Math.min(grid[j][i - <span class="hljs-number">1</span>], grid[j - <span class="hljs-number">1</span>][i]) + grid[j][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/">三角形最小路径和</a></h3><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; triangle;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>        <span class="hljs-built_in">this</span>.triangle = triangle;<br>        <span class="hljs-built_in">this</span>.n = triangle.size();<br>        <span class="hljs-built_in">this</span>.memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;    <br>        <span class="hljs-keyword">if</span> (r == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[r][c] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[r][c];<br>        <span class="hljs-keyword">return</span> memo[r][c] = Math.min(dfs(r + <span class="hljs-number">1</span>, c), dfs(r + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span>)) + triangle.get(r).get(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : dp) Arrays.fill(a, Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; ++ j) &#123;<br>            dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.min(dp[i][j + <span class="hljs-number">1</span>], dp[i][j]) + triangle.get(i).get(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-comment">// System.out.print(dp[n][i]);</span><br>        <span class="hljs-keyword">if</span> (dp[n][i + <span class="hljs-number">1</span>] &lt; res) res = dp[n][i + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自顶向下</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    Arrays.fill(dp, Integer.MAX_VALUE);<br>    dp[<span class="hljs-number">0</span>] = triangle.get(<span class="hljs-number">0</span>).get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] += triangle.get(i).get(j); <br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (dp[i] &lt; res) res = dp[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自底向上</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimumTotal</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> triangle.size();<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>    <span class="hljs-comment">// Initialize dp array with the last row of the triangle</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        dp[i] = triangle.get(n - <span class="hljs-number">1</span>).get(i);<br>    &#125;<br>    <span class="hljs-comment">// Start from the second last row and move upwards</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            dp[j] = Math.min(dp[j], dp[j + <span class="hljs-number">1</span>]) + triangle.get(i).get(j);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// The top element of dp array will have the minimum total</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum/">下降路径最小和</a></h3><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length, m = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(n - <span class="hljs-number">1</span>, i, matrix, memo);<br>            <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]matrix, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">0</span> || y &gt;= matrix[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-keyword">return</span> memo[x][y] = Math.min(Math.min(dfs(x-<span class="hljs-number">1</span>, y, matrix, memo), dfs(x-<span class="hljs-number">1</span>, y-<span class="hljs-number">1</span>, matrix, memo)),                              dfs(x-<span class="hljs-number">1</span>, y+<span class="hljs-number">1</span>, matrix, memo)) + matrix[x][y];<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix.length;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;            <br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n + <span class="hljs-number">2</span>];<br>    System.arraycopy(matrix[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>] = Integer.MAX_VALUE; <span class="hljs-comment">//左右边界同样初始化为MAX</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123;<br>            dp[i][j] = Math.min(Math.min(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][j]), dp[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>])<br>             + matrix[i][j - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (res &gt; dp[n - <span class="hljs-number">1</span>][i]) res = dp[n - <span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格中的最小路径代价"><a href="#网格中的最小路径代价" class="headerlink" title="网格中的最小路径代价"></a><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">网格中的最小路径代价</a></h3><p>题目太复杂，建议去原链接里读</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]grid; <span class="hljs-type">int</span> [][]moveCost;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.moveCost = moveCost;<br>        <span class="hljs-built_in">this</span>.m = grid.length;<br>        <span class="hljs-built_in">this</span>.n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, i, memo);<br>            <span class="hljs-comment">// System.out.print(t + &quot; &quot;);</span><br>            <span class="hljs-keyword">if</span> (t &lt; res) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y];<br>        <span class="hljs-keyword">if</span> (memo[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(x + <span class="hljs-number">1</span>, i, memo) + grid[x][y] + moveCost[grid[x][y]][i];<br>            res = Math.min(res, t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正序遍历</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) dp[<span class="hljs-number">0</span>][i] = grid[<span class="hljs-number">0</span>][i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dp[i - <span class="hljs-number">1</span>][k] + moveCost[grid[i - <span class="hljs-number">1</span>][k]][j];<br>                <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>            &#125;<br>            dp[i][j] = grid[i][j] + res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ans &gt; dp[m - <span class="hljs-number">1</span>][i]) ans = dp[m - <span class="hljs-number">1</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//倒序遍历，可以原地修改</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathCost</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span>[][] moveCost)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> grid[i + <span class="hljs-number">1</span>][k] + moveCost[grid[i][j]][k];<br>                <span class="hljs-keyword">if</span> (res &gt; t) res = t;<br>            &#125;<br>            grid[i][j] += res;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">if</span> (ans &gt; grid[<span class="hljs-number">0</span>][i]) ans = grid[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="下降路径最小和-II"><a href="#下降路径最小和-II" class="headerlink" title="下降路径最小和 II"></a><a href="https://leetcode.cn/problems/minimum-falling-path-sum-ii/">下降路径最小和 II</a></h3><p>给你一个 <code>n x n</code> 整数矩阵 <code>grid</code> ，请你返回 <strong>非零偏移下降路径</strong> 数字和的最小值。</p><p><strong>非零偏移下降路径</strong> 定义为：从 <code>grid</code> 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]grid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[grid.length][grid[<span class="hljs-number">0</span>].length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, Integer.MAX_VALUE);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; ++ i) &#123;<br>            res = Math.min(res, dfs(<span class="hljs-number">0</span>, i, memo));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == grid.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y];<br>        <span class="hljs-keyword">if</span> (memo[x][y] != Integer.MAX_VALUE) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; grid[<span class="hljs-number">0</span>].length; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (i != y) &#123;<br>                res = Math.min(dfs(x + <span class="hljs-number">1</span>, i, memo) + grid[x][y], res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推 + 原地修改</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; n; ++ k) &#123;<br>                <span class="hljs-keyword">if</span> (k != j) &#123;<br>                    res = Math.min(res, grid[i+<span class="hljs-number">1</span>][k]);<br>                &#125;<br>            &#125;<br>            grid[i][j] += res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : grid[<span class="hljs-number">0</span>]) &#123;<br>        ans = Math.min(ans, a);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵的最大非负积"><a href="#矩阵的最大非负积" class="headerlink" title="矩阵的最大非负积"></a><a href="https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/">矩阵的最大非负积</a></h3><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>grid</code> 。最初，你位于左上角 <code>(0, 0)</code> ，每一步，你可以在矩阵中 <strong>向右</strong> 或 <strong>向下</strong> 移动。</p><p>在从左上角 <code>(0, 0)</code> 开始到右下角 <code>(m - 1, n - 1)</code> 结束的所有路径中，找出具有 <strong>最大非负积</strong> 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p><p>返回 <strong>最大非负积</strong> 对 <strong><code>109 + 7</code></strong> <strong>取余</strong> 的结果。如果最大积为 <strong>负数</strong> ，则返回 <code>-1</code> 。</p><p><strong>注意，</strong>取余是在得到最大积之后执行的。</p><blockquote><p>直接上来就动态规划递推解决，但是在两个地方被卡了一个小时</p></blockquote><ul><li><code>(int) (mx[m - 1][n - 1] % mod)</code> 取模操作优先级低于类型转换，必须加括号</li><li>不认真读题，在每一步更新 <code>mx[i][j]</code> 的同时就对其取模，导致后续下一层比较大小时出问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxProductPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-type">long</span> [][]mx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">long</span> [][]mi = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    mx[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = mi[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        mx[i][<span class="hljs-number">0</span>] = (mx[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * grid[i][<span class="hljs-number">0</span>]);<br>        mi[i][<span class="hljs-number">0</span>] = mx[i][<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>        mx[<span class="hljs-number">0</span>][i] = (mx[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] * grid[<span class="hljs-number">0</span>][i]);<br>        mi[<span class="hljs-number">0</span>][i] = mx[<span class="hljs-number">0</span>][i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>            mx[i][j] = (grid[i][j] * Math.max(mx[i][j - <span class="hljs-number">1</span>], mx[i - <span class="hljs-number">1</span>][j]));<br>            mi[i][j] = (grid[i][j] * Math.min(mi[i][j- <span class="hljs-number">1</span>], mi[i - <span class="hljs-number">1</span>][j]));<br>            <span class="hljs-keyword">if</span> (grid[i][j] &lt; <span class="hljs-number">0</span>) &#123;<br>                mx[i][j] = (grid[i][j] * Math.min(mi[i][j - <span class="hljs-number">1</span>], mi[i - <span class="hljs-number">1</span>][j]));<br>                mi[i][j] = (grid[i][j] * Math.max(mx[i][j - <span class="hljs-number">1</span>], mx[i - <span class="hljs-number">1</span>][j]));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : (<span class="hljs-type">int</span>) (mx[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] % mod);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵中和能被-K-整除的路径"><a href="#矩阵中和能被-K-整除的路径" class="headerlink" title="矩阵中和能被 K 整除的路径"></a><a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">矩阵中和能被 K 整除的路径</a></h3><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 和一个整数 <code>k</code> 。你从起点 <code>(0, 0)</code> 出发，每一步只能往 <strong>下</strong> 或者往 <strong>右</strong> ，你想要到达终点 <code>(m - 1, n - 1)</code> 。</p><p>请你返回路径和能被 <code>k</code> 整除的路径数目，由于答案可能很大，返回答案对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p><blockquote><p>dfs + memo，区别在于多考虑一个维度，memo的第三维存 <code>x、y</code> 点当前路径和 <code>s</code> 的状态信息</p><p>具体来说， <code>memo[x][y][s]</code> 表示从 <code>(x, y)</code> 开始，路径和对 <code>k</code> 取模为 <code>s</code> 的路径数量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">long</span> [][][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m][n][k];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> [][]a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> []b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, grid, k, <span class="hljs-number">0</span>, memo); <span class="hljs-comment">//正向反向开始都可以</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> [][]grid, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> s, <span class="hljs-type">long</span> [][][]memo)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length, n = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        s = (s + grid[x][y]) % k;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> s % k == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[x][y][s] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y][s];<br>        <span class="hljs-keyword">return</span> memo[x][y][s] = (dfs(x - <span class="hljs-number">1</span>, y, grid, k, s, memo) + dfs(x, y - <span class="hljs-number">1</span>, grid, k, s, memo)) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length; <br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length; <br>        <br>        <span class="hljs-type">long</span>[][][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m+<span class="hljs-number">1</span>][n+<span class="hljs-number">1</span>][k];<br>     <br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; r &lt; k; ++ r) &#123;<br>                    dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>][(r + grid[i][j]) % k] = (dp[i][j + <span class="hljs-number">1</span>][r] + dp[i + <span class="hljs-number">1</span>][j][r]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (dp[m][n][<span class="hljs-number">0</span>] % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">矩阵中的最长递增路径</a></h3><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []dx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> []dy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> [][]matrix;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestIncreasingPath</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = matrix.length;<br>        <span class="hljs-built_in">this</span>.n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(i, j);<br>                <span class="hljs-keyword">if</span> (t &gt; res) res = t;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//初始长度为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> x + dx[i], y1 = y + dy[i];<br>            <span class="hljs-keyword">if</span> (x1 &lt; <span class="hljs-number">0</span> || x1 == m || y1 &lt; <span class="hljs-number">0</span> || y1 == n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matrix[x1][y1] &gt; matrix[x][y]) &#123;<br>                t = Math.max(t, <span class="hljs-number">1</span> + dfs(x1, y1));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="网格图中递增路径的数目"><a href="#网格图中递增路径的数目" class="headerlink" title="网格图中递增路径的数目"></a><a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/">网格图中递增路径的数目</a></h3><p>给你一个 <code>m x n</code> 的整数网格图 <code>grid</code> ，你可以从一个格子移动到 <code>4</code> 个方向相邻的任意一个格子。</p><p>请你返回在网格图中从 <strong>任意</strong> 格子出发，达到 <strong>任意</strong> 格子，且路径中的数字是 <strong>严格递增</strong> 的路径数目。由于答案可能会很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p><blockquote><p>dfs + memo 把上道题的代码简单改造一下就好了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []dx = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> []dy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> [][]matrix;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-type">int</span> m, n, mod = <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPaths</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = matrix.length;<br>        <span class="hljs-built_in">this</span>.n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.matrix = matrix;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                res += dfs(i, j);<br>                res %= mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) res % mod;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (memo[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//初始长度为1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">x1</span> <span class="hljs-operator">=</span> x + dx[i], y1 = y + dy[i];<br>            <span class="hljs-keyword">if</span> (x1 &lt; <span class="hljs-number">0</span> || x1 == m || y1 &lt; <span class="hljs-number">0</span> || y1 == n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (matrix[x1][y1] &gt; matrix[x][y]) &#123;<br>                t += dfs(x1, y1);<br>                t %= mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="检查是否有合法括号字符串路径"><a href="#检查是否有合法括号字符串路径" class="headerlink" title="检查是否有合法括号字符串路径"></a><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/">检查是否有合法括号字符串路径</a></h3><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抄的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">char</span> [][]grid;<br>    <span class="hljs-type">boolean</span> [][][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasValidPath</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.m = grid.length;<br>        <span class="hljs-built_in">this</span>.n = grid[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n][(m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;)&#x27;</span> || grid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u &gt; m - x + n - y - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//如果从起点到当前位置的左括号数已经很大，大到从当前位置到结尾全是右括号都无法匹配完</span><br>        <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> u == <span class="hljs-number">1</span>; <span class="hljs-comment">//抵达终点，左括号还剩1个</span><br>        <span class="hljs-keyword">if</span> (memo[x][y][u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>        memo[x][y][u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            ++ u;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            -- u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u &gt;= <span class="hljs-number">0</span> &amp;&amp; (x &lt; m - <span class="hljs-number">1</span> &amp;&amp; dfs(x + <span class="hljs-number">1</span>, y, u) || y &lt; n - <span class="hljs-number">1</span> &amp;&amp; dfs(x, y + <span class="hljs-number">1</span>, u));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己写了个反向的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">char</span> [][]grid;<br>    <span class="hljs-type">boolean</span> [][][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasValidPath</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        <span class="hljs-built_in">this</span>.m = grid.length;<br>        <span class="hljs-built_in">this</span>.n = grid[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][n][(m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span> (grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;)&#x27;</span> || grid[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span> || (m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u &gt; x + y + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> u == <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[x][y][u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        memo[x][y][u] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (grid[x][y] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>            ++ u;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            -- u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> u &gt;= <span class="hljs-number">0</span> &amp;&amp; (x &gt; <span class="hljs-number">0</span> &amp;&amp; dfs(x - <span class="hljs-number">1</span>, y, u) || y &gt; <span class="hljs-number">0</span> &amp;&amp; dfs(x, y - <span class="hljs-number">1</span>, u));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扣分后的最大得分"><a href="#扣分后的最大得分" class="headerlink" title="扣分后的最大得分"></a><a href="https://leetcode.cn/problems/maximum-number-of-points-with-cost/">扣分后的最大得分</a></h3><p>给你一个 <code>m x n</code> 的整数矩阵 <code>points</code> （下标从 <strong>0</strong> 开始）。一开始你的得分为 <code>0</code> ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：<strong>每一行</strong> 中选取一个格子，选中坐标为 <code>(r, c)</code> 的格子会给你的总得分 <strong>增加</strong> <code>points[r][c]</code> 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code> 和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code> 和 <code>(r + 1, c2)</code> 的格子，你的总得分 <strong>减少</strong> <code>abs(c1 - c2)</code> 。</p><p>请你返回你能得到的 <strong>最大</strong> 得分。</p><blockquote><p>dfs+memo也会超时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> [][]points;<br>    <span class="hljs-type">long</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxPoints</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] points)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = points.length;<br>        <span class="hljs-built_in">this</span>.n = points[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.points = points;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m][n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(m - <span class="hljs-number">1</span>, i);<br>            <span class="hljs-keyword">if</span> (res &lt; t) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> points[x][y];<br>        <span class="hljs-keyword">if</span> (memo[x][y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[x][y];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> dfs(x - <span class="hljs-number">1</span>, i) ;<br>            d = d + points[x][y] - (i - y &lt; <span class="hljs-number">0</span> ? y - i : i - y);<br>            <span class="hljs-keyword">if</span> (t &lt; d) t = d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y] = t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面的时间复杂度是O(<code>m*n^2</code>)，超时，下面优化成O(<code>m*n</code>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxPoints</span><span class="hljs-params">(<span class="hljs-type">int</span> [][]points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> points.length, n = points[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">long</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[m][n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = points[<span class="hljs-number">0</span>][j];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-type">long</span> []leftMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>            <span class="hljs-type">long</span> []rightMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>            leftMax[<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; ++ j) &#123;<br>                leftMax[j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], leftMax[j - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>            &#125;<br>            rightMax[n - <span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>                rightMax[j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], rightMax[j + <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                dp[i][j] = points[i][j] + Math.max(leftMax[j], rightMax[j]);<br>                <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (res &lt; dp[m - <span class="hljs-number">1</span>][j]) res = dp[m - <span class="hljs-number">1</span>][j];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面的空间复杂度是O(<code>m*n</code>)，下面优化为滚动数组，空间复杂度O(<code>n</code>)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxPoints</span><span class="hljs-params">(<span class="hljs-type">int</span> [][]points)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> points.length, n = points[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">long</span> []pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-type">long</span> []cur = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>                max = Math.max(max - <span class="hljs-number">1</span> , pre[j]);<br>                cur[j] = max;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>                cur[j] = Math.max(cur[j], max = Math.max(max - <span class="hljs-number">1</span>, pre[j])) + points[i][j];<br>            &#125;<br>            pre = cur;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> t : cur) &#123;<br>            <span class="hljs-keyword">if</span> (res &lt; t) res = t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="摘樱桃-II"><a href="#摘樱桃-II" class="headerlink" title="摘樱桃 II"></a><a href="https://leetcode.cn/problems/cherry-pickup-ii/">摘樱桃 II</a></h3><p>给你一个 <code>rows x cols</code> 的矩阵 <code>grid</code> 来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p><p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 <code>(0,0)</code> 出发，机器人 2 从右上角格子 <code>(0, cols-1)</code> 出发。</p><p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p><ul><li>从格子 <code>(i,j)</code> 出发，机器人可以移动到格子 <code>(i+1, j-1)</code>，<code>(i+1, j)</code> 或者 <code>(i+1, j+1)</code> 。</li><li>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。</li><li>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。</li><li>两个机器人在任意时刻都不能移动到 <code>grid</code> 外面。</li><li>两个机器人最后都要到达 <code>grid</code> 最底下一行。</li></ul><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> [][]grid;<br>    <span class="hljs-type">int</span> []dy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> [][][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> [][]a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (y1 &lt; <span class="hljs-number">0</span> || y2 &lt; <span class="hljs-number">0</span> || y1 == n || y2 == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (y1 == y2) <span class="hljs-keyword">return</span> grid[x][y1];<br>        <span class="hljs-keyword">if</span> (x == m - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y1] + grid[x][y2];<br>        <span class="hljs-keyword">if</span> (memo[x][y1][y2] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y1][y2];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++ j) &#123;<br>                t = Math.max(t, dfs(x + <span class="hljs-number">1</span>, y1 + dy[i], y2 + dy[j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y1][y2] = t + grid[x][y1] + grid[x][y2];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>灵神这个版本好理解一些</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> m, n;<br>    <span class="hljs-type">int</span> [][]grid;<br>    <span class="hljs-type">int</span> []dy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> [][][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        m = grid.length;<br>        n = grid[<span class="hljs-number">0</span>].length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> [][]a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x == m || y1 &lt; <span class="hljs-number">0</span> || y2 &lt; <span class="hljs-number">0</span> || y1 == n || y2 == n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[x][y1][y2] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x][y1][y2];        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++ j) &#123;<br>                t = Math.max(t, dfs(x + <span class="hljs-number">1</span>, y1 + dy[i], y2 + dy[j]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[x][y1][y2] = t + (y1 == y2 ? grid[x][y1] : grid[x][y1] + grid[x][y2]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="摘樱桃"><a href="#摘樱桃" class="headerlink" title="摘樱桃"></a><a href="https://leetcode.cn/problems/cherry-pickup/">摘樱桃</a></h3><p>给你一个 <code>n x n</code> 的网格 <code>grid</code> ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：</p><ul><li><code>0</code> 表示这个格子是空的，所以你可以穿过它。</li><li><code>1</code> 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。</li><li><code>-1</code> 表示这个格子里有荆棘，挡着你的路。</li></ul><p>请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：</p><ul><li>从位置 <code>(0, 0)</code> 出发，最后到达 <code>(n - 1, n - 1)</code> ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 <code>0</code> 或者 <code>1</code> 的格子）；</li><li>当到达 <code>(n - 1, n - 1)</code> 后，你要继续走，直到返回到 <code>(0, 0) </code>，只能向上或向左走，并且只能穿越有效的格子；</li><li>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 <code>0</code> ）；</li><li>如果在 <code>(0, 0)</code> 和 <code>(n - 1, n - 1)</code> 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。</li></ul><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span>[][][][] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        n = grid.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n][n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][][] a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] b : a) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] c : b)<br>                    Arrays.fill(c, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x1 == n || y1 == n || x2 == n || y2 == n || grid[x1][y1] == -<span class="hljs-number">1</span> || grid[x2][y2] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Integer.MIN_VALUE; <span class="hljs-comment">// 如果碰到障碍或者越界返回最小值</span><br>        <span class="hljs-keyword">if</span> (x1 == n - <span class="hljs-number">1</span> &amp;&amp; y1 == n - <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> grid[x1][y1]; <span class="hljs-comment">// 如果到达终点返回终点的樱桃数</span><br>        <span class="hljs-keyword">if</span> (memo[x1][y1][x2][y2] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[x1][y1][x2][y2];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(<br>            Math.max(dfs(x1 + <span class="hljs-number">1</span>, y1, x2 + <span class="hljs-number">1</span>, y2), dfs(x1 + <span class="hljs-number">1</span>, y1, x2, y2 + <span class="hljs-number">1</span>)),<br>            Math.max(dfs(x1, y1 + <span class="hljs-number">1</span>, x2 + <span class="hljs-number">1</span>, y2), dfs(x1, y1 + <span class="hljs-number">1</span>, x2, y2 + <span class="hljs-number">1</span>))<br>        ) + grid[x1][y1] + (x1 == x2 &amp;&amp; y1 == y2 ? <span class="hljs-number">0</span> : grid[x2][y2]);<br>        <span class="hljs-keyword">return</span> memo[x1][y1][x2][y2] = res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>灵神，减少到三个状态表示，t：每个人走的总步数，j：第一个人走到的纵坐标，k：第二个人走到的纵坐标</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] grid;<br>    <span class="hljs-type">int</span>[][][] memo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cherryPickup</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.grid = grid;<br>        n = grid.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>][n][n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> t &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j == n || k == n || t - j == n || t - k == n || grid[t - j][j] == -<span class="hljs-number">1</span> || grid[t - k][k] == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> grid[n - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]; <br>        <span class="hljs-keyword">if</span> (memo[t][j][k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[t][j][k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(<br>            Math.max(dfs(t + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, k), dfs(t + <span class="hljs-number">1</span>, j, k + <span class="hljs-number">1</span>)),<br>            Math.max(dfs(t + <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>), dfs(t + <span class="hljs-number">1</span>, j, k)))<br>            + grid[t - j][j] + (j == k ? <span class="hljs-number">0</span> : grid[t - k][k]);<br>        <span class="hljs-keyword">return</span> memo[t][j][k] = res;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a><a href="https://leetcode.cn/problems/target-sum/">目标和</a></h3><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p><ul><li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li></ul><p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p><blockquote><p>dfs + memo: 假设要凑成target，需要添加+号的所有数的和为p，则需要添加负号的为sum(nums) - p，target &#x3D; p + (p - s) </p><p>解得p &#x3D; (s + target) &#x2F; 2，因此 s + target 小于0以及为奇数均不合法，题目转化为从n个数组元素中选取元素刚好填满容量为p的背包</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">// p: 添加+号的部分的和，q: 添加-号的部分的和</span><br>    <span class="hljs-comment">// p + q = sum</span><br>    <span class="hljs-comment">// p - q = t</span><br>    <span class="hljs-comment">// sum + t = 2 * p</span><br>    <span class="hljs-comment">// sum - t = 2 * q</span><br>    <span class="hljs-comment">// p = (sum + t) / 2</span><br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        target += sum;<br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        target /= <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, target, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> [][]memo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 没有元素可选，检查背包是否刚好填满</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 刚好填满，方案数 +1</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][c] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> memo[i][c]; <br>        <span class="hljs-keyword">if</span> (c &lt; nums[i]) <span class="hljs-keyword">return</span> memo[i][c] = dfs(i - <span class="hljs-number">1</span>, c, memo);<span class="hljs-comment">// 容量小于当前元素体积，不能选</span><br>        <span class="hljs-keyword">return</span> memo[i][c] = (dfs(i - <span class="hljs-number">1</span>, c, memo) + dfs(i - <span class="hljs-number">1</span>, c - nums[i], memo));<span class="hljs-comment">// 总方案数为选与不选当前元素的方案数之和</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>    target += sum;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    target /= <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> [][]f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= target; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                f[i + <span class="hljs-number">1</span>][j] = f[i][j] + f[i][j - nums[i]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f[i + <span class="hljs-number">1</span>][j] = f[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[n][target];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化，倒着枚举</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>    target += sum;<br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span> || target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>    target /= <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> []f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : nums) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> target; j &gt;= x; -- j) &#123;<br>            f[j] = f[j] + f[j - x];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[target];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><blockquote><p>dfs + memo，最初把memo数组设为boolean，只有两种状态，无法表示是还未访问到还是访问到了但是结果为false</p><p>故使用Integer数组，初始为null表示还未被访问，1表示true，0表示false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        Integer [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[n][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> dfs(nums, memo, sum, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, Integer [][]memo, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (u == n || sum &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[u][sum] != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> memo[u][sum] == <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> dfs(nums, memo, sum, u + <span class="hljs-number">1</span>) || dfs(nums, memo, sum - nums[u], u + <span class="hljs-number">1</span>);<br>        memo[u][sum] = result ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推，空间优化，逆序遍历。</p><p>为什么逆序？正序的话，因为是用到背包容量 j 减去当前物品体积 i 的状态，是在 j 之前就更新过了的，所以会出错，因为用到新值了，我们要用的是上一层的旧值。逆序就不会出现这种问题，你细想。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).sum();<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br>        <span class="hljs-type">boolean</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[sum + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> sum; j &gt;= i; -- j) &#123;<br>                dp[j] = dp[j] || dp[j - i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[sum];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和为目标值的最长子序列的长度"><a href="#和为目标值的最长子序列的长度" class="headerlink" title="和为目标值的最长子序列的长度"></a><a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">和为目标值的最长子序列的长度</a></h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>返回和为 <code>target</code> 的 <code>nums</code> 子序列中，子序列 <strong>长度的最大值</strong> 。如果不存在和为 <code>target</code> 的子序列，返回 <code>-1</code> 。</p><p><strong>子序列</strong> 指的是从原数组中删除一些或者不删除任何元素后，剩余元素保持原来的顺序构成的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3,4,5]</span>, target = 9<br>输出：3<br>解释：总共有 3 个子序列的和为 9 ：<span class="hljs-comment">[4,5]</span> ，<span class="hljs-comment">[1,3,5]</span> 和 <span class="hljs-comment">[2,3,4]</span> 。最长的子序列是 <span class="hljs-comment">[1,3,5]</span> 和 <span class="hljs-comment">[2,3,4]</span> 。所以答案为 3 。<br></code></pre></td></tr></table></figure><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo; <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubsequence</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.size();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] row : memo) &#123;<br>            Arrays.fill(row, -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(nums, n - <span class="hljs-number">1</span>, target);<br>        <span class="hljs-keyword">return</span> t &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : t;<br>    &#125;<br><br>    <span class="hljs-comment">//前i个元素和为target的子序列长度的最大值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;Integer&gt; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 找到一个合法的子序列</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Integer.MIN_VALUE / <span class="hljs-number">2</span>; <span class="hljs-comment">// 没有更多元素可选</span><br>        <span class="hljs-keyword">if</span> (memo[i][target] != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][target];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums.get(i);<br>        <span class="hljs-keyword">if</span> (target &lt; t) &#123;<br>            <span class="hljs-keyword">return</span> memo[i][target] = dfs(nums, i - <span class="hljs-number">1</span>, target);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][target] = Math.max(dfs(nums, i - <span class="hljs-number">1</span>, target), dfs(nums, i - <span class="hljs-number">1</span>, target - t) + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将一个数字表示成幂的和的方案数"><a href="#将一个数字表示成幂的和的方案数" class="headerlink" title="将一个数字表示成幂的和的方案数"></a><a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">将一个数字表示成幂的和的方案数</a></h3><p>给你两个 <strong>正</strong> 整数 <code>n</code> 和 <code>x</code> 。</p><p>请你返回将 <code>n</code> 表示成一些 <strong>互不相同</strong> 正整数的 <code>x</code> 次幂之和的方案数。换句话说，你需要返回互不相同整数 <code>[n1, n2, ..., nk]</code> 的集合数目，满足 <code>n = n1x + n2x + ... + nkx</code> 。</p><p>由于答案可能非常大，请你将它对 <code>109 + 7</code> 取余后返回。</p><p>比方说，<code>n = 160</code> 且 <code>x = 3</code> ，一个表示 <code>n</code> 的方法是 <code>n = 23 + 33 + 53</code> 。</p><blockquote><p>递推：越来越熟练了 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numberOfWays</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(n, <span class="hljs-number">1d</span> / x) + <span class="hljs-number">1</span>; <span class="hljs-comment">//物品就从1-m中选，代表的是物品的体积，背包容量是n</span><br>        <span class="hljs-type">long</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.pow(i, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= t; -- j) &#123; <br>                dp[j] = dp[j] + dp[j - t];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (dp[n] % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行操作可获得的最大总奖励-I"><a href="#执行操作可获得的最大总奖励-I" class="headerlink" title="执行操作可获得的最大总奖励 I"></a><a href="https://leetcode.cn/problems/maximum-total-reward-using-operations-i/">执行操作可获得的最大总奖励 I</a></h3><p>给你一个整数数组 <code>rewardValues</code>，长度为 <code>n</code>，代表奖励的值。</p><p>最初，你的总奖励 <code>x</code> 为 0，所有下标都是 <strong>未标记</strong> 的。你可以执行以下操作 <strong>任意次</strong> ：</p><ul><li>从区间 <code>[0, n - 1]</code> 中选择一个 <strong>未标记</strong> 的下标 <code>i</code>。</li><li>如果 <code>rewardValues[i]</code> <strong>大于</strong> 你当前的总奖励 <code>x</code>，则将 <code>rewardValues[i]</code> 加到 <code>x</code> 上（即 <code>x = x + rewardValues[i]</code>），并 <strong>标记</strong> 下标 <code>i</code>。</li></ul><p>以整数形式返回执行最优操作能够获得的 <strong>最大</strong> 总奖励。</p><blockquote><p>这道题太抽象了，建议多思考思考怎么抽象成01背包的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxTotalReward</span><span class="hljs-params">(<span class="hljs-type">int</span>[] rewardValues)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rewardValues.length;<br>        Arrays.sort(rewardValues);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> rewardValues[n - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>;<span class="hljs-comment">//最大价值不会超过最大reward的二倍，因为如果最大reward能选，那前面的所有和就应该小于最大reward。</span><br>        <span class="hljs-type">boolean</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s + <span class="hljs-number">1</span>];<span class="hljs-comment">//背包容量就应该初始化为这个“可能”的最大价值，而答案就应该是dp数组为true的最大下标，也就是能达到的最大价值</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> rewardValues[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s; j &gt;= t; -- j) &#123;<br>                <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">2</span> * t) &#123; <span class="hljs-comment">//比普通的01背包多了一个判断，根据题意：如果t大于你当前的总奖励x才能选，选了t的状态就是从j-t这个价值的状态转移过来，x=j-t，t&gt;j-t, j&lt;2*t。不选t的状态就是dp[j]</span><br>                    dp[j] = dp[j] || dp[j - t];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= s; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (dp[j]) res = j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">一和零</a></h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p><p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：strs = [<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;0001&quot;</span>, <span class="hljs-string">&quot;111001&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>], m = <span class="hljs-number">5</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：最多有 <span class="hljs-number">5</span> 个 <span class="hljs-number">0</span> 和 <span class="hljs-number">3</span> 个 <span class="hljs-number">1</span> 的最大子集是 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; ，因此答案是 <span class="hljs-number">4</span> 。<br>其他满足题意但较小的子集包括 &#123;<span class="hljs-string">&quot;0001&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>&#125; 和 &#123;<span class="hljs-string">&quot;10&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>&#125; 。&#123;<span class="hljs-string">&quot;111001&quot;</span>&#125; 不满足题意，因为它含 <span class="hljs-number">4</span> 个 <span class="hljs-number">1</span> ，大于 <span class="hljs-built_in">n</span> 的值 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><blockquote><p>二维，背包有两个</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> [][][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[s + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, one = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[i].toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) one ++;<br>                <span class="hljs-keyword">else</span> zero ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= m; ++ j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= n; ++ k) &#123;<br>                    dp[i + <span class="hljs-number">1</span>][j][k] = dp[i][j][k];<br>                    <span class="hljs-keyword">if</span> (zero &lt;= j &amp;&amp; one &lt;= k) &#123;<br>                        dp[i + <span class="hljs-number">1</span>][j][k] = Math.max(dp[i][j][k], dp[i][j - zero][k - one] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[s][m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxForm</span><span class="hljs-params">(String[] strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> strs.length;<br>        <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s; ++ i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">zero</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, one = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : strs[i].toCharArray()) &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) one ++;<br>                <span class="hljs-keyword">else</span> zero ++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> m; j &gt;= zero; -- j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> n; k &gt;= one; -- k) &#123;<br>                    dp[j][k] = Math.max(dp[j][k], dp[j - zero][k - one] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p><p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p><blockquote><p>怎么转化为01背包？你真是一个一点就通的天才少年</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastStoneWeightII</span><span class="hljs-params">(<span class="hljs-type">int</span>[] stones)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(stones).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> stones.length;<br>        <span class="hljs-type">boolean</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[t + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s : stones) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> t; j &gt;= s; -- j) &#123;<br>                dp[j] = dp[j] || dp[j - s];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = t; i &gt;= <span class="hljs-number">0</span>; -- i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i]) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (sum - i) &gt; i ? sum - <span class="hljs-number">2</span> * i : <span class="hljs-number">2</span> * i - sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="最高的广告牌"><a href="#最高的广告牌" class="headerlink" title="最高的广告牌"></a><a href="https://leetcode.cn/problems/tallest-billboard/">最高的广告牌</a></h3><p>你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。</p><p>你有一堆可以焊接在一起的钢筋 <code>rods</code>。举个例子，如果钢筋的长度为 <code>1</code>、<code>2</code> 和 <code>3</code>，则可以将它们焊接在一起形成长度为 <code>6</code> 的支架。</p><p>返回 <em>广告牌的最大可能安装高度</em> 。如果没法安装广告牌，请返回 <code>0</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-type">int</span> sum;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tallestBillboard</span><span class="hljs-params">(<span class="hljs-type">int</span>[] rods)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rods.length;<br>        sum = Arrays.stream(rods).sum();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(rods, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//前i个支架(包含i)高度差为j时的最大高度和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []rods, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<span class="hljs-comment">// i:前i个支架，j：高度差</span><br>        <span class="hljs-keyword">if</span> (j &gt; sum) &#123;<br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (rods[i] == j) <span class="hljs-keyword">return</span> j;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> dfs(rods, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> dfs(rods, i - <span class="hljs-number">1</span>, j + rods[i]) + rods[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> dfs(rods, i - <span class="hljs-number">1</span>, Math.abs(j - rods[i])) + rods[i];<br>        <span class="hljs-keyword">return</span> memo[i][j] = Math.max(Math.max(t1, t2), t3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tallestBillboard</span><span class="hljs-params">(<span class="hljs-type">int</span>[] rods)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> rods.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(rods).sum();<br>        <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][sum + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            Arrays.fill(dp[i], Integer.MIN_VALUE);<br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            d += rods[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= d; ++ j) &#123;    <br>                <span class="hljs-keyword">if</span> (rods[i] + j &lt;= sum) &#123;<br>                     dp[i + <span class="hljs-number">1</span>][j] = Math.max(dp[i][j], Math.max(dp[i][Math.abs(rods[i] - j)], dp[i][rods[i] + j]) + rods[i]);<br>            &#125;<br>        &#125;      <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="盈利计划"><a href="#盈利计划" class="headerlink" title="盈利计划"></a><a href="https://leetcode.cn/problems/profitable-schemes/">盈利计划</a></h3><p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p><p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][][] memo;<br>    <span class="hljs-type">int</span> []group;<br>    <span class="hljs-type">int</span> []profit;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> group.length;<br>        <span class="hljs-built_in">this</span>.group = group;<br>        <span class="hljs-built_in">this</span>.profit = profit;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[][] a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] b : a) &#123;<br>                Arrays.fill(b, -<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(m - <span class="hljs-number">1</span>, n, minProfit) % mod;<br>    &#125;<br><br>    <span class="hljs-comment">//前i个工作，前j个员工，产生k的利润的方案数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//没有员工可选，不管多少个工作都产生不了利润</span><br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//没有工作可选</span><br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//产生0的利润有一个方案</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][j][k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][j][k];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">gro</span> <span class="hljs-operator">=</span> group[i], pro = profit[i];<br>        <span class="hljs-keyword">return</span> memo[i][j][k] = (dfs(i - <span class="hljs-number">1</span>, j, k) + dfs(i - <span class="hljs-number">1</span>, j - gro, Math.max(<span class="hljs-number">0</span>, k - pro))) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> group.length, p = profit.length, mod = <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> [][][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<span class="hljs-comment">//前i种工作，前j个员工，至少产生k的利润的方案数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++ j) dp[<span class="hljs-number">0</span>][j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123; <span class="hljs-comment">//工作</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> group[i], lr = profit[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++ j) &#123; <span class="hljs-comment">//人数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= minProfit; ++ k) &#123; <span class="hljs-comment">//利润</span><br>                    <span class="hljs-keyword">if</span> (j &lt; rs) &#123;<br>                        dp[i + <span class="hljs-number">1</span>][j][k] = dp[i][j][k];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i + <span class="hljs-number">1</span>][j][k] = (dp[i][j][k] + dp[i][j - rs][Math.max(<span class="hljs-number">0</span>, k - lr)]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">profitableSchemes</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> minProfit, <span class="hljs-type">int</span>[] group, <span class="hljs-type">int</span>[] profit)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> group.length, p = profit.length, mod = <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][minProfit + <span class="hljs-number">1</span>];<span class="hljs-comment">//前i种工作，前j个员工，至少产生k的利润的方案数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++ j) dp[j][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; ++ i) &#123; <span class="hljs-comment">//工作</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> group[i], lr = profit[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n; j &gt;= rs; -- j) &#123; <span class="hljs-comment">//人数</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= minProfit; ++ k) &#123; <span class="hljs-comment">//利润</span><br>                    dp[j][k] = (dp[j][k] + dp[j - rs][Math.max(<span class="hljs-number">0</span>, k - lr)]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][minProfit];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求出所有子序列的能量和"><a href="#求出所有子序列的能量和" class="headerlink" title="求出所有子序列的能量和"></a><a href="https://leetcode.cn/problems/find-the-sum-of-the-power-of-all-subsequences/">求出所有子序列的能量和</a></h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p><p>一个整数数组的 <strong>能量</strong> 定义为和 <strong>等于</strong> <code>k</code> 的子序列的数目。</p><p>请你返回 <code>nums</code> 中所有子序列的 <strong>能量和</strong> 。</p><p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><blockquote><p>dp(i，j，k)表示前i个数中长度为j且和为k的子序列的数目</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfPower</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, mod = <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> [][][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>][s + <span class="hljs-number">1</span>];<span class="hljs-comment">//前i个数中长度为j和为k的子序列的能量</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i + <span class="hljs-number">1</span>; ++ j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= s; ++ k) &#123;<br>                    <span class="hljs-keyword">if</span> (nums[i] &gt; k) &#123; <span class="hljs-comment">//不能选第i个数</span><br>                        dp[i + <span class="hljs-number">1</span>][j][k] = dp[i][j][k];<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) &#123;<br>                        dp[i + <span class="hljs-number">1</span>][j][k] = (dp[i][j][k] + dp[i][j - <span class="hljs-number">1</span>][k - nums[i]]) % mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= n; ++ j) &#123; <span class="hljs-comment">//枚举每一个长度j中和等于s的子序列的数目,该长度的子序列对答案的贡献为：数目 * 2^(n-j)</span><br>            res += Math.pow(<span class="hljs-number">2</span>, n - j) * dp[n][j][s] % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfPower</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, mod = <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][s + <span class="hljs-number">1</span>];<span class="hljs-comment">//前i个数中长度为j和为k的子序列的个数</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; -- j) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> s; k &gt;= nums[i]; -- k) &#123;<br>                    dp[j][k] = (dp[j][k] + dp[j - <span class="hljs-number">1</span>][k - nums[i]]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; ++ j) &#123;<br>            res += Math.pow(<span class="hljs-number">2</span>, n - j) * dp[j][s] % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (res % mod);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>另一种定义</li></ul><blockquote><p>dp(i, j)表示前i个元素，从中选出的子序列和为j时的能量和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumOfPower</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, mod = <span class="hljs-number">1_000_000_007</span>;<br>        <span class="hljs-type">int</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>];<span class="hljs-comment">//前i个元素，从中选出的子序列和为j时的能量和</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> k; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = dp[i][j] * <span class="hljs-number">2</span> % mod;<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                    dp[i + <span class="hljs-number">1</span>][j] = (dp[i + <span class="hljs-number">1</span>][j] + dp[i][j - nums[i]]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][k];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="好分区的数目"><a href="#好分区的数目" class="headerlink" title="好分区的数目"></a><a href="https://leetcode.cn/problems/number-of-great-partitions/">好分区的数目</a></h3><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p><p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>109 + 7</code> <strong>取余</strong> 后的结果。</p><p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p><blockquote><p>dfs + memo; 和大于等于k，不太好用背包，转化为求和小于k的分区数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPartitions</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<span class="hljs-comment">//妈的用stream流只支持int类型，会爆int</span><br>            sum += num;<br>        &#125;<span class="hljs-comment">//long sum = Arrays.stream(nums).mapToLong(o -&gt; (long) o).sum();可以这样,但是没for快</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (sum / <span class="hljs-number">2</span> &lt; s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> [][]memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][s + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (dfs(nums, memo, n - <span class="hljs-number">1</span>, s)) % mod;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<span class="hljs-comment">//妈的用Math.pow也会爆，得用快速幂</span><br>            total = (total * <span class="hljs-number">2</span>) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) ((total - <span class="hljs-number">2</span> * res + mod) % mod);<span class="hljs-comment">//妈的不多加一个mod又会减成负数</span><br>    &#125;<br><br>    <span class="hljs-comment">//前i个数中,选出和小于k的组合个数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">long</span> [][]memo, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> k &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i][k] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][k];<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(nums, memo, i - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">if</span> (k &gt; nums[i]) &#123;<br>            res = (res + dfs(nums, memo, i - <span class="hljs-number">1</span>, k - nums[i])) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][k] = res;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPartitions</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).mapToLong(o -&gt; (<span class="hljs-type">long</span>) o).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (sum / <span class="hljs-number">2</span> &lt; s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> [][]dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][s + <span class="hljs-number">1</span>];<span class="hljs-comment">//从前i个数中选择若干元素，和为j的分区数，所以j小于s，表示坏分区</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            ans = ans * <span class="hljs-number">2</span> % mod;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; s; ++ j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = dp[i][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= nums[i]) &#123;<br>                    dp[i + <span class="hljs-number">1</span>][j] = (dp[i + <span class="hljs-number">1</span>][j] + dp[i][j - nums[i]]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s; ++ i) &#123;<br>            res = (res + dp[n][i]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (ans - res * <span class="hljs-number">2</span> % mod + mod) % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>  <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPartitions</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(nums).mapToLong(o -&gt; (<span class="hljs-type">long</span>) o).sum();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">if</span> (sum / <span class="hljs-number">2</span> &lt; s) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[s + <span class="hljs-number">1</span>];<span class="hljs-comment">//从前i个数中选择若干元素，和为j的分区数，所以j小于s，表示坏分区</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1L</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            ans = ans * <span class="hljs-number">2</span> % mod;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s - <span class="hljs-number">1</span>; j &gt;= nums[i]; -- j) &#123;<br>                dp[j] = (dp[j] + dp[j - nums[i]]) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s; ++ i) &#123;<br>            res = (res + dp[i]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (ans - res * <span class="hljs-number">2</span> % mod + mod) % mod;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> dfs(coins, amount, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> t &gt;= Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []coins, <span class="hljs-type">int</span> amount, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[u][amount] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[u][amount];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(coins, amount, u - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (amount &gt;= coins[u]) &#123;<br>            res = Math.min(res, dfs(coins, amount - coins[u], u) + <span class="hljs-number">1</span>);<br>        &#125;   <br>        <span class="hljs-keyword">return</span> memo[u][amount] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp[<span class="hljs-number">0</span>], Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= amount; ++ j) &#123;<br>                dp[i + <span class="hljs-number">1</span>][j] = dp[i][j];<br>                <span class="hljs-keyword">if</span> (j &gt;= coins[i]) &#123;<br>                    dp[i + <span class="hljs-number">1</span>][j] = Math.min(dp[i][j], dp[i + <span class="hljs-number">1</span>][j - coins[i]] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][amount] == Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : dp[n][amount];<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 1 2 3 4 5</span><br><span class="hljs-comment">// 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><blockquote><p>空间优化，正序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">coinChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] coins, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= amount; ++ j) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == Integer.MAX_VALUE / <span class="hljs-number">2</span> ? -<span class="hljs-number">1</span> : dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">零钱兑换 II</a></h3><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][amount + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(coins, amount, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []coins, <span class="hljs-type">int</span> amount, <span class="hljs-type">int</span> u)</span> &#123;<br>        <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[u][amount] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[u][amount];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(coins, amount, u - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (amount &gt;= coins[u]) &#123;<br>            res += dfs(coins, amount - coins[u], u);<br>        &#125;   <br>        <span class="hljs-keyword">return</span> memo[u][amount] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">int</span>[] coins)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> coins.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[amount + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt;= amount; ++ j) &#123;<br>                dp[j] += dp[j - i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[t + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(t, n);<br>    &#125;<br>    <span class="hljs-comment">//n = 11, sqrt = 3,只有1,2,3的完全平方数能参与凑11的过程中</span><br>    <span class="hljs-comment">//1-t中他们的完全平方数凑够n的最小数量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> t, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[t][n] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[t][n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(t - <span class="hljs-number">1</span>, n);<br>        <span class="hljs-keyword">if</span> (n &gt;= t * t) &#123;<br>            res = Math.min(res, dfs(t, n - t * t) + <span class="hljs-number">1</span>);<br>        &#125;   <br>        <span class="hljs-keyword">return</span> memo[t][n] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []dp;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.sqrt(n);<br>        Arrays.fill(dp, Integer.MAX_VALUE / <span class="hljs-number">2</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= t; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt;= n; j ++) &#123;<br>                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数位成本和为目标值的最大数字"><a href="#数位成本和为目标值的最大数字" class="headerlink" title="数位成本和为目标值的最大数字"></a><a href="https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/">数位成本和为目标值的最大数字</a></h3><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code> 。请你返回满足如下规则可以得到的 <strong>最大</strong> 整数：</p><ul><li>给当前结果添加一个数位（<code>i + 1</code>）的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li><li>总成本必须恰好等于 <code>target</code> 。</li><li>添加的数位中没有数字 0 。</li></ul><p>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><blockquote><p>dfs + memo,先通过dfs枚举最长答案（完全背包）最长的字符串一定是最大的整数，接着使用dfs记录下的转移信息，倒着枚举数字，找出最长的字符串。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">largestNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] cost, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> cost.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> dfs(n - <span class="hljs-number">1</span>, cost, target);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (result &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, j = target; i &gt;= <span class="hljs-number">1</span>; -- i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> cost[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">while</span> (j &gt;= u &amp;&amp; memo[i - <span class="hljs-number">1</span>][j] == memo[i - <span class="hljs-number">1</span>][j - u] + <span class="hljs-number">1</span>) &#123;<br>                res += String.valueOf(i);<br>                j -= u;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span>[] cost, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Integer.MIN_VALUE;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][target] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(i - <span class="hljs-number">1</span>, cost, target);<br>        <span class="hljs-keyword">if</span> (target &gt;= cost[i]) &#123;<br>            res = Math.max(res, dfs(i, cost, target - cost[i]) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="掷骰子等于目标和的方法数"><a href="#掷骰子等于目标和的方法数" class="headerlink" title="掷骰子等于目标和的方法数"></a><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/">掷骰子等于目标和的方法数</a></h3><p>这里有 <code>n</code> 个一样的骰子，每个骰子上都有 <code>k</code> 个面，分别标号为 <code>1</code> 到 <code>k</code> 。</p><p>给定三个整数 <code>n</code>、<code>k</code> 和 <code>target</code>，请返回投掷骰子的所有可能得到的结果（共有 <code>kn</code> 种方式），使得骰子面朝上的数字总和等于 <code>target</code>。</p><p>由于答案可能很大，你需要对 <code>109 + 7</code> <strong>取模</strong>。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-type">int</span> [][][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> &#123;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> [][]a : memo) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []b : a) Arrays.fill(b, -<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dfs(n, k, target) % mod;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> target == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[n][k][target] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[n][k][target];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= k; ++ i) &#123;<br>            <span class="hljs-keyword">if</span> (target &gt;= i) &#123;<br>                res = (res + dfs(n - <span class="hljs-number">1</span>, k, target - i)) % mod;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[n][k][target] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; n || target &gt; n * k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 无法组成 target</span><br>        &#125;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][target + <span class="hljs-number">1</span>];<br>        memo[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; l &lt;= target; ++ l) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++ j) &#123;<br>                    <span class="hljs-keyword">if</span> (l &gt;= j) &#123;<br>                        res = (res + memo[i][l - j]) % mod;<br>                    &#125;<br>                &#125;<br>                memo[i + <span class="hljs-number">1</span>][l] = res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[n][target] % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>空间优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numRollsToTarget</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target &lt; n || target &gt; n * k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 无法组成 target</span><br>        &#125;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[target + <span class="hljs-number">1</span>];<br>        memo[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> target; l &gt;= <span class="hljs-number">0</span>; -- l) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= k; ++ j) &#123;<br>                    <span class="hljs-keyword">if</span> (l &gt;= j) &#123;<br>                        res = (res + memo[l - j]) % mod;<br>                    &#125;<br>                &#125;<br>                memo[l] = res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[target] % mod;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小化目标值与所选元素的差"><a href="#最小化目标值与所选元素的差" class="headerlink" title="最小化目标值与所选元素的差"></a><a href="https://leetcode.cn/problems/minimize-the-difference-between-target-and-chosen-elements/">最小化目标值与所选元素的差</a></h3><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> 和一个整数 <code>target</code> 。</p><p>从矩阵的 <strong>每一行</strong> 中选择一个整数，你的目标是 <strong>最小化</strong> 所有选中元素之 <strong>和</strong> 与目标值 <code>target</code> 的 <strong>绝对差</strong> 。</p><p>返回 <strong>最小的绝对差</strong> 。</p><p><code>a</code> 和 <code>b</code> 两数字的 <strong>绝对差</strong> 是 <code>a - b</code> 的绝对值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">boolean</span>[][] memo;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span>[][] mat;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minimizeTheDifference</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] mat, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mat.length;<br>        <span class="hljs-built_in">this</span>.n = mat[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-built_in">this</span>.mat = mat;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">MAX</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">70</span> * m, target);<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[m][MAX + <span class="hljs-number">1</span>];<br>        dfs(m - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, target);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> t)</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>            res = Math.min(res, Math.abs(sum - t));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[x][sum]) <span class="hljs-keyword">return</span>;<br>        memo[x][sum] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; ++ j) &#123;<br>            dfs(x - <span class="hljs-number">1</span>, sum + mat[x][j], t);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="经典线性-DP"><a href="#经典线性-DP" class="headerlink" title="经典线性 DP"></a>经典线性 DP</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> text2.length();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, text1, text2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(dfs(i - <span class="hljs-number">1</span>, j, s1, s2), dfs(i, j - <span class="hljs-number">1</span>, s1, s2));<br>        <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>            res = Math.max(res, dfs(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, s1, s2) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][j] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s2.length();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>                memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = Math.max(memo[i][j + <span class="hljs-number">1</span>], memo[i + <span class="hljs-number">1</span>][j]);<br>                <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>                    memo[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] = memo[i][j] + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[n][m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一维数组，我们可以发现，当前的状态由他的左边，上边和左上的状态转移过来，一维数组的话左上的状态就会在计算时被覆盖掉，导致我们计算当前状态时拿到的是错误的（被更新过的）左上状态来比较，所以需要用一个变量保存左上状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">longestCommonSubsequence</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> s2.length();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>; j &lt; m; ++ j) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> memo[j + <span class="hljs-number">1</span>];<span class="hljs-comment">//保存左上状态</span><br>                memo[j + <span class="hljs-number">1</span>] = Math.max(memo[j + <span class="hljs-number">1</span>], memo[j]);<br>                <span class="hljs-keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;<br>                    memo[j + <span class="hljs-number">1</span>] = pre + <span class="hljs-number">1</span>;<span class="hljs-comment">//左上状态+1</span><br>                &#125;<br>                pre = tmp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[m];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="划分型DP"><a href="#划分型DP" class="headerlink" title="划分型DP"></a>划分型DP</h2><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">单词拆分</a></h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> []memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>        Arrays.fill(memo, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(s, n, wordDict);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (memo[i] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i] == <span class="hljs-number">1</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; -- j) &#123;<br>            <span class="hljs-keyword">if</span> (wordDict.contains(s.substring(j, i))) &#123;<br>                res = res || dfs(s, j, wordDict);<br>            &#125;<br>        &#125;<br>        memo[i] = (res ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递推</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();<br>    <span class="hljs-type">boolean</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n + <span class="hljs-number">1</span>];<span class="hljs-comment">//dp[i]: s中前i个字符能否由wordDict拼接出</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++ i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; ++ j) &#123;<br>            <span class="hljs-keyword">if</span> (wordDict.contains(s.substring(j, i + <span class="hljs-number">1</span>))) &#123;<br>                dp[i + <span class="hljs-number">1</span>] = dp[j] || dp[i + <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></h3><p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span>[][] memo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> word1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> word2.length();<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][m];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> dfs(n - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, word1, word2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String word1, String word2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.min(dfs(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, word1, word2), Math.min(dfs(i - <span class="hljs-number">1</span>, j, word1, word2), dfs(i, j - <span class="hljs-number">1</span>, word1, word2))) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (word1.charAt(i) == word2.charAt(j)) res = dfs(i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>, word1, word2);<br>        <span class="hljs-keyword">return</span> memo[i][j] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不知道什么DP"><a href="#不知道什么DP" class="headerlink" title="不知道什么DP"></a>不知道什么DP</h2><h3 id="单调数组对的数目-I"><a href="#单调数组对的数目-I" class="headerlink" title="单调数组对的数目 I"></a><a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-i/">单调数组对的数目 I</a></h3><p>给你一个长度为 <code>n</code> 的 <strong>正</strong> 整数数组 <code>nums</code> 。</p><p>如果两个 <strong>非负</strong> 整数数组 <code>(arr1, arr2)</code> 满足以下条件，我们称它们是 <strong>单调</strong> 数组对：</p><ul><li>两个数组的长度都是 <code>n</code> 。</li><li><code>arr1</code> 是单调 <strong>非递减</strong> 的，换句话说 <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code> 。</li><li><code>arr2</code> 是单调 <strong>非递增</strong> 的，换句话说 <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code> 。</li><li>对于所有的 <code>0 &lt;= i &lt;= n - 1</code> 都有 <code>arr1[i] + arr2[i] == nums[i]</code> 。</li></ul><p>请你返回所有 <strong>单调</strong> 数组对的数目。</p><p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><blockquote><p>dfs + memo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]memo;<br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countOfPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> []a : memo) Arrays.fill(a, -<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= nums[n - <span class="hljs-number">1</span>]; ++ i) &#123;<br>            res = (res + dfs(n - <span class="hljs-number">1</span>, i)) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">//考虑前i个元素的单调数组对的数目，其中arr1的第i位值为j</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (memo[i][j] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> memo[i][j];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mi</span> <span class="hljs-operator">=</span> Math.min(Math.min(j, nums[i - <span class="hljs-number">1</span>]), nums[i - <span class="hljs-number">1</span>] - nums[i] + j);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= mi; ++ k) &#123;<br>            res = (res + dfs(i - <span class="hljs-number">1</span>, k)) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> memo[i][j] = res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>1:1翻译成递推，真的是完全1:1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]dp;<br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countOfPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= nums[<span class="hljs-number">0</span>]; ++ j) &#123;<span class="hljs-comment">//根据dfs初始条件1:1翻译</span><br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= nums[i]; ++ j) &#123;<span class="hljs-comment">//dp[i][j]表示前i个元素，其中arr1的第i位为j，所产生的单调 数组对个数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">mi</span> <span class="hljs-operator">=</span> Math.min(Math.min(j, nums[i - <span class="hljs-number">1</span>]), nums[i - <span class="hljs-number">1</span>] - nums[i] + j);<br>                <span class="hljs-comment">//由于arr1的第i位为j，而限定了arr1的第i-1位的取值范围</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt;= mi; ++ k) &#123;<span class="hljs-comment">//枚举i-1位的每一种可能取值</span><br>                    res = (res + dp[i - <span class="hljs-number">1</span>][k]) % mod;<br>                &#125;<br>                dp[i][j] = res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= nums[n - <span class="hljs-number">1</span>]; ++ i) &#123;<br>            ans = (ans + dp[n - <span class="hljs-number">1</span>][i]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>前缀和优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> [][]dp;<br>    <span class="hljs-type">int</span> []nums;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000_007</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countOfPairs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Arrays.stream(nums).max().getAsInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>][max + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= nums[<span class="hljs-number">0</span>]; ++ j) &#123;<span class="hljs-comment">//根据dfs初始条件1:1翻译</span><br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; ++ i) &#123;<br>            <span class="hljs-type">int</span> []preS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>];<br>            preS[<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; x &lt;= nums[i - <span class="hljs-number">1</span>]; ++ x) &#123;<br>                preS[x] = (preS[x - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][x]) % mod;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= nums[i]; ++ j) &#123;<span class="hljs-comment">//dp[i][j]表示前i个元素，其中arr1的第i位为j，所产生的单调 数组对个数</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">mi</span> <span class="hljs-operator">=</span> Math.min(Math.min(j, nums[i - <span class="hljs-number">1</span>]), nums[i - <span class="hljs-number">1</span>] - nums[i] + j);<br>                <span class="hljs-comment">// int res = 0;</span><br>                <span class="hljs-comment">// 由于arr1的第i位为j，而限定了arr1的第i-1位的取值范围</span><br>                <span class="hljs-comment">// for (int k = 0; k &lt;= mi; ++ k) &#123;//枚举i-1位的每一种可能取值</span><br>                <span class="hljs-comment">//     res = (res + dp[i - 1][k]) % mod;</span><br>                <span class="hljs-comment">// &#125;</span><br>                dp[i][j] = mi &gt;= <span class="hljs-number">0</span> ? preS[mi] : <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= nums[n - <span class="hljs-number">1</span>]; ++ i) &#123;<br>            ans = (ans + dp[n - <span class="hljs-number">1</span>][i]) % mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty实现RPC框架实战</title>
    <link href="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/"/>
    <url>/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h3 id="深入Netty"><a href="#深入Netty" class="headerlink" title="深入Netty"></a>深入Netty</h3><h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><p>Netty并未使用NIO中的ByteBuffer来作为缓冲区，而是自定义了一个ByteBuf，相比于ByteBuffer有如下区别：</p><ul><li>写操作完成后无需filp</li><li>比ByteBuffer响应更快</li><li>动态扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractByteBuf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteBuf</span> &#123;<br>    ...<br>    <span class="hljs-type">int</span> readerIndex;   <span class="hljs-comment">//index被分为了读和写，是两个指针在同时工作</span><br>    <span class="hljs-type">int</span> writerIndex; <span class="hljs-comment">//双指针取代position指针，无需flip将position置0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> markedReaderIndex;    <span class="hljs-comment">//mark操作也分两种</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> markedWriterIndex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxCapacity;    <span class="hljs-comment">//最大容量，没错，这玩意能动态扩容</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> Unpooled.buffer(<span class="hljs-number">10</span>); <span class="hljs-comment">//非池化缓冲区</span><br><span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> PooledByteBufAllocator.DEFAULT;<span class="hljs-comment">//池化技术可以复用buffer</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> allocator.buffer(<span class="hljs-number">256</span>);<br>byteBuf.writeBytes(<span class="hljs-string">&quot;abcdefgrfrfrf&quot;</span>.getBytes()); <span class="hljs-comment">//超过缓冲区大小动态扩容，先到64，之后再每次X2</span><br></code></pre></td></tr></table></figure><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>零拷贝允许在计算机内部传输数据时快速高效地将数据从文件系统移动到网络接口，避免将数据从一个存储区域复制到另一个存储区域，从而减少 CPU 负载和内存带宽的消耗。</p><p>其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，程序很容易不稳定，常常把系统搞崩溃，比如清除操作系统的内存数据。实际上让应用程序随便访问内存真的太危险了，于是就按照CPU 指令的重要程度对指令进行了分级，指令分为四个级别：Ring0 ~ Ring3，Linux 下只使用了 Ring0 和 Ring3 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。</p><p><img src="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png"></p><p>比如Java创建线程，实际上是通过调用本地方法<code>private native void start0();</code>来启动线程，它使用 JNI 调用操作系统的线程创建函数 <code>CreateThread</code> （这个就叫系统调用），这个过程就涉及到用户态到内核态的切换，操作系统内核负责分配资源（如栈、线程控制块等），并将新线程加入调度队列。</p><p>我们的文件操作也是如此，操作系统帮我们从磁盘读取到文件中的数据发给网络，流程如下</p><p><img src="/2024/07/03/Netty%E5%AE%9E%E7%8E%B0RPC%E6%A1%86%E6%9E%B6%E5%AE%9E%E6%88%98/%E6%96%87%E4%BB%B6IO.png"></p><p>DMA控制器就是Direct Memory Access，CSGO经常听到的DMA硬件外挂就是通过FPGA硬件设备直接访问内存，修改内存数据达到控制游戏操作的效果。图中经历了两次CPU拷贝两次DMA拷贝，拷贝略多，可以使用零拷贝优化。</p><p><strong>使用零拷贝技术</strong></p><ul><li><p><strong>mmap&#x2F;munmap</strong>：通过内存映射文件，可以将文件内容映射到进程的地址空间，这样读写文件就像读写内存一样，无需经过用户态的缓冲区。</p></li><li><p><strong>sendfile</strong>：系统调用 <code>sendfile</code> 允许直接将数据从一个文件描述符传输到另一个文件描述符（例如，从文件到网络套接字），避免在用户态和内核态之间进行数据拷贝。在内核空间中直接由CPU把数据拷贝到Socket。</p></li><li><p><strong>虚拟内存</strong>：现在的操作系统基本都是支持虚拟内存的，我们可以让内核空间和用户空间的虚拟地址指向同一个物理地址，这样就相当于是直接共用了这一块区域，也就谈不上拷贝操作了：</p></li></ul><h3 id="基于Netty的RPC框架"><a href="#基于Netty的RPC框架" class="headerlink" title="基于Netty的RPC框架"></a>基于Netty的RPC框架</h3><h4 id="NettyServer和NettyClient"><a href="#NettyServer和NettyClient" class="headerlink" title="NettyServer和NettyClient"></a>NettyServer和NettyClient</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcServer</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyServer.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.INFO))<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonDecoder</span>())<br>                                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSerializer</span>()))<br>                                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                        &#125;<br>                    &#125;)<br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> bootstrap.bind(port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RpcClient</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyClient.class);<br><br>    <span class="hljs-keyword">private</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Bootstrap bootstrap;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyClient</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>.host = host;<br>        <span class="hljs-built_in">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123; <span class="hljs-comment">//在静态代码块中先配置好客户端</span><br>        bootstrap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>        bootstrap.group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>        .channel(NioSocketChannel.class)<br><br>        .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonDecoder</span>())<br>                        .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonEncoder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonSerializer</span>()))<br>                        .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>());<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">sendRequest</span><span class="hljs-params">(RpcRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> bootstrap.connect(host, port).sync();<br>            logger.info(<span class="hljs-string">&quot;客户端连接到服务器：&#123;&#125;，&#123;&#125;&quot;</span>, host, port);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> future.channel();<br>            <span class="hljs-keyword">if</span> (channel.isActive()) &#123;<br>                channel.writeAndFlush(request).addListener(future1 -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (future1.isSuccess()) &#123;<br>                        logger.info(<span class="hljs-string">&quot;客户端发送消息：&#123;&#125;&quot;</span>, request.toString());<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        logger.error(<span class="hljs-string">&quot;发送消息时有错误发生，&#123;&#125;&quot;</span>, future1.cause().getMessage());<br>                    &#125;<br>                &#125;);<br>            &#125;<br>            <span class="hljs-comment">//阻塞等待直到channel关闭</span><br>            channel.closeFuture().sync();<br>            AttributeKey&lt;RpcResponse&gt; attributeKey = AttributeKey.valueOf(<span class="hljs-string">&quot;rpcResponse&quot;</span>);<br>            <span class="hljs-type">RpcResponse</span> <span class="hljs-variable">rpcResponse</span> <span class="hljs-operator">=</span> channel.attr(attributeKey).get();<br>            <span class="hljs-keyword">return</span> rpcResponse.getData();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;发送消息时有错误发生：&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编码与解码"><a href="#编码与解码" class="headerlink" title="编码与解码"></a>编码与解码</h4><p>首先自定义通信协议</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">魔数（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|数据包类型（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|序列化器类型（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|消息长度（<span class="hljs-built_in">int</span>）<span class="hljs-number">4</span>字节|消息体<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span> &#123; <span class="hljs-comment">//编码器</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAGIC_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xCAFEBABE</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CommonSerializer serializer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommonEncoder</span><span class="hljs-params">(CommonSerializer serializer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serializer = serializer;<br>    &#125;<br><br>    <span class="hljs-comment">//自定义协议：魔数（int）4字节|数据包类型|序列化器类型|消息长度|消息体</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Object o, ByteBuf byteBuf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        byteBuf.writeInt(MAGIC_NUMBER);<br>        <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> RpcRequest) &#123;<br>            byteBuf.writeInt(PackageType.REQUEST_PACK.getCode());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            byteBuf.writeInt(PackageType.RESPONSE_PACK.getCode());<br>        &#125;<br>        byteBuf.writeInt(serializer.getCode());<br>        <span class="hljs-type">byte</span>[] bytes = serializer.serialize(o);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> bytes.length;<br>        byteBuf.writeInt(len);<br>        byteBuf.writeBytes(bytes);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CommonDecoder.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAGIC_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">0xCAFEBABE</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">magic</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-keyword">if</span> (magic != MAGIC_NUMBER) &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid magic number! &#123;&#125;&quot;</span>, magic);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_MAGIC_NUMBER);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">packageCode</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        Class&lt;?&gt; packageClass;<br>        <span class="hljs-keyword">if</span> (packageCode == PackageType.REQUEST_PACK.getCode()) &#123;<br>            packageClass = RpcRequest.class;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (packageCode == PackageType.RESPONSE_PACK.getCode()) &#123;<br>            packageClass = RpcResponse.class;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid package type! &#123;&#125;&quot;</span>, packageCode);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_PACK_TYPE);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">serializeCode</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-type">CommonSerializer</span> <span class="hljs-variable">serializer</span> <span class="hljs-operator">=</span> CommonSerializer.getByCode(serializeCode);<br>        <span class="hljs-keyword">if</span> (serializer == <span class="hljs-literal">null</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;Invalid serialize code! &#123;&#125;&quot;</span>, serializeCode);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcException</span>(RpcError.UNKNOWN_SERIAL_CODE);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> byteBuf.readInt();<br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[len];<br>        byteBuf.readBytes(data);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> serializer.deserialize(data, packageClass);<br>        list.add(o);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码器解码器都是继承自<code>ChannelInboundHandlerAdapter</code>入站处理器类。其中解码器继承的ReplayingDecoder是<code>ByteToMessageDecoder</code>的子类，简化了数据解码的逻辑，可以自动处理缓冲区的读取操作，如果数据不足，它会自动暂停解码并等待更多的数据。而<code>ByteToMessageDecoder</code>需要手动检查可读字节，并决定是否有足够的数据来解码一条完整的消息。</p><h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><h5 id="Json序列化器"><a href="#Json序列化器" class="headerlink" title="Json序列化器"></a>Json序列化器</h5><p>基于JSON字符串，占用空间大，速度慢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommonSerializer</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(JsonSerializer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-type">byte</span>[] bytes;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bytes = mapper.writeValueAsBytes(obj);<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Json serialize error&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bytes;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;<br>        Object obj;<br>        <span class="hljs-keyword">try</span> &#123;<br>            obj = mapper.readValue(bytes, clazz);<br>            <span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> RpcRequest) &#123;<br>                obj = handleRequest(obj);<br>            &#125;<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Json deserialize error&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解决反序列化RpcRequest的Object[] params数组中的元素前后不一致的问题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> obj</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">rpcRequest</span> <span class="hljs-operator">=</span> (RpcRequest) obj;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rpcRequest.getParamTypes().length; i ++) &#123;<br>            Class&lt;?&gt; clazz = rpcRequest.getParamTypes()[i];<br>            <span class="hljs-keyword">if</span>(!clazz.isAssignableFrom(rpcRequest.getParams()[i].getClass())) &#123;<br>                <span class="hljs-type">byte</span>[] bytes = mapper.writeValueAsBytes(rpcRequest.getParams()[i]);<br>                rpcRequest.getParams()[i] = mapper.readValue(bytes, clazz);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rpcRequest;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SerializerCode.JSON_SERIALIZER.getCode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RpcRequest 反序列化时，由于其中有一个字段是 Object 数组，在反序列化时序列化器会根据字段类型进行反序列化，而 Object 就是一个十分模糊的类型，会出现反序列化失败的现象, 通常会直接反序列化成string类型：</p><p>客户端日志：</p><blockquote><p>[com.fu1sh.rpc.client.NettyClient]-客户端发送消息：RpcRequest(interfaceName&#x3D;com.fu1sh.rpc.api.Animal, methodName&#x3D;eat, params&#x3D;[<strong>Food</strong>(name&#x3D;猪食, price&#x3D;30)], paramTypes&#x3D;[class com.fu1sh.rpc.api.Food])</p></blockquote><p>服务端日志：可见反序列化搞丢了Food类型</p><blockquote><p>[com.fu1sh.rpc.handler.NettyServerHandler]-接收到客户端请求：RpcRequest(interfaceName&#x3D;com.fu1sh.rpc.api.Animal, methodName&#x3D;eat, params&#x3D;[{name&#x3D;猪食, price&#x3D;30}], paramTypes&#x3D;[class com.fu1sh.rpc.api.Food])</p></blockquote><p>这时就需要 RpcRequest 中的另一个字段 ParamTypes 来获取到 Object 数组中的每个实例的实际类，辅助反序列化。</p><h5 id="Kryo序列化器"><a href="#Kryo序列化器" class="headerlink" title="Kryo序列化器"></a>Kryo序列化器</h5><p>基于字节，空间利用率高；序列化时记录属性对象的类型信息</p><p>kryo使用 Input 和 Output 类来操作数据进出Kryo， 这些类并不是线程安全的。所以通常使用ThreadLocal来为每个需要序列化操作的线程存储一个kryo变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>    <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>    kryo.register(RpcRequest.class);<br>    kryo.register(RpcResponse.class);<br>    <span class="hljs-keyword">return</span> kryo;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(baos)) &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>        kryo.writeObject(output, obj);<br>        kryoThreadLocal.remove(); <span class="hljs-comment">//移除当前线程kryo局部变量防止内存泄漏</span><br>        <span class="hljs-keyword">return</span> output.toBytes();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;kryo serialize error&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>    <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(bais)) &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> kryo.readObject(input, clazz);<br>        kryoThreadLocal.remove();<br>        <span class="hljs-keyword">return</span> o;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(<span class="hljs-string">&quot;kryo deserialize error&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcClientProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> RpcClient rpcClient;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RpcClientProxy</span><span class="hljs-params">(RpcClient rpcClient)</span> &#123;<br>        <span class="hljs-built_in">this</span>.rpcClient = rpcClient;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">RpcRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcRequest</span>(method.getDeclaringClass().getName(), method.getName()<br>                ,args ,method.getParameterTypes());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.rpcClient.sendRequest(request);<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;clazz&#125;, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理的 <code>invoke</code> 方法封装了对接口方法的调用，将这些调用统一封装成 <code>RpcRequest</code> 对象，然后通过 <code>rpcClient.sendRequest</code> 发送，调用者不需要关注底层实现细节</p><p>动态代理同时提供了灵活性，能够在运行时动态地创建代理对象并处理接口方法的调用，可以方便地扩展和修改请求的处理逻辑，例如在 <code>invoke</code> 方法中添加日志记录、性能监控、权限检查等。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO</title>
    <link href="/2024/07/01/NIO/"/>
    <url>/2024/07/01/NIO/</url>
    
    <content type="html"><![CDATA[<h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><p><strong>同步</strong>（Synchronous）：同步任务按顺序执行，一个任务完成后才开始下一个任务。调用方在等待任务完成时会被阻塞，直到任务结束并返回结果。</p><p><strong>异步</strong>（Asynchronous）：异步任务可以同时执行，不必等待前一个任务完成。调用方在任务开始后立即返回，可以继续执行其他任务，不会被阻塞。结果通常通过回调、事件或Promise等方式处理。</p><h3 id="阻塞、非阻塞"><a href="#阻塞、非阻塞" class="headerlink" title="阻塞、非阻塞"></a>阻塞、非阻塞</h3><p><strong>阻塞</strong>：当一个线程在等待某个条件满足（如I&#x2F;O操作完成、锁释放等）时，它会被挂起（阻塞）并暂停执行，直到条件满足。系统会将其置于等待队列中，直到阻塞条件解除。</p><p><strong>非阻塞</strong>：当一个线程在等待某个条件满足时，它不会被挂起，而是立即返回一个状态（如成功、失败、或需要重试），线程可以继续处理其他任务或尝试再次执行未完成的任务。</p><h3 id="同步阻塞、非阻塞"><a href="#同步阻塞、非阻塞" class="headerlink" title="同步阻塞、非阻塞"></a>同步阻塞、非阻塞</h3><h4 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a><strong>同步阻塞（BIO）</strong></h4><p>以流的方式处理数据，底层是字节流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//socket通信</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port)) &#123;<br>    logger.info(<span class="hljs-string">&quot;服务启动中&quot;</span>);<br>    Socket socket;<br>    <span class="hljs-keyword">while</span> ((socket = serverSocket.accept()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//服务端accept()方法会阻塞等待直到有客户端连接</span><br>        logger.info(<span class="hljs-string">&quot;Accepted connection from &#123;&#125;&quot;</span>, socket.getRemoteSocketAddress());<br>        threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestHandlerThread</span>(socket, requestHandler, serviceRegistry));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    logger.error(<span class="hljs-string">&quot;连接出错了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a><strong>同步非阻塞（NIO）</strong></h4><p>面向数据块</p><h5 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a><strong>buffer</strong></h5><p>一个可以写入数据的内存块，使用缓冲区读写数据遵循以下四个步骤</p><ol><li>写数据</li><li>调用buffer.flip()方法，从写模式切换到读模式</li><li>读数据</li><li>调用buffer.clear()或buffer.compat()方法</li></ol><p><strong>buffer类的一些操作源码：</strong></p><ol><li>初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//调用mark()方法标记position位置，以便之后reset</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//下一个操作的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit; <span class="hljs-comment">//position能到的最大位置，默认是capacity</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br><span class="hljs-comment">//Allocates a new int buffer.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title function_">allocate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> createCapacityException(capacity);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapIntBuffer</span>(capacity, capacity, <span class="hljs-literal">null</span>); <span class="hljs-comment">//返回一个堆缓冲区</span><br>&#125;<br><br><span class="hljs-comment">//Wraps an int array into a buffer.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IntBuffer <span class="hljs-title function_">wrap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> length)</span><br>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapIntBuffer</span>(array, offset, length, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException x) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>put</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> IntBuffer <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br><br>    hb[ix(nextPutIndex())] = x; <span class="hljs-comment">//hb数组position位置赋值为x</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextPutIndex</span><span class="hljs-params">()</span> &#123;                          <span class="hljs-comment">// package-private</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> position;<br>    <span class="hljs-keyword">if</span> (p &gt;= limit)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferOverflowException</span>();<br>    position = p + <span class="hljs-number">1</span>; <span class="hljs-comment">//position加一</span><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>flip</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读之前一定要flip切换到读模式，也就是把position归0（使用wrap创建的buffer不用，因为position为0）</span><br><span class="hljs-keyword">public</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;<br>    limit = position; <span class="hljs-comment">//limit设为最后一个数据位置的下一个位置</span><br>    position = <span class="hljs-number">0</span>; <span class="hljs-comment">//position归0开始读</span><br>    mark = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>clear方法清空缓冲区；compact方法只会清空已读取的数据，而还未读取的数据继续保存在Buffer中；</li></ol><h5 id="channel"><a href="#channel" class="headerlink" title="channel"></a><strong>channel</strong></h5><ul><li>channel可以同时读写，流只能单独读或者写</li><li>channel可以实现异步读写数据</li><li>channel可以从buffer读取数据，也可以写数据到buffer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//RandomAccessFile操作文件，第二个参数mode：</span><br><span class="hljs-comment">// r：只读；rw：读写；rws/rwd：写操作同步刷新到磁盘</span><br><br><span class="hljs-keyword">try</span> (<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span>  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-string">&quot;rw&quot;</span>);<br>    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> raf.getChannel()) &#123;<br><br>    channel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>.getBytes())); <span class="hljs-comment">//读</span><br>    System.out.println(<span class="hljs-string">&quot;After write: position : &quot;</span> + channel.position());<br>    channel.position(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, read));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br></code></pre></td></tr></table></figure><p>channel还有个文件锁的功能，尝试获取与 <code>FileChannel</code> 关联的文件区域的独占或共享锁，shared变量声明是独占还是共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//阻塞式，如果无法立即获取锁（因为其他线程或进程已经持有了锁），那么调用线程会被阻塞</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FileLock <span class="hljs-title function_">lock</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)</span><br><span class="hljs-comment">//非阻塞式，尝试立即获取锁，如果锁不可用则不会阻塞，而是返回 null。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> FileLock <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size, <span class="hljs-type">boolean</span> shared)</span><br></code></pre></td></tr></table></figure><h5 id="selector"><a href="#selector" class="headerlink" title="selector"></a><strong>selector</strong></h5><p>一个组件，可以检测多个NIO channel，看看读或者写事件是否就绪。</p><p>多个Channel以事件的方式可以注册到同一个Selector，从而达到用一个线程处理多个请求成为可能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-comment">//ServerSocketChannel 用于服务端，负责监听和接受连接请求。</span><br><span class="hljs-comment">//SocketChannel 用于客户端或服务端，负责连接和进行数据传输。</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>     <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open()) &#123;<br>    serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>    <span class="hljs-comment">//要使用选择器，必须使用非阻塞方式，这样才不会像阻塞IO一样卡在accept()方法</span><br>    serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>        System.out.println(<span class="hljs-string">&quot;监听到&quot;</span>+ count +<span class="hljs-string">&quot;个事件&quot;</span>);<br>        Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123; <span class="hljs-comment">//如果当前key对应的通道已经做好准备accept</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;客户端连接：&quot;</span> + socketChannel.getRemoteAddress());<br>                <span class="hljs-comment">//将这个连接也注册到选择器</span><br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123; <span class="hljs-comment">//如果当前连接有可读的数据并且可以写，就开始处理</span><br>                <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>                <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>                    byteBuffer.flip();<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, read));<br>                &#125;<br>                socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到&quot;</span>.getBytes()));<br>            &#125;<br>            iterator.remove();<span class="hljs-comment">//调用 iterator.remove() 是为了从 selectedKeys 集合中移除已经处理过的 SelectionKey。如果不移除，下一次循环时这些 SelectionKey 还会被再次处理，可能会导致重复处理同一个事件。</span><br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span><br>     SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>));<br>     <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in)) &#123;<br>    System.out.println(<span class="hljs-string">&quot;已连接服务器！&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;请输入发送的内容：&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>        socketChannel.write(ByteBuffer.wrap(line.getBytes()));<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        socketChannel.read(buffer);<br>        buffer.flip();<br>        System.out.println(<span class="hljs-string">&quot;收到服务器返回的：&quot;</span>+ <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array(), <span class="hljs-number">0</span>, buffer.limit()));<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="reactor模式"><a href="#reactor模式" class="headerlink" title="reactor模式"></a>reactor模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Reactor，统筹全局</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, Closeable &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = ServerSocketChannel.open();<br>        <span class="hljs-built_in">this</span>.selector = Selector.open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9999</span>));<br>            <span class="hljs-comment">//要使用选择器，必须使用非阻塞方式，这样才不会像阻塞IO一样卡在accept()方法</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>(serverSocketChannel, selector));<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> selector.select();<br>                System.out.println(<span class="hljs-string">&quot;监听到&quot;</span> + count + <span class="hljs-string">&quot;个事件&quot;</span>);<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-built_in">this</span>.dispatch(iterator.next());<span class="hljs-comment">//SelectionKey实际上就是Acceptor或者Handler，这里转发过去调用run方法启动。</span><br>                    iterator.remove();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span> <span class="hljs-params">(SelectionKey key)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> key.attachment();<br>        <span class="hljs-keyword">if</span> (attachment <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>            ((Runnable) attachment).run();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        serverSocketChannel.close();<br>        selector.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Acceptor 负责监听和接收连接请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Acceptor</span><span class="hljs-params">(ServerSocketChannel serverSocketChannel, Selector selector)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverSocketChannel = serverSocketChannel;<br>        <span class="hljs-built_in">this</span>.selector = selector;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>            System.out.println(<span class="hljs-string">&quot;客户端连接：&quot;</span> + socketChannel.getRemoteAddress());<br>            <span class="hljs-comment">//将这个连接也注册到选择器</span><br>            socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            socketChannel.register(selector, SelectionKey.OP_READ, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(socketChannel));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Handler 处理每个客户端连接的任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadPoolExecutor pool;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Handler</span><span class="hljs-params">(SocketChannel socketChannel)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socketChannel = socketChannel;<br>        pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">20</span>,<br>                <span class="hljs-number">60</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">20</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socketChannel.read(byteBuffer);<br>            <span class="hljs-keyword">if</span> (read &lt; <span class="hljs-number">0</span>) &#123;<br>                socketChannel.close();<br>                System.out.println(<span class="hljs-string">&quot;客户端断开连接！&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            pool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (byteBuffer.remaining() == <span class="hljs-number">0</span>) &#123;<br>                        byteBuffer.flip();<br>                        System.out.println(<span class="hljs-string">&quot;线程 &quot;</span>+ Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> +<br>                                <span class="hljs-string">&quot;处理客户端消息： &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(byteBuffer.array(), <span class="hljs-number">0</span>, byteBuffer.remaining()));<br>                        byteBuffer.clear();<br>                    &#125;<br>                    socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;已收到&quot;</span>.getBytes()));<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="主从reactor模式"><a href="#主从reactor模式" class="headerlink" title="主从reactor模式"></a>主从reactor模式</h5><h4 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h4><p>客户端关闭导致服务端空轮询</p><p>粘包拆包问题</p><ul><li>消息定长</li><li>每个包末尾使用特殊分隔符</li><li>将消息分为头部和本体，头部保存数据包的长度</li></ul>]]></content>
    
    
    <categories>
      
      <category>NIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NIO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2024/06/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/29/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p><strong>IPV4</strong></p><p>本机：127.0.0.1</p><p>四个字节，每一字节0~255，42亿种，2011年就用完了</p><p><strong>IPV6</strong></p><blockquote><p>2001:0db8:85a3:0000:0000:8a2e:0370:7334</p></blockquote><p>8个无符号整数组成</p><p>16个字节，地球上每一粒沙子都可以分配一个</p><p><strong>公网&#x2F;私网&#x2F;NAT</strong></p><p>公网ip：互联网（全球唯一）</p><p>私网ip：局域网（常见192.168.）</p><p>NAT（网络地址转换）：当私网内部的设备需要访问互联网时，路由器会将设备的私网IP地址转换为一个公网IP地址，并在返回通信时将其转换回私网IP地址。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口表示计算机上一个程序的进程</p><ul><li><p>不同的进程有不同的端口号，用来区分软件</p></li><li><p>0 ~ 2^16 （65535）个</p></li><li><p>TCP&#x2F;UDP：单个协议下端口号不能相同，TCP和UDP互相不冲突</p></li><li><p>端口分类</p><ul><li><p>公有端口 0 ~ 1023</p><ul><li>HTTP：80</li><li>HTTPS：443</li><li>FTP：21</li></ul></li><li><p>程序注册端口 1024 ~ 49151</p><ul><li>MySQL：3306</li><li>Redis：6379</li></ul></li><li><p>动态端口 49152 ~ 65535</p></li></ul></li></ul><blockquote><p>netstat 查看网络相关信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat //显示所有活动的连接<br>netstat -a //显示所有连接和监听端口<br>netstat -n //以数字形式显示地址和端口号（不进行DNS解析）<br>netstat -o //显示与每个连接相关的进程ID（PID）<br>netstat -p tcp //显示特定协议的连接<br>netstat -tulnp //Linux特有，显示所有连接和监听端口，带PID和程序名<br></code></pre></td></tr></table></figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>打电话，连接，稳定</p><p>客户端、服务端</p><p>传输完成，释放连接，效率低</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>发短信，不连接，不稳定</p><p>客户端服务端没有明确的界限</p><p>不管准备好与否，都可以发给你</p><p>DDOS：洪水攻击</p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解与反射</title>
    <link href="/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>标记某个被注解的东西（类， 方法等），让其他程序根据这个东西上面的注解信息来执行对他的操作</p><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul><li>Target</li></ul><p><img src="/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/Target.png" alt="Target作用域"></p><ul><li>Retention</li></ul><p><img src="/2024/06/28/%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/Retention.png" alt="Retention保留"></p><ul><li>Documented：表示注解是否被 javadoc 工具记录，默认情况下注解是不包含在 javadoc 中的。</li><li>Inherited：表示注解是否可以被继承，默认情况下注解是不会被子类继承的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义注解</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.LOCAL_VARIABLE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Person &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-meta">@Person(age = 20)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>    <span class="hljs-meta">@Person(age = 18, name = &quot;fred&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">eat</span><span class="hljs-params">(String food)</span> &#123;<br>        <span class="hljs-keyword">return</span> food;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Method</span> <span class="hljs-variable">eat</span> <span class="hljs-operator">=</span> test.class.getMethod(<span class="hljs-string">&quot;eat&quot;</span>, String.class); <br>            <span class="hljs-keyword">if</span> (eat.isAnnotationPresent(Person.class)) &#123; <span class="hljs-comment">//判断该元素上是否有Person注解</span><br>                <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> eat.getAnnotation(Person.class);<span class="hljs-comment">//获取方法上的注解</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> person.name();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> person.age();<br>                System.out.println(name + <span class="hljs-string">&quot; &quot;</span> + age);<br>            &#125;<br><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> test.class.getDeclaredField(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">//反射获取字段</span><br>            <span class="hljs-type">Person</span> <span class="hljs-variable">personOnA</span> <span class="hljs-operator">=</span> a1.getAnnotation(Person.class); <br>            System.out.println(personOnA.age());<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | NoSuchFieldException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//junit 源码</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; expected() <span class="hljs-keyword">default</span> None.class;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">None</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">None</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取类的class对象</span><br>Class&lt;?&gt; clazz = MyClass.class;<br><br><span class="hljs-type">MyClass</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>Class&lt;?&gt; clazz = obj.getClass();<br><br>Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.example.MyClass&quot;</span>);<br><br><span class="hljs-comment">// 获取所有公共方法，包括继承的公共方法</span><br>Method[] methods = clazz.getMethods();<br><br><span class="hljs-comment">// 获取所有声明的方法（包括私有），不包括继承的方法</span><br>Method[] declaredMethods = clazz.getDeclaredMethods();<br><br><span class="hljs-comment">// 获取特定参数类型的方法，获取不到私有方法</span><br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;methodName&quot;</span>, String.class);<br><br><span class="hljs-comment">// 获取字段</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;fieldName&quot;</span>);<br><br><span class="hljs-comment">// 获取字段的值</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> field.get(obj);<br><br><span class="hljs-comment">// 设置字段的值</span><br>field.set(obj, <span class="hljs-string">&quot;newValue&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2024/06/26/JVM/"/>
    <url>/2024/06/26/JVM/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><p><img src="/2024/06/26/JVM/jvm%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="JVM体系结构"></p><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123; <span class="hljs-comment">//构造方法也是方法，存储在方法区</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wolf</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//方法区</span><br>        System.out.println(name + <span class="hljs-string">&quot; age &quot;</span> + age + <span class="hljs-string">&quot; wolf&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;fred&quot;</span>, <span class="hljs-number">23</span>);<br>        dog.wolf();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码运行时，JVM各区域存储的信息</p><p><img src="/2024/06/26/JVM/jvm%E5%AE%9E%E4%BE%8B.png" alt="JVM实例"></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区</strong>是Java虚拟机规范（JVM Specification）中定义的逻辑部分。<strong>永久代</strong>（Permanent Generation，PermGen）是HotSpot JVM在Java 8之前对方法区的具体实现。<strong>元空间</strong>（Metaspace）是Java 8及以后版本中对方法区的新的实现，取代了永久代。</p><p>被所有线程共享，存储静态变量，常量（final），常量池（包括字符串常量和基本类型常量），类信息（类的名称、父类、接口、字段、方法等）</p><h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>存储对象的引用、方法调用相关的信息（局部变量、操作数栈、返回地址等），管理简单，速度快，但空间有限，生命周期短。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p><img src="/2024/06/26/JVM/%E5%A0%86%E5%86%85%E5%AD%98.png" alt="堆内存示意图"></p><blockquote><p>使用VM options调整JVM启动参数</p></blockquote><p><strong>堆内存大小配置</strong>：</p><ul><li><code>-Xms</code>：设置JVM堆内存的初始大小。</li><li><code>-Xmx</code>：设置JVM堆内存的最大大小。</li></ul><p><strong>年轻代和老年代的比例</strong>：</p><ul><li><code>-XX:NewRatio</code>：这个参数用于设置老年代与年轻代的比例。默认值通常为2，即老年代大小是年轻代的两倍。比如，如果设置为<code>-XX:NewRatio=3</code>，则老年代大小是年轻代的三倍。</li><li><code>-XX:MaxNewSize</code>：设置年轻代的最大大小。</li><li><code>-XX:NewSize</code>：设置年轻代的初始大小。</li></ul><p><strong>查看GC详细参数</strong>：</p><ul><li><code>-XX:+PrintGCDetails</code></li></ul><p><strong>使用jprofiler查看heap dump文件</strong>：</p><ul><li><code>-XX:+HeapDumpOnOutOfMemoryError</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">totalMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory();<br>        System.out.println(totalMemory + <span class="hljs-string">&quot;-&gt;&quot;</span> + totalMemory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;mb&quot;</span>);<br>        System.out.println(maxMemory + <span class="hljs-string">&quot;-&gt;&quot;</span> + maxMemory / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;mb&quot;</span>);<br><br>        List&lt;HeapTest&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapTest</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/06/26/JVM/heapDump.png" alt="jProfiler可以看到ArrayList被撑爆了"></p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>​引用计数算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为该对象不再被使用，是“垃圾”了。</p><ul><li>缺点：每次对对象赋值时均要更新计数器，且计数器本身也占用内存，故jdk1.1已弃用</li></ul><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p><strong>Eden区</strong>：</p><ul><li>Eden区是新对象最初分配的地方。</li><li>当Eden区满时，会触发一次Minor GC（新生代的垃圾收集）。</li><li>在Minor GC过程中，复制算法会将存活的对象复制到Survivor区的一个空闲区域（一般是To区）。</li></ul><p><strong>Survivor区</strong>：</p><ul><li>在Minor GC过程中，存活的对象会从Eden区和From区复制到To区。</li><li>每次Minor GC后，From区和To区的角色会互换，即To区变为新的From区，From区变为空闲区（To）。</li></ul><p>优点：无内存碎片，内存效率高，时间复杂度低</p><p>缺点：需要一片额外空白内存空间，内存利用率低</p><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>​为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 <code>GC</code> 操作。</p><p>优点：内存利用率高</p><p>缺点：每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，内存碎片多</p><h4 id="标记-整理-压缩算法（Mark-Compact）"><a href="#标记-整理-压缩算法（Mark-Compact）" class="headerlink" title="标记-整理&#x2F;压缩算法（Mark-Compact）"></a>标记-整理&#x2F;压缩算法（Mark-Compact）</h4><p>标记阶段：与标记-清除算法类似，标记出所有活动对象。</p><p>整理阶段：将所有存活的对象向一端移动，然后清理掉端边界以外的内存。</p><p>优缺点：相比标记-清除算法，减少了内存碎片的产生，但是移动对象可能会增加算法的复杂性和执行时间。</p><blockquote><p>GC：分代收集算法</p></blockquote><p>即新生代的对象存活率低，使用复制算法，老年代存活率高，内存区域大，使用标记清除 + 标记压缩算法（先使用标记清除，内存碎片多到一定量就压缩清除一次）</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>后台运行</strong>：守护线程通常用于在后台执行辅助任务，例如垃圾收集、日志记录、监控等。</p><p><strong>生命周期依赖于非守护线程</strong>：当所有非守护线程结束时，JVM会终止所有仍在运行的守护线程并退出。</p><p><strong>低优先级</strong>：通常守护线程的优先级较低，因为它们的任务不如用户线程（非守护线程）重要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;我是守护线程&quot;</span> + Thread.currentThread().getName());<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;DaemonThread&quot;</span>);<br><br>    thread.setDaemon(<span class="hljs-literal">true</span>);<br>    thread.start();<br><br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    System.out.println(<span class="hljs-string">&quot;我是主线程，我即将退出&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">我是守护线程DaemonThread<br>我是守护线程DaemonThread<br>我是守护线程DaemonThread<br>我是主线程，我即将退出<br></code></pre></td></tr></table></figure><p>守护线程适用于以下场景：</p><ol><li><strong>垃圾收集器</strong>：JVM自带的垃圾收集线程就是一个守护线程，用于在后台清理不再使用的对象。</li><li><strong>日志记录</strong>：在后台记录应用程序的运行日志。</li><li><strong>监控</strong>：用于监控应用程序的状态，例如资源使用情况、性能指标等。</li></ol><h3 id="类加载器-双亲委派机制"><a href="#类加载器-双亲委派机制" class="headerlink" title="类加载器&#x2F;双亲委派机制"></a>类加载器&#x2F;双亲委派机制</h3><ul><li>Bootstrap ClassLoader ：jre&#x2F;lib</li><li>ExtClassLoader ： jre&#x2F;lib&#x2F;ext下的jar</li><li>AppClassLoader ： 加载用户路径ClassPath下的包</li><li>自定义类加载器 ： 加载用户自定义路径下的包</li></ul><blockquote><p>双亲委派机制：先自底向上检查是否已经加载，若未加载则从Bootstrap开始往下查看自己是否可以加载，若失败则抛出ClassNotFoundException</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">//              -----??-----</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve)<br>    <span class="hljs-keyword">throws</span> ClassNotFoundException<br>&#123;<br>        <span class="hljs-comment">// 首先，检查是否已经被类加载器加载过</span><br>        Class&lt;?&gt; c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 存在父加载器，递归的交由父加载器</span><br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                    c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 直到最上面的Bootstrap类加载器</span><br>                    c = findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span><br>                <span class="hljs-comment">// from the non-null parent class loader</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                <span class="hljs-comment">// to find the class.即首先Bootstrap findClass -&gt; ExtClassLoader -&gt; AppClassLoader</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>jar tf rt.jar</code>查看jdk8&#x2F;jre&#x2F;lib下的rt.jar包（bootstrap加载器加载的类库）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">java/lang/Exception.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/ThreadDeath.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Error.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Throwable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/System.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/ClassLoader.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Cloneable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/Type.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/AnnotatedElement.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/reflect/GenericDeclaration.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Class.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/CharSequence.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Comparable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/io/Serializable.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/String.<span class="hljs-keyword">class</span><br><span class="hljs-title class_">java</span>/lang/Object.class<br></code></pre></td></tr></table></figure><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>native方法是用C和C++编写的底层方法，Java调用native方法的线程会进入该线程的本地方法栈，调用本地方法接口JNI</p><p>扩展Java的使用，融合不同的语言为Java使用</p><p>在内存中专门开辟的一片区域，本地方法栈，登记native方法</p><p>在JVM中，每个线程都有自己的本地方法栈，用于存储该线程的本地方法调用。当Java线程调用一个本地方法时：</p><ol><li>JVM创建一个新的本地方法栈帧并将其推入该线程的本地方法栈。</li><li>该线程在本地方法栈帧中执行本地代码。</li><li>执行完成后，JVM将结果返回给Java代码，栈帧被移出本地方法栈。</li></ol><p>这种设计确保了每个线程都有自己的本地方法调用栈帧，不会与其他线程的本地方法调用混淆，从而保证了线程安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>; <span class="hljs-comment">//Thread类通过本地方法start0启动线程</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2024/06/22/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/06/22/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><p>虽然在学习CS61B的时候自己动手写了一个简易版的HashMap，但是跟实际的完全没有可比性，最近开始深入底层，遂记录。</p><h3 id="初始参数"><a href="#初始参数" class="headerlink" title="初始参数"></a>初始参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<span class="hljs-comment">//转红黑树阈值，链表中元素大于此就将其转为红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; <span class="hljs-comment">//树转链表阈值，树中元素低于此就转为链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>; <span class="hljs-comment">//整个表中元素超过该值时才可以开启树形化操作 ？？？？还是数组长度？？？</span><br></code></pre></td></tr></table></figure><h3 id="初始方法"><a href="#初始方法" class="headerlink" title="初始方法"></a>初始方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// &gt;&gt;&gt;表示无符号右移</span><br><span class="hljs-comment">// 对key的hashCode右移16位再异或，可以增加hash的复杂度，降低hash冲突的概率</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br><span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br><span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* onlyIfAbsent:默认为false，表示若key相同，用新值覆盖旧值</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-comment">//第一次插入元素，初始化，HashMap为了节约内存在使用时才初始化数组</span><br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>    <span class="hljs-comment">//路由地址算法，即hash % n，这里n为数组长度，始终是2的幂，故可以用位运算来优化</span><br>    <span class="hljs-comment">//数组该地址对应的节点为空，创建一个新节点即可</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">//当前节点就是目标节点</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-comment">//没找到目标节点，且当前节点是红黑树节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-comment">//当前节点是普通链表节点</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-comment">//尾插法</span><br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-comment">//找到目标节点，立即break;</span><br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//存在key对应的mapping</span><br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-comment">// 覆盖旧值</span><br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * newCap: the new capacity, MUST be a power of two</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;   <span class="hljs-comment">// 获取旧表</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;  <span class="hljs-comment">// 获取旧表的容量old capacity</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;  <span class="hljs-comment">// 获取旧的扩容阈值</span><br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果旧表的容量大于0</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">// 如果旧容量已经达到最大容量</span><br>            threshold = Integer.MAX_VALUE;  <span class="hljs-comment">// 将阈值设置为最大值</span><br>            <span class="hljs-keyword">return</span> oldTab;  <span class="hljs-comment">// 返回旧表</span><br>        &#125;<br>        newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 新容量是旧容量的两倍</span><br>        <span class="hljs-keyword">if</span> (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// 新的扩容阈值也是旧阈值的两倍</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        newCap = oldThr;  <span class="hljs-comment">// 如果旧容量为0但旧阈值大于0，设置新容量为旧阈值</span><br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// oldThr == 0 &amp;&amp; oldCap == 0 此为第一次初始化map时的操作</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;  <span class="hljs-comment">// 设置新容量为默认初始容量</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  <span class="hljs-comment">// 设置新的扩容阈值 16 * 0.75 = 12</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;  <span class="hljs-comment">// 更新阈值</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];  <span class="hljs-comment">// 创建新表</span><br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果旧表不为空</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;  <span class="hljs-comment">// 遍历旧表中的每个桶</span><br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果当前桶不为空</span><br>                oldTab[j] = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 释放旧表中的引用，帮助垃圾回收</span><br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)  <span class="hljs-comment">// 如果当前桶中只有一个节点</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;  <span class="hljs-comment">// 直接将节点放到新表中的相应位置</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)  <span class="hljs-comment">// 如果当前桶是树节点</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);  <span class="hljs-comment">// 调用split方法，将树节点拆分并放到新表中</span><br>                <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果当前桶是链表节点，按位重新分配</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 低位链表的头尾节点</span><br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 高位链表的头尾节点</span><br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;  <span class="hljs-comment">// 记录下一个节点</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果哈希值与旧容量按位与为0，放到低位链表</span><br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则放到高位链表</span><br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 遍历整个链表</span><br><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果低位链表不为空</span><br>                        loTail.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 终止链表</span><br>                        newTab[j] = loHead;  <span class="hljs-comment">// 将低位链表放到新表中的相应位置</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 如果高位链表不为空</span><br>                        hiTail.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 终止链表</span><br>                        newTab[j + oldCap] = hiHead;  <span class="hljs-comment">// 将高位链表放到新表中的相应位置</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;  <span class="hljs-comment">// 返回新表</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="为什么都要比较两次？"><a href="#为什么都要比较两次？" class="headerlink" title="为什么都要比较两次？"></a>为什么都要比较两次？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先用&#x27;==&#x27;比较key对象的内存地址，如果地址相同则肯定是同一个对象</span><br><span class="hljs-comment">// 如果不是同一个对象，再用&#x27;equals&#x27;比较对象的内容，如果内容相同</span><br>(k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))<br>(v = e.value) == value || (value != <span class="hljs-literal">null</span> &amp;&amp; value.equals(v)) <span class="hljs-comment">//containsValue方法</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC并发编程</title>
    <link href="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC并发编程"><a href="#JUC并发编程" class="headerlink" title="JUC并发编程"></a>JUC并发编程</h1><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>一个程序，wechat.exe。每个进程都有自己独立的一块内存空间</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>进程中的一个执行任务，同类的多个线程共享进程的堆区和方法区，每个线程有独立的PC，虚拟机栈和本地方法栈</p><p>java是不能开启线程的，Thread的start()方法通过调用本地方法<code>private native void start0();</code>来启动线程。</p><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">NEW, <span class="hljs-comment">//新创建了一个线程对象，但还没有调用start()方法。</span><br><br>RUNNABLE,<span class="hljs-comment">//Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</span><br><br>BLOCKED,<span class="hljs-comment">//表示线程阻塞于锁。</span><br><br>WAITING,<span class="hljs-comment">//进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</span><br><br>TIMED_WAITING,<span class="hljs-comment">//该状态不同于WAITING，它可以在指定的时间后自行返回。</span><br><br>TERMINATED;<span class="hljs-comment">//表示该线程已经执行完毕。</span><br></code></pre></td></tr></table></figure><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default priority that is assigned to a thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum priority that a thread can have.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPriority</span><span class="hljs-params">(<span class="hljs-type">int</span> newPriority)</span> &#123; <span class="hljs-comment">// source code</span><br>    ThreadGroup g;<br>    checkAccess();<br>    <span class="hljs-keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>((g = getThreadGroup()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;<br>            newPriority = g.getMaxPriority();<br>        &#125;<br>        setPriority0(priority = newPriority);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>CPU一核，快速交替执行多个线程 操作同一个资源</p><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>CPU多核同时执行多个线程</p><h3 id="synchronized和Lock的区别"><a href="#synchronized和Lock的区别" class="headerlink" title="synchronized和Lock的区别"></a>synchronized和Lock的区别</h3><p>1、synchronized是Java内置关键字，Lock是类</p><p>2、synchronized无法判断获取锁的状态，Lock可以</p><p>3、synchronized会自动释放锁，Lock必须手动释放，否则会<strong>死锁</strong></p><p>4、synchronized未获取到锁的线程会一直等待，Lock锁不一定会一直等待下去</p><p>5、synchronized可重入锁，不可以中断，非公平；Lock可重入锁，不可以中断，可设置公平与否</p><p>6、synchronized适合锁少量代码块，Lock适合锁大量同步代码</p><p>7、synchronized只能锁类对象和普通对象，Lock可以锁任意的共享资源</p><blockquote><p>可重入锁：synchronized， ReentrantLock，同一线程可以多次获取同一把锁</p></blockquote><ul><li>方法A需要调用方法B，方法A需要先获取锁，执行到调用B时方法B同样需要获取同一把锁，可重入锁保证了线程可以在方法B中继续获取这同一把锁。不可重入锁则会导致线程在方法B中阻塞等待。</li></ul><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="synchronized锁版本"><a href="#synchronized锁版本" class="headerlink" title="synchronized锁版本"></a>synchronized锁版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pc</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> food;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (food != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为了防止虚假唤醒，需要将wait函数放在while循环中，而不能用if</span><br>            <span class="hljs-built_in">this</span>.wait();<br>        &#125;<br>        food ++;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (food == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.wait();<br>        &#125;<br>        food --;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>        <span class="hljs-built_in">this</span>.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock锁版本"><a href="#Lock锁版本" class="headerlink" title="Lock锁版本"></a>Lock锁版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pc</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> food;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (food != <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            food ++;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (food == <span class="hljs-number">0</span>) &#123;<br>                condition.await();<br>            &#125;<br>            food --;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;&quot;</span> + food);<br>            condition.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h3><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//源码，add方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            Object[] es = getArray(); <span class="hljs-comment">//拿到原始array</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> es.length;<br>            es = Arrays.copyOf(es, len + <span class="hljs-number">1</span>);<br>            es[len] = e;<br>            setArray(es); <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">/** The array, accessed only via getArray/setArray. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Object[] array;<br></code></pre></td></tr></table></figure><p>通过自定义一个lock对象，更加精细地控制同步，CopyOnWriteArrayList中的所有同步方法（mutators）都需要先获取这把锁才能执行操作，如上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The lock protecting all mutators.  (We have a mild preference</span><br><span class="hljs-comment">* for builtin monitors over ReentrantLock when either will do.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br></code></pre></td></tr></table></figure><h4 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h4><p>和上面一样，底层是CopyOnWriteArrayList，使用CopyOnWriteArrayList的addIfAbsent方法来添加新元素并去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the element, if not present.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this list, if absent</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if the element was added</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addIfAbsent</span><span class="hljs-params">(E e)</span> &#123;<br>    Object[] snapshot = getArray();<br>    <span class="hljs-keyword">return</span> indexOfRange(e, snapshot, <span class="hljs-number">0</span>, snapshot.length) &lt; <span class="hljs-number">0</span> <span class="hljs-comment">//indexOfRange查找当前数组范围内要新增的元素e是否存在，不存在返回-1，可以add</span><br>        &amp;&amp; addIfAbsent(e, snapshot);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 题外话：HashSet底层是什么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a new, empty set; the backing &#123;<span class="hljs-doctag">@code</span> HashMap&#125; instance has</span><br><span class="hljs-comment">    * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>       map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>   &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>       <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-literal">null</span>;<br>   &#125;<br><br>   <span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code> 通过分段锁（Segment）和 CAS 操作保证了并发访问的安全性。每个 Segment 类似于一个小的 <code>HashMap</code>，它们分别维护桶数组的一部分，减少了锁的粒度，提高了并发访问性能。</p><p>CAS操作的一个弊端就是成功率太低了，通过分段锁的思想可以提高每一段的成功率，从而提高整体的成功率。</p><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  CountDownLatch 减法计数器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 离开&quot;</span>);<br>                countDownLatch.countDown();  <span class="hljs-comment">// 每个工作线程执行完成后调用countDown()方法，减少计数器</span><br>            &#125;, String.valueOf(i)).start();<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch.await();<span class="hljs-comment">// 主线程等待所有工作线程完成</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;关门&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CyclicBarrier 加法计数器</span><br><span class="hljs-comment">// 构造方法：public CyclicBarrier(int parties, Runnable barrierAction)</span><br><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">7</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;开启大门&quot;</span>))); <br><span class="hljs-comment">// 7: 指定需要同步等待的线程数量，即到达屏障点的线程数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 阻塞&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                cyclicBarrier.await(); <span class="hljs-comment">// 当线程调用 await() 方法时，它会被阻塞，直到所有线程都调用了await() 方法，然后屏障会开放，启动自定义的线程执行相应操作</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;).start();<br></code></pre></td></tr></table></figure><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Semaphore 信号量限流</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 抢到车位！&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + finalI + <span class="hljs-string">&quot; 离开！&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br></code></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>相比于传统队列，阻塞队列引入了两组新的添加删除操作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 队满则阻塞等待，一直等待直到空出位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       Objects.requireNonNull(e);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>       lock.lockInterruptibly();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == items.length)<br>               notFull.await();<br>           enqueue(e);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 队空阻塞等待，一直等待</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>       lock.lockInterruptibly();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>               notEmpty.await();<br>           <span class="hljs-keyword">return</span> dequeue();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           lock.unlock();<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 重载了offer方法，阻塞等待指定时间，超时则自动结束程序</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br><span class="hljs-comment">// 重载了poll方法</span><br>E <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><blockquote><p>同步队列 <code>SynchronousQueue</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">BlockingQueue&lt;String&gt; synchronousQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><span class="hljs-comment">//1.生产者-消费者模式</span><br><span class="hljs-comment">//2.线程池任务提交</span><br><span class="hljs-comment">//3.运行时任务交换</span><br><span class="hljs-comment">//4.负载均衡</span><br></code></pre></td></tr></table></figure><h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>相比于Runnable，多了一个返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(thread);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;A&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask, <span class="hljs-string">&quot;B&quot;</span>).start();<br>    System.out.println(futureTask.get());<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running。。。&quot;</span>);<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;call() called&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="阿里开发手册-线程池的创建"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">2</span>, <span class="hljs-comment">// corePoolSize</span><br>        <span class="hljs-number">5</span>, <span class="hljs-comment">// maximumPoolSize</span><br>        <span class="hljs-number">5L</span>, <span class="hljs-comment">// keepAliveTime</span><br>        TimeUnit.SECONDS, <span class="hljs-comment">// java.util.concurrent.TimeUnit unit</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">3</span>), <span class="hljs-comment">// 阻塞队列</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略</span><br>);<br><br><span class="hljs-comment">// 拒绝策略：线程数超过maximumPoolSize + BlockingQueue的size时</span><br>AbortPolicy(): 抛出异常`java.util.concurrent.RejectedExecutionException`<br>CallerRunsPolicy(): 交给调用execute方法的线程执行<br>DiscardPolicy(): 默默丢弃被拒绝的任务<br>DiscardOldestPolicy(): 丢弃最旧的未处理任务，然后尝试执行被拒绝的这个任务<br>    <br><span class="hljs-comment">// maximumPoolSize设置原则</span><br><span class="hljs-comment">// CPU密集型：maximumPoolSize = Runtime.getRuntime.availableProcessors() + 1; 加一是为了确保某些线程在等待时，仍有线程可以执行任务</span><br><span class="hljs-comment">// IO密集型：大一点，大于那些十分耗IO的线程数</span><br>    <br>  <br><span class="hljs-comment">//ThreadPoolExecutor的执行方法</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span>; <br>Future&lt;?&gt; submit(Runnable task) <span class="hljs-comment">//有返回值，future。通过Future的get()方法同步等待线程执行完成返回</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br>&lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure><ul><li><p>corePoolSize: 线程池中保持存活的核心线程数，即使这些线程是空闲的也不会被回收。</p></li><li><p>maximumPoolSize: 线程池中允许的最大线程数。当任务的数量超过 <code>corePoolSize</code> 并且阻塞队列已满时，如果线程数量没有达到 <code>maximumPoolSize</code>，线程池会创建新的线程来执行任务。</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过 <code>corePoolSize</code> 时，多余的空闲线程在超过 <code>keepAliveTime</code> 时间后将被终止回收。这一参数仅在线程数大于 <code>corePoolSize</code> 时才会生效。</p></li><li><p>workQueue: 阻塞队列</p></li><li><p>handler: 任务数量超过 <code>maximumPoolSize</code> + 队列容量时的拒绝策略</p></li></ul><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span> <span class="hljs-comment">//函数式接口是一个只包含一个抽象方法（abstract method）的接口</span><br><span class="hljs-comment">// 抽象方法是一个没有实现的方法，只包含方法签名（即方法的声明），但不包含方法体。抽象方法必须在实现类中被重写。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Applies this function to the given argument.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment">     */</span><br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br>&#125;<br><br><span class="hljs-comment">//函数型接口，输入T，输出R</span><br>Function&lt;String, Integer&gt; function = Integer::parseInt; <br>function.apply(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//断言型接口，输入T，返回boolean</span><br>Predicate&lt;Integer&gt; predicate = x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <br>predicate.test(<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">//消费型接口，输入T，无返回值</span><br>Consumer&lt;String&gt; consumer = System.out::println;<br>consumer.accept(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//供给型接口，无输入，有返回值</span><br>Supplier&lt;String&gt; supplier = () -&gt; <span class="hljs-string">&quot;123&quot;</span>;<br>supplier.get(); <span class="hljs-comment">//返回&quot;123&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User1</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">21</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">22</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">23</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">24</span>);<br><span class="hljs-type">User1</span> <span class="hljs-variable">u5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User1</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;e&quot;</span>,<span class="hljs-number">25</span>);<br>List&lt;User1&gt; list = Arrays.asList(u1, u2, u3, u4, u5);<br><br>list.stream() <span class="hljs-comment">//Stream&lt;User1&gt;</span><br>        .filter(u -&gt; u.getId() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>        .filter(u -&gt; u.getAge() &gt; <span class="hljs-number">23</span>)<br>        .map(u -&gt; u.getName().toUpperCase()) <span class="hljs-comment">//Stream&lt;String&gt;</span><br>        .sorted(Comparator.reverseOrder())<br>        .limit(<span class="hljs-number">1</span>)<br>        .forEach(System.out::println);<br><span class="hljs-comment">// 输出E</span><br></code></pre></td></tr></table></figure><h3 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h3><p>并行处理框架，用于执行可以被递归地拆分成更小任务的工作负载。旨在充分利用多核处理器的能力来提升并行计算的性能。</p><p>**任务分割 (Fork)**：将一个大任务分解成多个较小的子任务。</p><p>**任务合并 (Join)**：在子任务完成后，将它们的结果合并起来形成最终结果。</p><h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//supplyAsync 有返回值的异步回调</span><br><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; supplyAsync&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>; <span class="hljs-comment">// 除0异常</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>&#125;);<br><br>System.out.println(future.whenComplete((t, u) -&gt; &#123; <span class="hljs-comment">// 成功走whenComplete</span><br>    System.out.println(<span class="hljs-string">&quot;t是任务成功执行时的正常返回值---&gt;&quot;</span> + t.toUpperCase()); <span class="hljs-comment">// HELLO WORLD</span><br>    System.out.println(<span class="hljs-string">&quot;u是执行失败时的错误信息---&gt;&quot;</span> + u); <span class="hljs-comment">// 成功为null</span><br>&#125;).exceptionally((e) -&gt; &#123; <span class="hljs-comment">// 失败走exceptionally</span><br>    System.out.println(e.getMessage());<br>    <span class="hljs-keyword">return</span> String.valueOf(<span class="hljs-number">404</span>);<br>&#125;).get());<br></code></pre></td></tr></table></figure><h3 id="JMM和volatile"><a href="#JMM和volatile" class="headerlink" title="JMM和volatile"></a>JMM和volatile</h3><blockquote><p>JMM: Java内存模型，是一种约定，主要规定了线程自己的本地内存和主存之间的共享变量交互的规则</p></blockquote><p>JMM同步约定：</p><p>1.线程解锁前，必须把共享变量立即写回主存</p><p>2.线程加锁前，必须读取主存共享变量的最新值到自己的工作内存</p><p><img src="/2024/06/20/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/jmm.png" alt="JMM模型"></p><p>JMM定义的规则：</p><ul><li><p>不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。</p></li><li><p>一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。</p></li><li><p>如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量。</p></li></ul><blockquote><p>volatile: JVM提供的轻量级同步机制，关键字</p></blockquote><p>1.保证可见性：这是因为 <code>volatile</code> 变量会直接存储在主存中，每次读取时都直接从主存读取，而不是从线程的工作内存（缓存）中读取。</p><p>2.不保证原子性</p><p>3.禁止指令重排，保证指令执行的顺序性：在编译器和处理器层面，使用 <code>volatile</code> 会插入内存屏障，防止对该变量的读&#x2F;写操作与其他内存操作进行重排序，从而保证了某些顺序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (num == <span class="hljs-number">0</span>) &#123;<br><br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;A&quot;</span>).start();<br><br>    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br><br>    num += <span class="hljs-number">1</span>;<br>    System.out.println(num);<br>&#125;<br><span class="hljs-comment">//程序打印1，但是一直执行并不结束，因为A线程中的num值一直为0，并未更新</span><br><span class="hljs-comment">//private static volatile int num = 0; 使用volatile保证num变量的可见性</span><br><span class="hljs-comment">//即一个线程对 num 的修改对其他线程是立即可见的</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//volatile不能保证对num操作的原子性，最后num的结果始终小于10000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    num ++;<br>&#125;<br><span class="hljs-comment">//num ++ 并不是一个原子操作。在多线程环境下，这些步骤可能被不同的线程打断，从而导致竞争条件。例如，一个线程读取 num 的值为 5，在它增加值之前，另一个线程也读取了同样的值 5 并增加了它们的值。最终的结果是两个线程都将值 6 写回 num，而预期的结果应该是 7。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                add();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>    <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//除了main和gc线程之外，还有上面没执行完的线程</span><br>        Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">//就让主线程让出CPU</span><br>    &#125;<br><br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + num);<br>&#125;<br><br><span class="hljs-comment">// 修改，1.使用atomic包中的原子类保证原子性 2。使用synchronized关键字</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    num.getAndIncrement();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Lazy instance; <span class="hljs-comment">//volatile禁止指令重排，保证instance创建成功，而不会出现（1）先分配内存空间，（2）instance指向该内存空间，（3）接着再初始化对象的情况发生，这种情况其他线程可能返回一个不为null但未被初始化的对象</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Lazy</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; ok&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Lazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//双重检测锁定</span><br>    <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (Lazy.class) &#123;<br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;      <br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lazy</span>();<span class="hljs-comment">//正常创建对象指令 (1)分配内存空间</span><br>            &#125;  <span class="hljs-comment">//   (2)执行构造方法初始化对象</span><br>        &#125;  <span class="hljs-comment">//         (3)把instance对象指向该内存空间</span><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(Lazy::getInstance).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用枚举类实现单例模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Cannot reflectively create enum objects 反射不能创建枚举对象，因此是安全的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">singleEnum</span> &#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-keyword">public</span> singleEnum <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>乐观锁就是操作共享变量时乐观地认为不会有其他线程对数据进行修改，不加锁，只有在提交时（更新时）判断其他线程在这之前有没有对变量进行修改，失败就回滚或者提示。可以通过版本号机制或者CAS算法实现</p></blockquote><blockquote><p>悲观锁总是悲观地假设最坏的情况，操作时加锁，一次只能一个线程访问，其他线程只能等待。MySQL的读写锁，synchronized关键字等</p></blockquote><h4 id="版本号控制"><a href="#版本号控制" class="headerlink" title="版本号控制"></a>版本号控制</h4><ul><li>取出记录时，获取当前<code>version</code></li><li>更新时，带上这个<code>version</code></li><li>执行更新时， <code>set version = newVersion where version = oldVersion</code></li><li>如果<code>version</code>不对，就更新失败</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><blockquote><p>compare and swap的缩写</p></blockquote><p>三个参数：</p><ul><li>需要读写的内存位置<code>V</code></li><li>进行比较的预期原值<code>A</code></li><li>拟写入的新值<code>B</code></li></ul><p>缺点：</p><ul><li><p>ABA问题</p><p>比如说一个线程<code>T1</code>从内存位置<code>V</code>中取出<code>A</code>，这时候另一个线程<code>T2</code>也从内存中取出<code>A</code>，并且<code>T2</code>进行了一些操作变成了<code>B</code>，然后<code>T2</code>又将<code>V</code>位置的数据变成<code>A</code>，这时候线程<code>T1</code>进行<code>CAS</code>操作发现内存中仍然是<code>A</code>，然后<code>T1</code>操作成功。尽管线程<code>T1</code>的<code>CAS</code>操作成功，但可能存在潜藏的问题。</p></li><li><p>自旋CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@IntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123; <span class="hljs-comment">// 自旋锁</span><br>        v = getIntVolatile(o, offset); <span class="hljs-comment">// 获取对象在偏移处的volatile最新值（volatile保证可见性，被其他线程更新的值）</span><br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta)); <span class="hljs-comment">// CAS操作，不解释了</span><br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只能保证一个共享变量的原子操作</p></li></ul><p>AtomicInteger</p><p>AtomicReference<V></p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;bob&quot;</span>);<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">dog2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;tom&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>(dog1, dog2), <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread1</span>(dog2, dog1), <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123; <span class="hljs-comment">//拿狗当锁</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dog</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    Dog dogA;<br>    Dog dogB;<br><br>    MyThread1(Dog A, Dog B) &#123;<br>        <span class="hljs-built_in">this</span>.dogA = A;<br>        <span class="hljs-built_in">this</span>.dogB = B;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (dogA) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;锁定了&quot;</span> + dogA);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (dogB) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;锁定了&quot;</span> + dogB);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>使用 **<code>jps -l</code>**查看进程的进程号</p><p>使用 **<code>jstack &quot;进程号&quot;</code>**定位死锁问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;t1&quot;</span>:<br>        at com.fu1sh.juc.MyThread1.run(DeadLockTest.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x000000071be545c8</span>&gt; (a com.fu1sh.juc.Dog)<br>        - locked &lt;<span class="hljs-number">0x000000071be54588</span>&gt; (a com.fu1sh.juc.Dog)<br>        at java.lang.Thread.run(java.base@<span class="hljs-number">17.0</span><span class="hljs-number">.10</span>/Thread.java:<span class="hljs-number">842</span>)<br><span class="hljs-string">&quot;t2&quot;</span>:<br>        at com.fu1sh.juc.MyThread1.run(DeadLockTest.java:<span class="hljs-number">47</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x000000071be54588</span>&gt; (a com.fu1sh.juc.Dog)<br>        - locked &lt;<span class="hljs-number">0x000000071be545c8</span>&gt; (a com.fu1sh.juc.Dog)<br>        at java.lang.Thread.run(java.base@<span class="hljs-number">17.0</span><span class="hljs-number">.10</span>/Thread.java:<span class="hljs-number">842</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2024/06/17/Redis/"/>
    <url>/2024/06/17/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Linux下登录Redis"><a href="#Linux下登录Redis" class="headerlink" title="Linux下登录Redis"></a>Linux下登录Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 -a YourPassword --raw //raw显示原数据<br></code></pre></td></tr></table></figure><h3 id="使用Docker启动redis"><a href="#使用Docker启动redis" class="headerlink" title="使用Docker启动redis"></a>使用Docker启动redis</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d \</span><br><span class="language-bash">  --name redis \</span><br><span class="language-bash">  -p 6379:6379 \</span><br><span class="language-bash">  -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="language-bash">  -v /docker/redis/data:/data \</span><br><span class="language-bash">  --restart unless-stopped \</span><br><span class="language-bash">  redis:latest \</span><br><span class="language-bash">  redis-server /etc/redis/redis.conf --appendonly <span class="hljs-built_in">yes</span> --requirepass <span class="hljs-string">&quot;123456&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="Redis的数据格式"><a href="#Redis的数据格式" class="headerlink" title="Redis的数据格式"></a>Redis的数据格式</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set name fuish<br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br><span class="hljs-string">&quot;fuish&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; del <span class="hljs-title function_">name</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; exists <span class="hljs-title function_">name</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set age <span class="hljs-number">22</span><br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; keys * <span class="hljs-comment">//keys patten ：模式匹配键</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;x&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; keys *ge<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;age&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; set msg 中文消息也是以二进制保存<br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get msg<br><span class="hljs-string">&quot;\xe4\xb8\xad\xe6\x96\x87\xe6\xb6\x88\xe6\x81\xaf\xe4\xb9\x9f\xe6\x98\xaf\xe4\xbb\xa5\xe4\xba\x8c\xe8\xbf\x9b\xe5\x88\xb6\xe4\xbf\x9d\xe5\xad\x98&quot;</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; redis-cli -h <span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span> -p <span class="hljs-number">6379</span> -a **** --raw <span class="hljs-comment">//加上--raw参数表示以原始形式显示内容</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get msg<br>中文消息也是以二进制保存<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg <span class="hljs-comment">//查看key过期时间</span><br>-<span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; expire msg <span class="hljs-number">10</span> <span class="hljs-comment">// 设置key的过期时间，10s</span><br><span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg<br><span class="hljs-number">6</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl msg<br><span class="hljs-number">2</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setex name <span class="hljs-number">10</span> fuish <span class="hljs-comment">//设置带有过期时间的键值对，10s</span><br>OK<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl name<br><span class="hljs-number">4</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; ttl name<br><span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setnx name kk <span class="hljs-comment">// 键不存在时才设置键的值</span><br><span class="hljs-number">1</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br>kk<br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; setnx name fuish<br><span class="hljs-number">0</span><br><span class="hljs-number">47.121</span><span class="hljs-number">.141</span><span class="hljs-number">.189</span>:<span class="hljs-number">6379</span>&gt; get name<br>kk<br></code></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>旧版本底层是双向链表，新版本换成了quicklist</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush list a b c d e  <span class="hljs-comment">//push elements in the head of the list</span><br>(integer) <span class="hljs-number">5</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span> <br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpop list <span class="hljs-comment">// remove element in the tail</span><br><span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpop list<br><span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; llen <span class="hljs-title function_">list</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush list  d e f <span class="hljs-title function_">g</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">7</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;g&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;c&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;b&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; ltrim list <span class="hljs-number">2</span> <span class="hljs-number">4</span>  <span class="hljs-comment">//trim </span><br>OK<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lrange list <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;e&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;c&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd animal <span class="hljs-title function_">dog</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; smembers animal<br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd animal dog <span class="hljs-comment">// Duplicate element is NOT allowed in Set</span><br>(integer) <span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sismember animal dog <span class="hljs-comment">// Is dog a member of Set Animal</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem animal dog <span class="hljs-comment">// Remove dog</span><br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd s1 dog cat <span class="hljs-title function_">pig</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd s2 cat <span class="hljs-title function_">pig</span><br><span class="hljs-params">(integer)</span> <span class="hljs-number">2</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sinter s1 s2 <span class="hljs-comment">// Intersection of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;pig&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sunion s1 s2 <span class="hljs-comment">// Union of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;cat&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;pig&quot;</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;  sdiff s1 s2 <span class="hljs-comment">// Difference of two Sets</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;dog&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="SortedSet（ZSet）"><a href="#SortedSet（ZSet）" class="headerlink" title="SortedSet（ZSet）"></a>SortedSet（ZSet）</h4><p>维护一个score，按照分数排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd schools <span class="hljs-number">700</span> 清华 <span class="hljs-number">680</span> 浙大 <span class="hljs-number">660</span> 复旦 <span class="hljs-number">640</span> 成电<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange schools <span class="hljs-number">0</span> -<span class="hljs-number">1</span><br>成电<br>复旦<br>浙大<br>清华<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange schools <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<br>成电<br><span class="hljs-number">640</span><br>复旦<br><span class="hljs-number">660</span><br>浙大<br><span class="hljs-number">680</span><br>清华<br><span class="hljs-number">700</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zscore schools 清华<br><span class="hljs-number">700</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank schools 清华 <span class="hljs-comment">// Index of &quot;清华&quot;</span><br><span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank schools 清华 <span class="hljs-comment">// Reverse the rank of &quot;清华&quot; and output</span><br><span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrevrank schools 成电<br><span class="hljs-number">3</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrank schools 清华 <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><img src="/2024/06/17/Redis/hash.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog name fuish<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog age <span class="hljs-number">22</span><br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset dog msg hello<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br>msg<br>hello<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel dog msg<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel dog msg<br><span class="hljs-number">0</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall dog<br>name<br>fuish<br>age<br><span class="hljs-number">22</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hexists dog name<br><span class="hljs-number">1</span><br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hkeys dog<br>name<br>age<br><br></code></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>不同于数据库事务是一个原子操作，要么全部成功要么全部失败。Redis事务只是一批任务的执行集合，允许个别失败，不影响其他任务的成功执行</p><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><h4 id="RDB：Redis-DataBase"><a href="#RDB：Redis-DataBase" class="headerlink" title="RDB：Redis DataBase"></a>RDB：Redis DataBase</h4><ul><li><p>配置文件自动每隔指定的时间间隔将Redis中的数据写入硬盘中</p></li><li><p>save命令，生成dump.rbd，rdb 文件是紧凑的二进制文件，适合备份和传输。创建快照过程中Redis是阻塞的，性能开销大</p></li><li><p>bgsave命令(background save)：Redis 通过fork一个子进程来完成快照操作（复制了映射到内存数据的页表），主进程可以同步接收请求。但是如果在快照之间发生故障，可能会丢失最新的一些数据。</p></li></ul><p><img src="/2024/06/17/Redis/rdb.png"></p><h4 id="AOF-：Append-Only-File"><a href="#AOF-：Append-Only-File" class="headerlink" title="AOF ：Append-Only File"></a>AOF ：Append-Only File</h4><ul><li>Redis 可以将每个写操作都追加到一个日志文件中（AOF 文件）。</li><li>Redis重启时，重新执行AOF文件中的命令来重建数据集。</li></ul><p><img src="/2024/06/17/Redis/aof.png"></p><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式用于监控Redis实例的健康状况，并在主节点故障时进行自动故障转移。它是一种高可用性解决方案，确保Redis集群能够在主节点发生故障时继续正常运行。</p><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ol><li><strong>监控</strong>：Sentinel不断检查主节点和从节点是否正常运行。</li><li><strong>通知</strong>：当某个节点出现问题时，Sentinel可以通知系统管理员或其他应用程序。</li><li><strong>自动故障转移</strong>：如果主节点故障，Sentinel会自动将一个从节点提升为新的主节点，并将其他从节点指向新的主节点。</li><li><strong>配置提供</strong>：客户端可以通过Sentinel获取当前的主节点地址，从而连接到正确的主节点。</li></ol><h3 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>定义：客户端请求的数据在缓存和数据库中都找不到，缓存永不生效，请求全打到数据库。</p><p>解决方法</p><ul><li>缓存空对象<ul><li>优点： 实现简单，维护方便</li><li>缺点： 额外的内存消耗，且可能造成短期的数据不一致问题</li></ul></li><li>布隆过滤器<ul><li>优点：内存占用少，没有多余的key</li><li>缺点：实现复杂，且存在误判可能</li></ul></li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>定义：同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案</p><ul><li>给不同key的TTL添加随机值</li><li>搭建Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h4 id="缓存击穿（热点key问题）"><a href="#缓存击穿（热点key问题）" class="headerlink" title="缓存击穿（热点key问题）"></a>缓存击穿（热点key问题）</h4><p>定义：一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>解决方案</p><ul><li><p>互斥锁：同一时间只能有一个线程拿到锁执行缓存重建</p><ul><li>优点：简单方便，没有多余的内存消耗，保证强一致性</li><li>缺点：线程等待获取锁的时间过长，可能有死锁风险</li></ul></li><li><p>逻辑过期</p><ul><li>不设置TTL，加一个expire time，当前线程查询缓存发现逻辑过期时间已经过期后，获取互斥锁，开启一个新线程来为自己执行重建数据库的操作。其他线程查询这个缓存均返回过期数据就行，无需等待</li><li>缺点：不保证一致性，有额外的内存消耗，实现复杂</li></ul></li></ul><h3 id="Redis验证码登录"><a href="#Redis验证码登录" class="headerlink" title="Redis验证码登录"></a>Redis验证码登录</h3><ul><li>客户端请求服务端，传给服务端手机号</li><li>服务端校验手机号是否合法，生成验证码，保存验证码到Redis，通过云服务发送验证码给对应手机号</li><li>客户端输入验证码登录，传给服务端手机号和验证码，服务端校验手机号，对比客户端验证码和Redis中的验证码</li><li>执行业务逻辑，根据手机号查询用户，没有就新建用户，生成一个随机Token（UUID）作为登录凭证，同时使用这个Token作为key，用户信息作为value，存入Redis中，方便后续校验</li><li>后续用户访问其他页面，需要登录校验，可以定义一个拦截器，<code>String token = request.getHeader(&quot;authorization&quot;);</code> 拿到前端请求中的Token，去Redis找对应的用户信息，并存入ThreadLocal中，方便未来使用</li></ul><h3 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a>优惠券秒杀</h3><p>几个关键点：</p><ul><li>高并发情况下的库存超卖问题</li><li>一人一单</li><li>全局Id</li><li>自调用AOP解决方案</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> ISeckillVoucherService iSeckillVoucherService;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisIDGenerator redisIDGenerator;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Long, Object&gt; locks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secKillByVoucherId</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">//查询优惠券</span><br>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> iSeckillVoucherService.getById(voucherId);<br>        <span class="hljs-comment">//判断秒杀是否开始</span><br>        <span class="hljs-keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (seckillVoucher.getStock() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>        <span class="hljs-comment">//方案一：使用字符串常量池来保证userId的唯一性</span><br><span class="hljs-comment">//        synchronized (userId.toString().intern()) &#123;</span><br><span class="hljs-comment">//            IVoucherOrderService iVoucherOrderServiceProxy = (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="hljs-comment">//            return iVoucherOrderServiceProxy.createVoucherOrder(voucherId);</span><br><span class="hljs-comment">//        &#125;</span><br>        <br>        <span class="hljs-comment">//方案二：使用concurrentHashMap存储userId</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> locks.computeIfAbsent(userId, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">iVoucherOrderServiceProxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>            <span class="hljs-keyword">return</span> iVoucherOrderServiceProxy.createVoucherOrder(voucherId);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>        <span class="hljs-comment">//一人一单</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;每人只能购买一张！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>                .update();<br>        <span class="hljs-keyword">if</span> (!success) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//创建订单</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIDGenerator.nextId(<span class="hljs-string">&quot;order&quot;</span>);<span class="hljs-comment">//使用redis实现的全局Id生成器</span><br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>        voucherOrder.setId(orderId);<br>        voucherOrder.setVoucherId(voucherId);<br>        voucherOrder.setUserId(userId);<br><br>        save(voucherOrder);<br>        <span class="hljs-comment">//返回订单id</span><br>        <span class="hljs-keyword">return</span> Result.ok(orderId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>超卖解决方案</p></blockquote><ul><li>1.如上文，增加判断 <code>gt(&quot;stock&quot;, 0)</code>，也就是 <code>update SeckillVoucher set stock = stock - 1 WHERE id = 1001 and stock &gt; 0</code>。当然这里也可以用CAS比较stock&#x3D;&#x3D;之前查出来的stock，只是这样会阻塞很多没必要阻塞的线程，因为只要库存大于0便都可以执行操作</li><li>2.版本号，CAS操作</li><li>3.利用Redis单线程</li></ul><h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><p>基于synchronized悲观锁锁住UserId的方案存在以下问题：</p><ul><li>单机模式下可行，但是效率低</li><li>集群模式下不可行，当在不同的端口启动项目时（模拟分布式集群），请求通过nginx负载均衡到不同的端口（部署项目的机器），而每台机器上运行的JVM进程都是独立的，synchronized锁不可能跨进程发挥作用</li></ul><p>解决方案：分布式锁（集群模式下多进程可见的互斥锁）</p><ul><li>redis实现分布式锁，通过key（KeyPrefix+userId）–&gt; value（UUID+ThreadId）锁到同一台redis中。</li><li>数据库实现</li><li>zookeeper</li></ul><blockquote><p>redis分布式锁控制一人一单实战</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">idPrefix</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<span class="hljs-comment">//lua脚本保证解锁操作的原子性</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unLock.lua&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisDistributedLock</span><span class="hljs-params">(String name, StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSeconds)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> keyPrefix + name;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> idPrefix + Thread.currentThread().getId();<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, value, timeoutSeconds, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(b);<br><span class="hljs-comment">//        return BooleanUtil.isTrue(b);</span><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        redisTemplate.execute(UNLOCK_SCRIPT,<br>                Collections.singletonList(keyPrefix + name),<br>                idPrefix + Thread.currentThread().getId()<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而之前秒杀功能中的synchronized锁便被替换为了自定义的redis锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RedisDistributedLock</span> <span class="hljs-variable">redisDistributedLock</span> <span class="hljs-operator">=</span> redisLockFactory.createLock(<span class="hljs-string">&quot;order:&quot;</span> + userId);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redisDistributedLock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-keyword">if</span> (!lock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;一人只能下一单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">iVoucherOrderServiceProxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> iVoucherOrderServiceProxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    redisDistributedLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>unLock.lua脚本文件，判断将要解锁的锁（lockKey）下的value是不是自己之前设置的UUID+ThreadId，防止把别人的</p><p>锁解开了（删除了）</p><blockquote><p>lua脚本可以将该线程的这些redis命令原子地执行，执行过程中不允许其他线程的redis命令执行</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--unLock.lua</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;DEL&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>基于Redis的setnx命令实现的分布式锁存在以下问题：</p><ul><li>不可重入</li><li>不可重试</li><li>超时释放</li><li>主从一致性</li></ul><blockquote><p>Redisson可重入锁原理</p></blockquote><p>同Reentrantlock一样，Reentrantlock通过state变量记录重入的次数，重入锁state+1，释放锁state-1</p><p>Redisson通过redis的hash结构控制重入，其中key是锁的名称，value的键是线程的标识，值是重入次数，源码通过lua脚本控制获取锁和释放锁的操作，每次获取锁和释放锁都要为key重新设置有效期，除非释放锁导致重入次数归零，此时直接删除锁</p><blockquote><p>Redisson重试机制</p></blockquote><p>利用信号量和发布订阅（pub、sub）功能实现等待、唤醒、获取锁失败的重试机制</p><blockquote><p>超时续约</p></blockquote><p>利用watchDog，每隔releaseTime&#x2F;3的时间便重置超时时间</p><blockquote><p>主从一致性保证</p></blockquote><p>multiLock，redisson不再区分主从节点，分布式锁需要在每个redis节点同步更新，必须在所有节点都获取到重入锁，才算获取锁成功</p><h3 id="总结对于Redis的各种数据结构的实战使用"><a href="#总结对于Redis的各种数据结构的实战使用" class="headerlink" title="总结对于Redis的各种数据结构的实战使用"></a>总结对于Redis的各种数据结构的实战使用</h3><h4 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h4><p>用户使用手机号登录，后台生成验证码后，使用手机号作为key，存储验证码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure><h4 id="Hash-1"><a href="#Hash-1" class="headerlink" title="Hash"></a>Hash</h4><p>用户登录后，生成一个随机Token（UUID）作为登录凭证，同时使用这个Token作为key，用户信息作为value，存入Redis中，用户信息被转换成了一个HashMap。后续该用户的各种访问，通过拦截器去Redis拿他的用户信息来进行校验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br>stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);<br>stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br><br><span class="hljs-comment">// 基于token获取redis中的用户</span><br>Map&lt;Object, Object&gt; userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);<br></code></pre></td></tr></table></figure><h4 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h4><ul><li>存储用户id，控制一个用户只能下一单（不重复性质）</li><li>共同关注功能（intersect函数功能，查交集）</li></ul><h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>存储对应博文点赞的用户id，并按照时间戳排序，便于将最先点赞的用户展示在最前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br></code></pre></td></tr></table></figure><h4 id="Hash-2"><a href="#Hash-2" class="headerlink" title="Hash"></a>Hash</h4><h3 id="异步秒杀"><a href="#异步秒杀" class="headerlink" title="异步秒杀"></a>异步秒杀</h3><blockquote><p>思路就是把对于库存余量和一人一单的判断放到redis去做，只要这两个条件满足就先允许用户下单，把订单信息存到一个消息队列中（这里使用阻塞队列简单实现），对于数据库的更新操作是通过监听消息队列后台异步执行的，提升了性能</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于redis+阻塞队列实现异步秒杀</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> voucherId</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">secKillByVoucherId</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">//上传秒杀优惠券时，使用redis的hash存储了秒杀开始和结束时间，以及库存</span><br>    Map&lt;Object, Object&gt; seckillMap = stringRedisTemplate.opsForHash().entries(SECKILL_MAP_KEY + voucherId);<br>    <span class="hljs-type">SeckillVoucherRedis</span> <span class="hljs-variable">svr</span> <span class="hljs-operator">=</span> BeanUtil.mapToBean(seckillMap, SeckillVoucherRedis.class, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (svr.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (svr.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀已经结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(<br>            SECKILL_SCRIPT,<br>            Collections.emptyList(),<br>            voucherId.toString(),<br>            userId.toString()<br>    );<br>    <span class="hljs-keyword">assert</span> res != <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> res.intValue();<br>    <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> Result.fail(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足！&quot;</span> : <span class="hljs-string">&quot;一人只能下一单&quot;</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIDGenerator.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    <span class="hljs-comment">//生成订单，放到阻塞队列中</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setVoucherId(voucherId);<br>    voucherOrder.setUserId(userId);<br>    queue.add(voucherOrder);<br>    iVoucherOrderServiceProxy = (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>lua脚本</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---</span><br><span class="hljs-comment">--- Generated by EmmyLua(https://github.com/EmmyLua)</span><br><span class="hljs-comment">--- Created by Fu1sh.</span><br><span class="hljs-comment">--- DateTime: 2024/8/16 22:42</span><br><span class="hljs-comment">---</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:map:&#x27;</span>..voucherId<br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span>..voucherId<br><span class="hljs-comment">-- 判断库存《hash》</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;hget&#x27;</span>, stockKey, <span class="hljs-string">&#x27;stock&#x27;</span>)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 判断用户是否已经下过单《set》</span><br><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><br>redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, stockKey, <span class="hljs-string">&#x27;stock&#x27;</span>, <span class="hljs-number">-1</span>)<br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>以下是异步更新数据库的逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> IVoucherOrderService iVoucherOrderServiceProxy;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><br><span class="hljs-meta">@PostConstruct</span><span class="hljs-comment">//当一个类的实例被创建并且所有的依赖已经注入后,@PostConstruct标记的方法就会被自动调用。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    pool.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                voucherOrder = queue.take();<br>                handlerVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单有异常发生：&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步将订单存入数据库</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> voucherOrder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlerVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">myLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    lock = myLock.tryLock();<br>    <span class="hljs-keyword">if</span> (!lock) &#123;<br>        log.error(<span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        iVoucherOrderServiceProxy.createVoucherOrder(voucherOrder);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        myLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">voucherId</span> <span class="hljs-operator">=</span> voucherOrder.getVoucherId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        log.error(<span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> iSeckillVoucherService.update()<br>            .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>            .gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>            .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>    &#125;<br>    save(voucherOrder);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阻塞队列的缺点"><a href="#阻塞队列的缺点" class="headerlink" title="阻塞队列的缺点"></a>阻塞队列的缺点</h4><ul><li>基于JVM，队列中的元素存储在JVM内存中，不支持持久化，一旦掉电消息丢失</li><li>占内存，影响性能</li><li>只能存取消息一次</li></ul><h4 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h4><ul><li>List：双向链表，LPUSH，RPOP等，可以做消息队列，基于redis不占JVM内存，可持久化消息，满足消息有序性。但是无法避免消息丢失，且只支持单消费者（消息被一个消费者拿走就从List移除了）</li><li>PubSub：发布订阅模式，支持多生产多消费者。但是不支持消息持久化，无法避免消息丢失，消息堆积有上限，超出时消息就丢失了</li><li>Stream</li></ul><p><code>优点</code>：</p><ol><li>使用成本低。几乎每一个项目都会使用Redis，用Stream做消息队列就不需要额外再引入中间件，减少系统复杂性，运维成本，硬件资源。</li></ol><p><code>缺点</code>：</p><ol><li>Redis 的数据都存储在内存中，内存持续增长超过机器内存上限，就会面临 OOM 的风险</li><li>Stream 作为Redis的一种数据结构，Redis 在持久化或主从切换时有丢失数据的风险，所以Stream也有丢失消息的风险</li><li>所有的消息会一直保存在Stream中，没有删除机制。要么定时清除，那么设置队列的长度自动丢弃先入列消息</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP总结</title>
    <link href="/2024/05/16/HTTP%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/16/HTTP%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><h4 id="一个完整的HTTP请求长什么样子？"><a href="#一个完整的HTTP请求长什么样子？" class="headerlink" title="一个完整的HTTP请求长什么样子？"></a>一个完整的HTTP请求长什么样子？</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">+---------------------------------------------------------------+<br>|<span class="hljs-string">                     请求行 (Request Line)                     </span>|<br>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string"> HTTP Method (GET, POST, etc.) / Request-URI / HTTP Version    </span>|<span class="hljs-string">                          </span><br><span class="hljs-string"></span>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string">                    请求头部 (Request Headers)                 </span>|<br>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string"> Header-Name: Header-Value                                    </span>|<span class="hljs-string">                          </span><br><span class="hljs-string"></span>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string"> 空行：请求头部和请求体之间用一个空行分隔，表示头部的结束。             </span>|<br>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string">                      请求体 (Request Body)                    </span>|<br>|<span class="hljs-string">---------------------------------------------------------------</span>|<br>|<span class="hljs-string"> Body Content (for POST, PUT, etc.)                           </span>|<br>+---------------------------------------------------------------+<br></code></pre></td></tr></table></figure><p><strong>POST请求示例</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http">POST /items HTTP/1.1   #请求行#<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com      #请求头#<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>34     #请求体#<br>&#123;<br>  &quot;itemId&quot;: 123,<br>  &quot;itemName&quot;: &quot;Example Item&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="响应长什么样"><a href="#响应长什么样" class="headerlink" title="响应长什么样"></a>响应长什么样</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK                        #状态行#<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 20 Jul 2021 20:00:00 GMT        #响应头#<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.4.41 (Ubuntu)<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 20 Jul 2021 18:00:00 GMT<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>85<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br>&#123; #响应体#<br>    &quot;status&quot;: &quot;success&quot;,<br>    &quot;data&quot;: &#123;<br>        &quot;id&quot;: 1,<br>        &quot;name&quot;: &quot;John Doe&quot;,<br>        &quot;email&quot;: &quot;john.doe@example.com&quot;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="一条URL（Uniform-Resource-Locator）"><a href="#一条URL（Uniform-Resource-Locator）" class="headerlink" title="一条URL（Uniform Resource Locator）"></a>一条URL（Uniform Resource Locator）</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://localhost:8080/users?ids=1,2,3,4,5&amp;name=John&amp;money=100<br></code></pre></td></tr></table></figure><ul><li>http：协议</li><li>localhost:8080：主机名（ip）和端口号</li><li>&#x2F;users：资源路径（URI，Uniform Resource Identifier）</li><li>?：标志查询参数的开始。</li><li>&amp;：多个查询参数之间用 <code>&amp;</code> 符号分隔。</li></ul><h4 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h4><p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</p><ul><li>超文本：它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。</li><li>传输：HTTP 是一个在计算机世界里专门用来在<strong>两点之间传输数据</strong>的约定和规范。</li><li>协议：它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul><li>200 OK：成功</li><li>3xx：表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</li><li>4xx：表示客户端发送的报文有误，服务器无法处理，属于客户端的错误码。</li><li>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</li></ul><h4 id="HTTP字段"><a href="#HTTP字段" class="headerlink" title="HTTP字段"></a>HTTP字段</h4><ul><li>Host：客户端发送请求时，用来指定服务器的域名。<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Host:</span> www.A.com<br></code></pre></td></tr></table></figure></li><li>Content-Length 字段：服务器返回数据的长度。</li><li>Connection 字段：客户端要求服务器使用「HTTP 长连接」机制，<code>Connection: Keep-Alive</code></li><li>Content-Encoding 字段：服务器返回的数据使用了什么压缩格式。</li></ul><h4 id="HTTP无状态"><a href="#HTTP无状态" class="headerlink" title="HTTP无状态"></a>HTTP无状态</h4><p>HTTP 无状态（Stateless）是指每个 HTTP 请求都是独立的，服务器在处理完一个请求后不会保留任何与该请求相关的状态信息。这意味着服务器不会自动记住客户端之间的交互，每个请求都被认为是全新的、独立的请求</p><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p>保存在服务端，服务端返回给客户端一个SessionId，以后的每次请求都带上这个Id（客户端通过 Cookie 或 URL 参数将 Session ID 发送给服务器。服务器根据这个 ID 查找并恢复用户的会话状态。），服务端根据Id拿到对应的session恢复用户状态。</p><blockquote><p>基于session的验证码登录</p></blockquote><ul><li>客户端请求服务端，传给服务端手机号</li><li>服务端校验手机号是否合法，生成验证码，保存验证码到session，通过云服务发送验证码给对应手机号，（同时后台生成了cookie并将sessionId附在cookie中返回给了客户端）</li><li>客户端输入验证码登录，传给服务端手机号和验证码（sessionId也跟随cookie一并传过来了），服务端校验手机号，对比客户端验证码和对应session中的验证码，执行业务逻辑（根据手机号查询用户，没有就创建，有就把部分用户信息保存到session），同时返回这部分用户信息给前端</li></ul><h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>用户首次访问服务端后由服务端生成，返回并保存在客户端，通常用来保存用户偏好、跟踪用户行为、保持登录状态。生命周期有仅限浏览器运行时的，也有持久化存储到硬盘的。每次客户端向服务器发起请求时，浏览器会自动将与该域名相关的所有 Cookie 一同发送给服务器。</p><h4 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h4><p>前端控制器，具体见下图</p><p><img src="/2024/05/16/HTTP%E6%80%BB%E7%BB%93/DispatcherServlet.png" alt="DispatcherServlet扮演的角色"></p><h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET&#x2F;POST"></a>GET&#x2F;POST</h3><p>1、GET 和 POST 方法都是安全和幂等的吗？</p><ul><li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li><li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li></ul><p>RFC 规范定义下：</p><ul><li><p>GET 方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。</p></li><li><p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。</p></li></ul><h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p>把重复性的 HTTP「请求-响应」的数据缓存在本地</p><p>1、强制缓存</p><ul><li>只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。通过HTTP 响应头部（Response Header）的字段<code>Cache-Control</code>和<code>Expires</code>控制</li></ul><p>2、协商缓存</p><ul><li>通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。与服务端协商之后，通过协商结果来判断是否使用本地缓存。</li></ul><h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><h4 id="HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？"></a>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 提高了什么性能？</h4><p>优化：</p><ul><li>使用长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>缺点：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>请求只能从客户端开始，服务器只能被动响应；</li><li>没有请求优先级控制。</li></ul><h4 id="HTTP-2-相比-HTTP-1-1-性能上的改进"><a href="#HTTP-2-相比-HTTP-1-1-性能上的改进" class="headerlink" title="HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进"></a>HTTP&#x2F;2 相比 HTTP&#x2F;1.1 性能上的改进</h4><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p>缺点：</p><ul><li>一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">2</span> 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 <span class="hljs-number">1</span> 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 <span class="hljs-number">1</span> 个字节数据到达时，HTTP/<span class="hljs-number">2</span> 应用层才能从内核中拿到数据，这就是 HTTP/<span class="hljs-number">2</span> 队头阻塞问题。<br></code></pre></td></tr></table></figure></li></ul><h4 id="HTTP-3-做了哪些优化？"><a href="#HTTP-3-做了哪些优化？" class="headerlink" title="HTTP&#x2F;3 做了哪些优化？"></a>HTTP&#x2F;3 做了哪些优化？</h4><p> HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！<br> <img src="/2024/05/16/HTTP%E6%80%BB%E7%BB%93/1-HTTP3.webp" alt="小林Coding"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和String类的compareTo方法</title>
    <link href="/2024/05/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CString%E7%B1%BB%E7%9A%84compareTo%E6%96%B9%E6%B3%95/"/>
    <url>/2024/05/16/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CString%E7%B1%BB%E7%9A%84compareTo%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>可以将Lambda表达式理解为一个匿名函数； Lambda表达式允许将一个函数作为另外一个函数的参数； 我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码作为实参）,也可以理解为函数式编程，将一个函数作为参数进行传递。</p><ul><li>实例</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>       <span class="hljs-title class_">Thread</span> thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>       thread.<span class="hljs-title function_">start</span>();<br>       thread.<span class="hljs-title function_">close</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使这段代码更加简洁，可以使用匿名内部类重构：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-comment">//这里的 new 了 Runnable() 接口，在这个 new 的接口里面，我们写了这个接口的实现类。</span><br>        <span class="hljs-comment">//这里可以看出，我们把一个重写的 run() 方法传入了一个构造函数中。</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>            &#125;<br>        &#125;).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续简化，使用Lambda：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLambda</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>))</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="String的compareTo-方法"><a href="#String的compareTo-方法" class="headerlink" title="String的compareTo()方法"></a>String的compareTo()方法</h1><ul><li>源码</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> implements java.io.Serializable, Comparable&lt;<span class="hljs-type">String</span>&gt;, CharSequence &#123;<br><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-type">String</span> anotherString)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = value.length;<br>        <span class="hljs-type">int</span> len2 = anotherString.value.length;<br>        <span class="hljs-type">int</span> lim = Math.<span class="hljs-built_in">min</span>(len1, len2);<br>        <span class="hljs-type">char</span> v1[] = value;<br>        <span class="hljs-type">char</span> v2[] = anotherString.value;<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>            <span class="hljs-type">char</span> c1 = v1[k];<br>            <span class="hljs-type">char</span> c2 = v2[k];<br>            <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                <span class="hljs-keyword">return</span> c1 - c2;<br>            &#125;<br>            k++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len1 - len2;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="剑指offer-把数组排成最小的数"><a href="#剑指offer-把数组排成最小的数" class="headerlink" title="剑指offer.把数组排成最小的数"></a>剑指offer.把数组排成最小的数</h1><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。输出格式为字符串。</p><p>样例:</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[3, 32, 321]</span><br><br>输出：<span class="hljs-number">321323</span><br></code></pre></td></tr></table></figure><ul><li><p>思路：自定义排序规则，<code>nums[i] &lt; nums[j]</code> 当且仅当 <code>nums[i] + nums[j](字符串连接) &lt; nums[j] + nums[i]</code></p></li><li><p>代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">printMinNumber</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>        StringBuilder sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>();<br>        <span class="hljs-type">int</span> n = nums.length;<br>        <span class="hljs-comment">// 将整数数组转换为字符串数组</span><br>        <span class="hljs-type">String</span>[] strNums = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            strNums[i] = <span class="hljs-type">String</span>.<span class="hljs-built_in">valueOf</span>(nums[i]);<br>        &#125;<br>        <span class="hljs-comment">// 自定义排序逻辑，按连接后的字符串进行比较</span><br>        Arrays.<span class="hljs-built_in">sort</span>(strNums, (o1, o2) -&gt; (o1 + o2).<span class="hljs-built_in">compareTo</span>(o2 + o1));<br>        <span class="hljs-comment">// 拼接排序后的字符串数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> str : strNums) &#123;<br>            sb.<span class="hljs-built_in">append</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全排列（没有重复数字）</title>
    <link href="/2024/05/14/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%89/"/>
    <url>/2024/05/14/%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Problem: <a href="https://leetcode.cn/problems/VvJkup/description/">LCR 083. 全排列</a></p></blockquote><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个不含重复数字的整数数组 nums ，返回其<strong>所有可能的全排列</strong> 。可以<strong>按任意顺序</strong>返回答案。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数<strong>互不相同</strong></li></ul><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><figcaption><span>[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">// 全局变量记录答案</span><br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//记录每个排列</span><br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        dfs(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> []nums, <span class="hljs-type">int</span> u)</span> &#123; <span class="hljs-comment">//定义u记录递归深度</span><br>        <span class="hljs-keyword">if</span> (u == nums.length) &#123; <span class="hljs-comment">//到底了就说明生成了一个排列，加入答案List中</span><br>            res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>(path)); <span class="hljs-comment">//注意不能把path直接加入res中，而是要新建一个对象。否则后续更新path会导致res中的path更改。</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123; <span class="hljs-comment">//遍历nums中的每个值</span><br>            <span class="hljs-keyword">if</span> (!path.contains(i)) &#123; <span class="hljs-comment">//若本次排列中不包含这个值,如i = 3,path = [1, 2, 4]</span><br>                path.add(i); <span class="hljs-comment">//将该值加入排列,path = [1, 2, 4, 3]</span><br>                dfs(nums, u + <span class="hljs-number">1</span>); <span class="hljs-comment">//递归添加排列的下一个位置,即寻找path = [1, 2, 4, 3, _]的空格处应该填入的值</span><br>                path.removeLast(); <span class="hljs-comment">//恢复现场，path = [1, 2, 4, _]</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>时间复杂度:</p><blockquote><p>$ O(n! * n)$</p></blockquote><p>空间复杂度</p><blockquote><p>$ O(n!)$ </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>equals和==的区别</title>
    <link href="/2024/05/12/Java%E4%B8%ADequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/05/12/Java%E4%B8%ADequals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h3><h5 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h5><ul><li>int（4Byte）， double（8）， float（4）， long（8）， short（2）， byte（1）， char（2）， boolean（）</li></ul><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ul><li>类， 接口， 数组</li></ul><h3 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和&#x3D;&#x3D;的区别"></a>equals和&#x3D;&#x3D;的区别</h3><h5 id="比较值是否相等"><a href="#比较值是否相等" class="headerlink" title="&#x3D;&#x3D; 比较值是否相等"></a>&#x3D;&#x3D; 比较值是否相等</h5><ul><li>作用于基本数据类型的变量，则直接比较其存储的值是否相等</li><li>作用于引用类型的变量，则比较的是所指向的对象的地址是否相等<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">其实<span class="hljs-operator">=</span><span class="hljs-operator">=</span>比较的不管是基本数据类型，还是引用数据类型的变量，比较的都是值，只是引用类型变量存的值是对象的地址.<br></code></pre></td></tr></table></figure></li></ul><h5 id="equals比较是否是同一个对象"><a href="#equals比较是否是同一个对象" class="headerlink" title="equals比较是否是同一个对象"></a>equals比较是否是同一个对象</h5><ul><li>equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用&#x3D;&#x3D;的效果一样，也是比较的是引用类型的变量所指向的对象的地址，不过，Java提供的类中，有些类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类。</li></ul><h5 id="null"><a href="#null" class="headerlink" title="&#x3D;&#x3D; null"></a>&#x3D;&#x3D; null</h5><p>为什么用 <code>== null</code>，而不用 <code>equals(null)</code> ?</p><ul><li><code>obj.equals(null)</code> 如果 <code>obj</code> 也为 <code>null</code> 的话，会抛出空指针异常</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树的子结构</title>
    <link href="/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<ul><li>题目描述</li></ul><p><img src="/2024/05/11/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/image.png"></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> boolean hasSubtree(TreeNode pRoot1, TreeNode pRoot2) &#123;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">null</span> || pRoot2 == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//遇到空节点直接返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isPart(pRoot1, pRoot2)) &#123; <span class="hljs-comment">//遍历树A的所有非空节点，判断树A中以R为根的子树是否与树B有一样的结构</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hasSubtree(pRoot1.left, pRoot2) || hasSubtree(pRoot1.right, pRoot2); <span class="hljs-comment">// 递归遍历A的所有子节点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> boolean isPart(TreeNode p1, TreeNode p2) &#123;<br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//树B遍历到了空，说明当前分支匹配，返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span> || p1.<span class="hljs-keyword">val</span> != p2.<span class="hljs-keyword">val</span>) &#123; <span class="hljs-comment">//树A为空且树B不为空，或者两个节点都不为空但数值不同，均返回false</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isPart(p1.left, p2.left) &amp;&amp; isPart(p1.right, p2.right); <span class="hljs-comment">// 否则说明当前这个点匹配，递归遍历左子树和右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown表格</title>
    <link href="/2024/05/04/MarkDown%E8%A1%A8%E6%A0%BC/"/>
    <url>/2024/05/04/MarkDown%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<ol><li>表格居中<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-variable">&lt;style&gt;</span><br>.center <br>&#123;<br>  width: auto;<br>  display: table;<br>  margin-left: auto;<br>  margin-right: auto;<br>&#125;<br><span class="hljs-variable">&lt;/style&gt;</span><br><br><span class="hljs-variable">&lt;div class=&quot;center&quot;&gt;</span><br>|<span class="hljs-string">数组下标 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 3  </span>|<span class="hljs-string"> 4 </span>|<br>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<span class="hljs-string">:----:</span>|<br>|<span class="hljs-string"> h </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 1 </span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string"> -1 </span>|<br>|<span class="hljs-string"> e </span>|<span class="hljs-string"> 2 </span>|<span class="hljs-string"> 4 </span>|<span class="hljs-string"> 3 </span>|<span class="hljs-string"> 4 </span>||<br>|<span class="hljs-string"> ne </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> -1 </span>|<span class="hljs-string"> 0 </span>|<span class="hljs-string"> -1 </span>||<br><span class="hljs-variable">&lt;/div&gt;</span><br><br></code></pre></td></tr></table></figure></li></ol><ul><li>效果<style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style></li></ul><div class="center"><table><thead><tr><th align="center">数组下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">-1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">e</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">4</td><td align="center"></td></tr><tr><td align="center">ne</td><td align="center">-1</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center"></td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>MarkDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MarkDown插入图片</title>
    <link href="/2024/04/27/MarkDown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <url>/2024/04/27/MarkDown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<ol><li>本地路径下的图片</li></ol><ul><li><p>本地相对路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">!<span class="hljs-selector-attr">[本地路径]</span>(image.png)         (图片在md文件的同一级)<br>!<span class="hljs-selector-attr">[本地路径]</span>(pic\image.png)     (图片在md文件的下一级)<br>或者：<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.png&quot;</span>&gt;<br>&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;pic\image.png&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>本地绝对路径不建议使用，很多情况加载不出来</p></li></ul><ol start="2"><li>控制图片大小</li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">设置图片的宽和高像素值：&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;图片路径&quot;</span> width <span class="hljs-operator">=</span> <span class="hljs-number">300</span> height <span class="hljs-operator">=</span> <span class="hljs-number">200</span>&gt;<br>设置缩放的比例：&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;图片路径&quot;</span> width <span class="hljs-operator">=</span> <span class="hljs-number">60</span>%&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>控制图片位置</li></ol><ul><li>有left、right、center等属性<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;div <span class="hljs-attribute">align</span>=center&gt;  &lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;image.png&quot;</span> <span class="hljs-attribute">width</span>=60%&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>MarkDown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MarkDown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜鸟一面</title>
    <link href="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/"/>
    <url>/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="菜鸟实习生校招"><a href="#菜鸟实习生校招" class="headerlink" title="菜鸟实习生校招"></a>菜鸟实习生校招</h3><p><strong>首先</strong>：回答问题的时候不要表现得像在背八股文一样，眼睛瞟着一边做出思考的样子，非常像在背八股文。简历上的每一个条目都要弄懂，并且要思考为什么要用这个东西，比如阿里云（用他的优势是什么，为什么不用华为云）。</p><ol><li>自我介绍：老师您好！我叫fred，…..</li><li>项目：三个项目中你觉得最有意思的项目是哪个（意思是你最熟悉哪个），答RPC。</li><li>讲一下RPC</li></ol><ul><li>远程过程调用(Remote Procedure Call)，两个不同的服务器上的服务提供的方法不在同一个内存空间，通过RPC可以帮我们调用某个远程服务器上服务的某个方法，这个过程就像本地调用一样简单，同时我们不需要关注底层网络编程的具体细节。</li><li>RPC原理：①客户端、②客户端stub（代理类）主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端、③网络传输（socket、Netty、Jetty）、④服务端stub（指接收到客户端执行方法的请求后，去执行对应的方法然后返回结果给客户端的类）、⑤服务端</li><li>本RPC项目的结构：<br><img src="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/image-1.png"></li></ul><ol start="4"><li>Netty是什么</li></ol><ul><li>Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</li></ul><ol start="5"><li>Netty相比于其他网络传输优势在哪？</li></ol><ul><li>API使用简单，学习成本低。</li><li>功能强大，内置了多种解码编码器，支持多种协议。</li><li>性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><ol start="6"><li>Netty如何实现长连接，为什么不用短连接要用长连接，心跳包的收发过程。</li></ol><ul><li>减少连接建立和断开的开销: 建立和断开连接都需要消耗资源，包括网络带宽、CPU 时间和内存等。使用长连接可以减少这些开销，因为连接在一段时间内保持打开状态，而不需要频繁地进行建立和断开操作。</li><li>提高性能和效率: 长连接可以减少因连接建立和断开所带来的延迟，从而提高数据传输的效率和性能。特别是对于实时通信、推送服务等应用场景，长连接能够更快地实现消息的实时传输。</li><li>实现长连接的关键在于保持连接的活跃状态，以防止连接由于长时间没有数据传输而被关闭。在实际应用中，通常会采用心跳机制来维持连接的活跃状态。心跳包是定期发送的小型数据包，用于检测连接的状态和保持连接的活跃性。</li></ul><ol start="7"><li>TCP&#x2F;IP三次握手，四次挥手：见小林coding</li><li>序列化是什么，有哪些序列化方式，为什么用kryo，不用其他的</li></ol><ul><li>序列化：把对象转化为可传输的字节序列过程称为序列化。</li><li>序列化最终的目的是为了对象可以跨平台存储，和进行网络传输。而我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</li><li>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则（序列化），那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来（反序列化）。</li><li>序列化的方式：JDK（不支持跨语言）、JSON、XML、Hessian、Kryo（不支持跨语言）、Thrift、Protobuff、FST（不支持跨语言）</li><li>kryo优势：高性能，序列化后数据量小，速度快，灵活性强，支持自定义序列化器</li><li>基于Json的序列化器缺陷：某个类的属性反序列化时，如果属性声明为Object，就会造成反序列化出错， 会把Object类型反序列化成String类型，并且，JSON 序列化器是基于字符串（JSON 串）的，占用空间较大且速度较慢。</li></ul><ol start="9"><li><p>为什么要把对象序列化成二进制发送，不序列化可以发送吗，一定要序列化成二进制吗<br><img src="/2024/04/23/%E8%8F%9C%E9%B8%9F%E4%B8%80%E9%9D%A2/image2.png"></p></li><li><p>同步阻塞调用</p></li><li><p>git的rebase操作</p></li><li><p>TreadLocal</p></li><li><p>深拷贝和浅拷贝：</p></li></ol><ul><li>浅拷贝创建一个新对象，但新对象内部的元素是对原始对象中元素的引用。也就是说，新对象与原始对象共享子对象或属性（共享同一块内存）。</li><li>深拷贝创建一个新对象，并递归地复制所有子对象或属性。新对象与原始对象完全独立，修改新对象不会影响原始对象。</li></ul><ol start="14"><li><p>无锁队列</p></li><li><p>中序遍历应用场景</p></li><li><p>一个请求从前端到后端的执行流程</p></li><li><p>线程池的参数<br><strong>总结</strong>：先搞清楚简历上的每一个关键词，并延伸，多思考为什么这么做，而不是这个东西的原理，比如使用kryo相比于JSON序列化的优势，之后再补充</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面筋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL从入门到入门</title>
    <link href="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="部署与启动MySQL"><a href="#部署与启动MySQL" class="headerlink" title="部署与启动MySQL"></a>部署与启动MySQL</h1><p><a href="https://blog.csdn.net/qq_45441466/article/details/109670194">阿里云安装MySQL</a></p><h3 id="启动MySQL服务"><a href="#启动MySQL服务" class="headerlink" title="启动MySQL服务"></a>启动MySQL服务</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service mysql <span class="hljs-literal">start</span> / service mysqld <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -uroot -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><h3 id="关系型数据库VS非关系型数据库"><a href="#关系型数据库VS非关系型数据库" class="headerlink" title="关系型数据库VS非关系型数据库"></a>关系型数据库VS非关系型数据库</h3><p>关系型：二维表格模型，ACID特性（Atomicity，Consistency，Isolation，    Durability）。有MySQL、Oracle、SQL Server。慢，海量数据读写，扩展性和可用性<br>非关系型：NoSQL，键值对存储，分布式，不保证ACID。有MongoDB、Redis、CouchDB。快，key-value查询，海量数据访问</p><h3 id="DML、DDL"><a href="#DML、DDL" class="headerlink" title="DML、DDL"></a>DML、DDL</h3><p>DDL：Data Definition Language，定义&#x2F;改变表的结构、数据类型、表之间的链接等操作。CREATE、DROP、ALTER</p><p>DML：Data Manipulate Language，INSERT、UPDATE、DELETE</p><p>DQL：Data Query Language，SELECT</p><p>DCL：Data Control Language，设置&#x2F;更改数据库用户权限。常用关键字有 GRANT、REVOKE </p><h3 id="MySQL执行流程"><a href="#MySQL执行流程" class="headerlink" title="MySQL执行流程"></a>MySQL执行流程</h3><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.webp" alt="借用小林Coding的图"></p><p><strong>Server层</strong></p><p>1、连接器</p><ul><li>与客户端进行 TCP 三次握手建立连接</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限</li></ul><p>2、查询缓存</p><ul><li>以key-value形式保存，key为SQL语句，value为SQL查询结果</li><li>MySQL 8.0已经删除</li></ul><p>3、解析器</p><ul><li>词法分析：把SQL语句分解成关键词</li><li>语法分析：构建SQL语法树，方便后续模块获取表名、字段名等</li></ul><p>4、执行SQL</p><ul><li>预处理器：检查 SQL 查询语句中的表或者字段是否存在、将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列</li><li>优化器：将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</li><li>执行器：与存引擎交互，过程为：<ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul></li></ul><p>5、总结</p><p>执行一条 SQL 查询语句，期间发生了什么？</p><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列；</li><li>优化阶段：基于查询成本的考虑，选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><h3 id="MySQL字段类型"><a href="#MySQL字段类型" class="headerlink" title="MySQL字段类型"></a>MySQL字段类型</h3><p>1、整数类型的UNSIGNED属性，表示不允许负值的无符号整数，可将正整数的上限提高一倍<br>2、字符串类型：CHAR和VARCHAR，CHAR是定长字符串，VARCHAR是变长字符串。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CHAR</span> 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 <span class="hljs-number">1</span> 或 <span class="hljs-number">2</span> 个额外字节记录字符串的长度，检索时不需要处理。<br></code></pre></td></tr></table></figure><p>3、定点类型DECIMAL和浮点类型FLOAT&#x2F;DOUBLE: DECIMAL可以存储精确的小数值（货币相关），FLOAT&#x2F;DOUBLE只能存储近似的小数值<br>4、时间类型： </p><ul><li>DATETIME(8字节)：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 </li><li>TIMESTAMP(4字节)：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li></ul><h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>事务就是一组原子性的SQL执行单元，其中的SQL语句要么全部成功，只要有一条失败，事务就会回滚</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>Atomicity：原子性，单个事务，不可能只执行其中的一部分SQL语句，所有语句要么全部执行成功，要么全部失败。</li><li>Consistency：一致性，事务保证了数据库的数据从一个状态转移到另一个状态，比如四条语句，第一条update使得money - 100，但是只要事务没有成功提交，这个update操作也不会成功，money不会-100，保证了数据的一致性。</li><li>Isolation：隔离性，一个事务所做的修改在还未成功提交之前，对其他事务是不可见的，比如money-100的事务还未提交之前的任意时刻，其他事务来查询money都是未-100的原始数据。</li><li>Durability：持久性，一旦事务提交，其所做的修改就永久保存到数据库中</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><h4 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h4><p>Read Uncommitted，允许事务访问其他事务未提交的数据</p><p>脏读，不可重复读，幻读</p><h4 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h4><p>Read Committed，事务只能访问其他事务已提交的数据</p><p>不可重复读，幻读</p><h4 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h4><p>Repeatable Read，事务执行过程中访问的数据都是事务开启之前的。也就是说事务执行过程中维护一个事务开启前的数据Read view。Innodb默认隔离级别</p><p>幻读</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p> Serializable，顾名思义，对记录加上读写锁，如果发生读写冲突，事务按照访问的先后顺序执行</p><ul><li>脏读：事务读取到其他事务还未提交的数据</li><li>不可重复读：事务<strong>多次读取同一个数据</strong>前后两次数据不一致</li><li>幻读：事务多次查询某记录数量前后两次记录数量不一致（记录被增删）</li></ul><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><p>1、MySQL存储引擎架构：采用插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。目前MySQL默认使用InnoDB</p><h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><p>1、索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了B+树作为索引结构。索引存储在文件系统中，占用物理空间。</p><p>2、索引结构优劣对比</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">对于树型索引结构，树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。<br></code></pre></td></tr></table></figure><ul><li>Hash：不支持范围查询</li><li>二叉搜索树：极端情况会成为一个链表</li><li>二叉平衡树（AVL）：频繁旋转降低性能、每个树节点存储一个数据，若查询的数据分布在多个节点，会进行多次磁盘IO</li><li>红黑树：平衡性较弱，可能导致树高变高。但插入删除操作仅需O(1)，因此TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。</li><li>B 树：数据分布在整棵树中，检索的过程相当于对范围内的每个节点的关键字做二分查找</li><li>B+ 树：数据只存在于叶子结点，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li></ul><p>3、索引分类</p><p>按功能（逻辑分类）</p><ul><li>主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL。</li><li>唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入。</li><li>全文索引：它查找的是文本中的关键词，主要用于全文检索。</li></ul><p>按列数（逻辑分类）</p><ul><li>单例索引：一个索引只包含一个列，一个表可以有多个单例索引。</li><li>组合索引：一个组合索引包含两个或两个以上的列。查询的时候遵循 mysql 组合索引的 “最左前缀”原则，即使用 where 时条件要按照建立索引的时候字段的排列方式放置索引才会生效。</li></ul><p>物理分类</p><ul><li>聚簇索引（clustered index）：数据和索引存储在一块，找到了索引就找到了需要的数据，那么这个索引就是聚簇索引。主键索引是聚簇索引。</li><li>二级索引：数据与索引分开存储，索引结构的叶子节点挂的是对应的主键<br><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.png" alt="聚集索引和回表查询"></li></ul><h3 id="什么时候需要-不需要创建索引？"><a href="#什么时候需要-不需要创建索引？" class="headerlink" title="什么时候需要 &#x2F; 不需要创建索引？"></a>什么时候需要 &#x2F; 不需要创建索引？</h3><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p>什么时候适用索引？</p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><p>什么时候不需要创建索引？</p><ul><li>字段中存在大量重复数据时，如性别；</li><li>表数据太少时；</li><li>经常更新的字段不需要创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree 的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li></ul><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ul><li>测试数据如下</li></ul><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/1.png" alt="tb_user表"></p><ul><li><p>创建索引 </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_name <span class="hljs-keyword">on</span> tb_user(name)<span class="hljs-punctuation">;</span><span class="hljs-comment">//普通索引</span><br><span class="hljs-keyword">create</span> UNIQUE <span class="hljs-keyword">index</span> idx_user_phone <span class="hljs-keyword">on</span> tb_user(phone)<span class="hljs-punctuation">;</span><span class="hljs-comment">//唯一索引</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user(profession, age, status)<span class="hljs-punctuation">;</span><span class="hljs-comment">//联合索引</span><br></code></pre></td></tr></table></figure></li><li><p>查看索引 </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95.png" alt="查看索引"></p></li><li><p>删除索引 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">index</span> user_name <span class="hljs-keyword">on</span> tb_user;<br></code></pre></td></tr></table></figure></li></ul><h3 id="索引性能分析"><a href="#索引性能分析" class="headerlink" title="索引性能分析"></a>索引性能分析</h3><ul><li>explain<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/explain.png" alt="explain语法"></li></ul><h3 id="最左前缀匹配法则"><a href="#最左前缀匹配法则" class="headerlink" title="最左前缀匹配法则"></a>最左前缀匹配法则</h3><p>使用上面创建的联合索引<code>idx_user_pro_age_sta</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-operator">=</span> &quot;软件工程&quot; <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-comment">----或者----</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">31</span> <span class="hljs-keyword">and</span> status <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> profession <span class="hljs-operator">=</span> &quot;软件工程&quot;;<br>查询语句中profession的位置不影响使用索引<br></code></pre></td></tr></table></figure><p>索引会从创建索引时最左边的字段<code>profession</code>开始匹配，若存在就走索引，依次匹配下去，下图就是三个索引均用到了</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="使用全部索引"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&quot;软件工程&quot;</span> and status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>age</code>没有匹配，则<code>status</code>也无法匹配</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/5.png" alt="仅用到profession索引"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> age = <span class="hljs-number">31</span> and status = <span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>最左前缀<code>profession</code>没有匹配，此条查询未走索引</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/6.png" alt="未走索引"></p><h3 id="索引失效原则"><a href="#索引失效原则" class="headerlink" title="索引失效原则"></a>索引失效原则</h3><ul><li>使用函数</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//查询手机号后两位等于15的user</span><br> <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> <span class="hljs-title">substring</span>(<span class="hljs-params">phone, <span class="hljs-number">10</span>, <span class="hljs-number">2</span></span>)</span> = <span class="hljs-string">&#x27;15&#x27;</span>; <span class="hljs-comment">//phone索引失效</span><br></code></pre></td></tr></table></figure><ul><li><p>字符串未加引号</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone = <span class="hljs-number">17799990015</span>; <span class="hljs-comment">//查询是能查询出来的，但是没走phone的索引</span><br></code></pre></td></tr></table></figure></li><li><p>模糊查询</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;软件%&#x27;</span>; <span class="hljs-comment">//尾部模糊匹配，索引不失效</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%工程&#x27;</span>; <span class="hljs-comment">//头部模糊匹配，索引失效</span><br></code></pre></td></tr></table></figure></li><li><p>or 连接的条件</p></li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id = <span class="hljs-string">&#x27;10&#x27;</span> or age = <span class="hljs-string">&#x27;30&#x27;</span>; <span class="hljs-comment">//若or前面的条件有索引，后面的条件没有索引，索引失效</span><br></code></pre></td></tr></table></figure><ul><li>数据分布情况</li></ul><p>MySQL视情况决定走不走索引</p><h3 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user use <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//建议数据库使用该索引</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user ignore <span class="hljs-keyword">index</span>(idx_user_pro_age_sta) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//让数据库忽略该索引</span><br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user force <span class="hljs-keyword">index</span>(idx_user_pro) <span class="hljs-keyword">where</span> profession = <span class="hljs-string">&#x27;软件工程&#x27;</span>; <span class="hljs-comment">//强制数据库使用该索引</span><br></code></pre></td></tr></table></figure><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">create</span> <span class="hljs-keyword">index</span> idx_email_5 <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>))<span class="hljs-punctuation">;</span><span class="hljs-comment">//数字5代表取email的前五个字符作为前缀索引，节省索引空间，降低建立索引的消耗</span><br></code></pre></td></tr></table></figure><h3 id="覆盖索引和回表查询"><a href="#覆盖索引和回表查询" class="headerlink" title="覆盖索引和回表查询"></a>覆盖索引和回表查询</h3><p>创建一个 phone 和 name 的联合索引，表中目前索引有：</p><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/7.png" alt="查看索引"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> id,phone,<span class="hljs-type">name</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone = <span class="hljs-string">&#x27;17799990010&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;韩信&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/11/MySQL%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/8.png" alt="分析索引执行情况"></p><ul><li><p>回表查询：由于 phone 和 name 均有唯一索引，而当前查询只走了 idx_user_phone 这条索引，故会根据 idx_user_phone 下的 id 值进行回表查询，查询 name </p></li><li><p>覆盖索引：<code>select id,name from tb_user wherename = &#39;韩信&#39;;</code>，idx_user_name 这条索引的叶子结点下挂的就是 id 值， 不需要回表查询，就叫覆盖索引</p></li></ul><h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>通过 long_query_time 参数定义一个SQL耗时多长才被定义为慢查询，默认10s</p><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>日志格式</p><ul><li>STATEMENT：记录对数据进行修改的SQL语句，如update，insert</li><li>ROW：基于行的日志，记录每一行的数据变更</li><li>MIXED：混合statement和row，默认statement</li></ul><h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>锁住了DML和DDL操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br>unlock tables<br></code></pre></td></tr></table></figure><blockquote><p> 全局锁应用场景是什么？</p></blockquote><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。当然这样锁住整个数据库对业务的影响很大。</p><p>如果数据库引擎支持可重复读 隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent write;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>会释放所有表的锁<br>unlock tables<br></code></pre></td></tr></table></figure><p>元数据锁：（Meta Data Lock），在表上有活动事务的时候，不可以对元数据进行写入操作，保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当我们对数据库表进行操作时，会自动给这个表加上 MDL，MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>，这些语句必须放在事务中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>普通查询不加锁（除了串行化隔离级别）<br><span class="hljs-keyword">select</span> ...<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>共享锁（S型锁）<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>排他锁（独占锁、X型锁）<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br><span class="hljs-keyword">insert</span>、<span class="hljs-keyword">update</span>、<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>不同隔离级别下，行级锁的种类是不同的。</p><p>在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。</p><p>在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上，有S锁和X锁之分；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><p><strong>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果没走索引是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong></p><h4 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h4><ul><li>互斥</li><li>占有并等待</li><li>不可剥夺</li><li>循环等待</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java导出word文档--XWPFDocument</title>
    <link href="/2024/04/05/Java%E5%AF%BC%E5%87%BAword%E6%96%87%E6%A1%A3-XWPFDocument/"/>
    <url>/2024/04/05/Java%E5%AF%BC%E5%87%BAword%E6%96%87%E6%A1%A3-XWPFDocument/</url>
    
    <content type="html"><![CDATA[<h3 id="依赖导入"><a href="#依赖导入" class="headerlink" title="依赖导入"></a>依赖导入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>poi-ooxml<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">XWPFDocument document = <span class="hljs-keyword">new</span> <span class="hljs-built_in">XWPFDocument</span>(); <span class="hljs-comment">//创建了一个新的空白 Word 文档</span><br>XWPFParagraph Paragraph = document.<span class="hljs-built_in">createParagraph</span>(); <span class="hljs-comment">//这行代码创建了一个新的段落对象，并将其添加到刚刚创建的 Word 文档中</span><br>Paragraph.<span class="hljs-built_in">setAlignment</span>(ParagraphAlignment.CENTER); <span class="hljs-comment">//设置对齐方式</span><br>XWPFRun run = Paragraph.<span class="hljs-built_in">createRun</span>(); <span class="hljs-comment">//XWPFRun 对象代表 Word 文档中的一个文本运行（run）,可以通过操作这个文本运行对象来设置文本内容、样式、字体等属性。</span><br>run.<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//这里是输入到word的文本</span><br>run.<span class="hljs-built_in">setBold</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//设置字体加粗</span><br>run.<span class="hljs-built_in">setFontSize</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">//设置字体大小（12磅对应小四）</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用数组模拟邻接表</title>
    <link href="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <url>/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="数组模拟邻接表的难点"><a href="#数组模拟邻接表的难点" class="headerlink" title="数组模拟邻接表的难点"></a>数组模拟邻接表的难点</h2><p>看了一圈博客、ACwing的解释仍然云里雾里，大多数同学都在绞尽脑汁想给大家讲明白每个数组代表什么含义，什么 <strong>e[]</strong> 数组啊，<strong>ne[]</strong> 数组等等。其实差的只是最后一步，就是模拟完add(a, b)建表之后，再带着大家走一遍顺着邻接表读取的过程，瞬间就会豁然开朗，此篇文章适合已经了解了数组模拟邻接表的基本代码和原理但仍然云里雾里的同学。</p><h4 id="一、建表"><a href="#一、建表" class="headerlink" title="一、建表"></a>一、建表</h4><ul><li><p>补充一点初始条件：idx初值为0，h[]数组中的每个值已被初始化为-1，即：h[-1, -1, -1, -1, -1]。你先不管为什么初始化为-1，看到后面就明白了。</p></li><li><p>先贴代码</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">void add(a, b) &#123;<br>    e<span class="hljs-comment">[idx]</span> = b;<br>    ne<span class="hljs-comment">[idx]</span> = h<span class="hljs-comment">[a]</span>;<br>    h<span class="hljs-comment">[a]</span> = idx ++;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如下图，请按照add(1, 2)、add(2, 4)、add(1, 3)、add(3, 4)的顺序构建邻接表，现在你不用管那些数组是什么意思，只需要按照add方法往几个数组中更新值就行<br><img src="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/image.png"></p></li><li><p>最后得到和我一样的几个数组就算胜利：</p><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style></li></ul><div class="center"><table><thead><tr><th align="center">数组下标</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">-1</td><td align="center">2</td><td align="center">1</td><td align="center">3</td><td align="center">-1</td></tr><tr><td align="center">e</td><td align="center">2</td><td align="center">4</td><td align="center">3</td><td align="center">4</td><td align="center"></td></tr><tr><td align="center">ne</td><td align="center">-1</td><td align="center">-1</td><td align="center">0</td><td align="center">-1</td><td align="center"></td></tr></tbody></table></div><ul><li><p>此时idx的值为3</p></li><li><p>再次补充前置知识：初始情况下，邻接表为中元素1后面没有连接任何元素，可以理解为 <strong>1 -&gt; -1</strong>，这里-1代表后面没有元素。<strong>add(1, 2)</strong> 后，即在1后面插入2，就变成 <strong>1 -&gt; 2 -&gt; -1</strong>，<strong>add(1, 3)<strong>后，变成</strong>1 -&gt; 3 -&gt; 2 -&gt; -1</strong>，可以发现add操作是在表头后面插入新元素的，而不是在链表的尾部插入。</p></li></ul><h4 id="二、开始模拟"><a href="#二、开始模拟" class="headerlink" title="二、开始模拟"></a>二、开始模拟</h4><ul><li>只需一遍，你就会明白</li><li>如果我们想获取结点1对应的这个链表，即获取 <strong>1 -&gt; 3 -&gt; 2</strong>，首先找到 <strong>h[1] &#x3D; 2</strong>，那么 <strong>e[2] &#x3D; 3</strong> 就是结点1的在表中的下一个结点，即 <strong>1 -&gt; 3</strong>；接着<strong>ne[2] &#x3D; 0</strong>就代表再下一个结点在<strong>e[0]<strong>处，</strong>e[0] &#x3D; 2</strong>， 即<strong>1 -&gt; 3 -&gt; 2</strong>；接着<strong>ne[0] &#x3D; -1</strong>就代表没有下一个结点了，即<strong>1 -&gt; 3 -&gt; 2 -&gt; -1</strong>，怎么样是不是很简单。</li><li>所以可以总结出：e数组就是存放下一个结点的数组，而ne数组是存放去e数组的哪个位置找结点的数组</li></ul><p><img src="/2024/04/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%82%BB%E6%8E%A5%E8%A1%A8/image-1.png"></p><ul><li>再看这张图，可以发现，我们调用add()函数建表时就是用idx来给每条边编号的，同时<strong>h</strong>数组中存放的就是每个结点到它的下一个第一个结点的边的编号，例如 <strong>2 -&gt; 4</strong>，查询<strong>h[2] &#x3D; 1</strong>，即为图中对应边的编号。</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
